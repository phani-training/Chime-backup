// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video_control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_video_5fcontrol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_video_5fcontrol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_video_5fcontrol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[47]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace signal_rtc {
class AudioControlFrame;
class AudioControlFrameDefaultTypeInternal;
extern AudioControlFrameDefaultTypeInternal _AudioControlFrame_default_instance_;
class AudioMetadataFrame;
class AudioMetadataFrameDefaultTypeInternal;
extern AudioMetadataFrameDefaultTypeInternal _AudioMetadataFrame_default_instance_;
class AudioProfileState;
class AudioProfileStateDefaultTypeInternal;
extern AudioProfileStateDefaultTypeInternal _AudioProfileState_default_instance_;
class AudioStatusFrame;
class AudioStatusFrameDefaultTypeInternal;
extern AudioStatusFrameDefaultTypeInternal _AudioStatusFrame_default_instance_;
class AudioStreamIdInfo;
class AudioStreamIdInfoDefaultTypeInternal;
extern AudioStreamIdInfoDefaultTypeInternal _AudioStreamIdInfo_default_instance_;
class AudioStreamIdInfoFrame;
class AudioStreamIdInfoFrameDefaultTypeInternal;
extern AudioStreamIdInfoFrameDefaultTypeInternal _AudioStreamIdInfoFrame_default_instance_;
class AudioTranscript;
class AudioTranscriptDefaultTypeInternal;
extern AudioTranscriptDefaultTypeInternal _AudioTranscript_default_instance_;
class AudioTranscriptAlternative;
class AudioTranscriptAlternativeDefaultTypeInternal;
extern AudioTranscriptAlternativeDefaultTypeInternal _AudioTranscriptAlternative_default_instance_;
class AudioTranscriptEntity;
class AudioTranscriptEntityDefaultTypeInternal;
extern AudioTranscriptEntityDefaultTypeInternal _AudioTranscriptEntity_default_instance_;
class AudioTranscriptEvent;
class AudioTranscriptEventDefaultTypeInternal;
extern AudioTranscriptEventDefaultTypeInternal _AudioTranscriptEvent_default_instance_;
class AudioTranscriptFrame;
class AudioTranscriptFrameDefaultTypeInternal;
extern AudioTranscriptFrameDefaultTypeInternal _AudioTranscriptFrame_default_instance_;
class AudioTranscriptItem;
class AudioTranscriptItemDefaultTypeInternal;
extern AudioTranscriptItemDefaultTypeInternal _AudioTranscriptItem_default_instance_;
class AudioTranscriptResult;
class AudioTranscriptResultDefaultTypeInternal;
extern AudioTranscriptResultDefaultTypeInternal _AudioTranscriptResult_default_instance_;
class Bitrate;
class BitrateDefaultTypeInternal;
extern BitrateDefaultTypeInternal _Bitrate_default_instance_;
class BitrateFrame;
class BitrateFrameDefaultTypeInternal;
extern BitrateFrameDefaultTypeInternal _BitrateFrame_default_instance_;
class BridgeJoinAckFrame;
class BridgeJoinAckFrameDefaultTypeInternal;
extern BridgeJoinAckFrameDefaultTypeInternal _BridgeJoinAckFrame_default_instance_;
class BridgeJoinFrame;
class BridgeJoinFrameDefaultTypeInternal;
extern BridgeJoinFrameDefaultTypeInternal _BridgeJoinFrame_default_instance_;
class BridgeReserveAckFrame;
class BridgeReserveAckFrameDefaultTypeInternal;
extern BridgeReserveAckFrameDefaultTypeInternal _BridgeReserveAckFrame_default_instance_;
class BridgeReserveFrame;
class BridgeReserveFrameDefaultTypeInternal;
extern BridgeReserveFrameDefaultTypeInternal _BridgeReserveFrame_default_instance_;
class ClientDetails;
class ClientDetailsDefaultTypeInternal;
extern ClientDetailsDefaultTypeInternal _ClientDetails_default_instance_;
class ClientMetricFrame;
class ClientMetricFrameDefaultTypeInternal;
extern ClientMetricFrameDefaultTypeInternal _ClientMetricFrame_default_instance_;
class DataMessageFrame;
class DataMessageFrameDefaultTypeInternal;
extern DataMessageFrameDefaultTypeInternal _DataMessageFrame_default_instance_;
class DataMessagePayload;
class DataMessagePayloadDefaultTypeInternal;
extern DataMessagePayloadDefaultTypeInternal _DataMessagePayload_default_instance_;
class ErrorFrame;
class ErrorFrameDefaultTypeInternal;
extern ErrorFrameDefaultTypeInternal _ErrorFrame_default_instance_;
class IndexFrame;
class IndexFrameDefaultTypeInternal;
extern IndexFrameDefaultTypeInternal _IndexFrame_default_instance_;
class JoinAckFrame;
class JoinAckFrameDefaultTypeInternal;
extern JoinAckFrameDefaultTypeInternal _JoinAckFrame_default_instance_;
class JoinFrame;
class JoinFrameDefaultTypeInternal;
extern JoinFrameDefaultTypeInternal _JoinFrame_default_instance_;
class LeaveAckFrame;
class LeaveAckFrameDefaultTypeInternal;
extern LeaveAckFrameDefaultTypeInternal _LeaveAckFrame_default_instance_;
class LeaveFrame;
class LeaveFrameDefaultTypeInternal;
extern LeaveFrameDefaultTypeInternal _LeaveFrame_default_instance_;
class MeetingSessionCredentials;
class MeetingSessionCredentialsDefaultTypeInternal;
extern MeetingSessionCredentialsDefaultTypeInternal _MeetingSessionCredentials_default_instance_;
class MeetingTranscriptionStatus;
class MeetingTranscriptionStatusDefaultTypeInternal;
extern MeetingTranscriptionStatusDefaultTypeInternal _MeetingTranscriptionStatus_default_instance_;
class Metric;
class MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class PauseResumeFrame;
class PauseResumeFrameDefaultTypeInternal;
extern PauseResumeFrameDefaultTypeInternal _PauseResumeFrame_default_instance_;
class PingPongFrame;
class PingPongFrameDefaultTypeInternal;
extern PingPongFrameDefaultTypeInternal _PingPongFrame_default_instance_;
class PrimaryMeetingJoinAckFrame;
class PrimaryMeetingJoinAckFrameDefaultTypeInternal;
extern PrimaryMeetingJoinAckFrameDefaultTypeInternal _PrimaryMeetingJoinAckFrame_default_instance_;
class PrimaryMeetingJoinFrame;
class PrimaryMeetingJoinFrameDefaultTypeInternal;
extern PrimaryMeetingJoinFrameDefaultTypeInternal _PrimaryMeetingJoinFrame_default_instance_;
class PrimaryMeetingLeaveFrame;
class PrimaryMeetingLeaveFrameDefaultTypeInternal;
extern PrimaryMeetingLeaveFrameDefaultTypeInternal _PrimaryMeetingLeaveFrame_default_instance_;
class RemoteVideoUpdateFrame;
class RemoteVideoUpdateFrameDefaultTypeInternal;
extern RemoteVideoUpdateFrameDefaultTypeInternal _RemoteVideoUpdateFrame_default_instance_;
class SignalFrame;
class SignalFrameDefaultTypeInternal;
extern SignalFrameDefaultTypeInternal _SignalFrame_default_instance_;
class StreamAllocation;
class StreamAllocationDefaultTypeInternal;
extern StreamAllocationDefaultTypeInternal _StreamAllocation_default_instance_;
class StreamDescriptor;
class StreamDescriptorDefaultTypeInternal;
extern StreamDescriptorDefaultTypeInternal _StreamDescriptor_default_instance_;
class StreamMetricFrame;
class StreamMetricFrameDefaultTypeInternal;
extern StreamMetricFrameDefaultTypeInternal _StreamMetricFrame_default_instance_;
class SubscribeAckFrame;
class SubscribeAckFrameDefaultTypeInternal;
extern SubscribeAckFrameDefaultTypeInternal _SubscribeAckFrame_default_instance_;
class SubscribeFrame;
class SubscribeFrameDefaultTypeInternal;
extern SubscribeFrameDefaultTypeInternal _SubscribeFrame_default_instance_;
class TrackMapping;
class TrackMappingDefaultTypeInternal;
extern TrackMappingDefaultTypeInternal _TrackMapping_default_instance_;
class TurnCredentials;
class TurnCredentialsDefaultTypeInternal;
extern TurnCredentialsDefaultTypeInternal _TurnCredentials_default_instance_;
class VideoSubscriptionConfiguration;
class VideoSubscriptionConfigurationDefaultTypeInternal;
extern VideoSubscriptionConfigurationDefaultTypeInternal _VideoSubscriptionConfiguration_default_instance_;
}  // namespace signal_rtc
PROTOBUF_NAMESPACE_OPEN
template<> ::signal_rtc::AudioControlFrame* Arena::CreateMaybeMessage<::signal_rtc::AudioControlFrame>(Arena*);
template<> ::signal_rtc::AudioMetadataFrame* Arena::CreateMaybeMessage<::signal_rtc::AudioMetadataFrame>(Arena*);
template<> ::signal_rtc::AudioProfileState* Arena::CreateMaybeMessage<::signal_rtc::AudioProfileState>(Arena*);
template<> ::signal_rtc::AudioStatusFrame* Arena::CreateMaybeMessage<::signal_rtc::AudioStatusFrame>(Arena*);
template<> ::signal_rtc::AudioStreamIdInfo* Arena::CreateMaybeMessage<::signal_rtc::AudioStreamIdInfo>(Arena*);
template<> ::signal_rtc::AudioStreamIdInfoFrame* Arena::CreateMaybeMessage<::signal_rtc::AudioStreamIdInfoFrame>(Arena*);
template<> ::signal_rtc::AudioTranscript* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscript>(Arena*);
template<> ::signal_rtc::AudioTranscriptAlternative* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptAlternative>(Arena*);
template<> ::signal_rtc::AudioTranscriptEntity* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptEntity>(Arena*);
template<> ::signal_rtc::AudioTranscriptEvent* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptEvent>(Arena*);
template<> ::signal_rtc::AudioTranscriptFrame* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptFrame>(Arena*);
template<> ::signal_rtc::AudioTranscriptItem* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptItem>(Arena*);
template<> ::signal_rtc::AudioTranscriptResult* Arena::CreateMaybeMessage<::signal_rtc::AudioTranscriptResult>(Arena*);
template<> ::signal_rtc::Bitrate* Arena::CreateMaybeMessage<::signal_rtc::Bitrate>(Arena*);
template<> ::signal_rtc::BitrateFrame* Arena::CreateMaybeMessage<::signal_rtc::BitrateFrame>(Arena*);
template<> ::signal_rtc::BridgeJoinAckFrame* Arena::CreateMaybeMessage<::signal_rtc::BridgeJoinAckFrame>(Arena*);
template<> ::signal_rtc::BridgeJoinFrame* Arena::CreateMaybeMessage<::signal_rtc::BridgeJoinFrame>(Arena*);
template<> ::signal_rtc::BridgeReserveAckFrame* Arena::CreateMaybeMessage<::signal_rtc::BridgeReserveAckFrame>(Arena*);
template<> ::signal_rtc::BridgeReserveFrame* Arena::CreateMaybeMessage<::signal_rtc::BridgeReserveFrame>(Arena*);
template<> ::signal_rtc::ClientDetails* Arena::CreateMaybeMessage<::signal_rtc::ClientDetails>(Arena*);
template<> ::signal_rtc::ClientMetricFrame* Arena::CreateMaybeMessage<::signal_rtc::ClientMetricFrame>(Arena*);
template<> ::signal_rtc::DataMessageFrame* Arena::CreateMaybeMessage<::signal_rtc::DataMessageFrame>(Arena*);
template<> ::signal_rtc::DataMessagePayload* Arena::CreateMaybeMessage<::signal_rtc::DataMessagePayload>(Arena*);
template<> ::signal_rtc::ErrorFrame* Arena::CreateMaybeMessage<::signal_rtc::ErrorFrame>(Arena*);
template<> ::signal_rtc::IndexFrame* Arena::CreateMaybeMessage<::signal_rtc::IndexFrame>(Arena*);
template<> ::signal_rtc::JoinAckFrame* Arena::CreateMaybeMessage<::signal_rtc::JoinAckFrame>(Arena*);
template<> ::signal_rtc::JoinFrame* Arena::CreateMaybeMessage<::signal_rtc::JoinFrame>(Arena*);
template<> ::signal_rtc::LeaveAckFrame* Arena::CreateMaybeMessage<::signal_rtc::LeaveAckFrame>(Arena*);
template<> ::signal_rtc::LeaveFrame* Arena::CreateMaybeMessage<::signal_rtc::LeaveFrame>(Arena*);
template<> ::signal_rtc::MeetingSessionCredentials* Arena::CreateMaybeMessage<::signal_rtc::MeetingSessionCredentials>(Arena*);
template<> ::signal_rtc::MeetingTranscriptionStatus* Arena::CreateMaybeMessage<::signal_rtc::MeetingTranscriptionStatus>(Arena*);
template<> ::signal_rtc::Metric* Arena::CreateMaybeMessage<::signal_rtc::Metric>(Arena*);
template<> ::signal_rtc::PauseResumeFrame* Arena::CreateMaybeMessage<::signal_rtc::PauseResumeFrame>(Arena*);
template<> ::signal_rtc::PingPongFrame* Arena::CreateMaybeMessage<::signal_rtc::PingPongFrame>(Arena*);
template<> ::signal_rtc::PrimaryMeetingJoinAckFrame* Arena::CreateMaybeMessage<::signal_rtc::PrimaryMeetingJoinAckFrame>(Arena*);
template<> ::signal_rtc::PrimaryMeetingJoinFrame* Arena::CreateMaybeMessage<::signal_rtc::PrimaryMeetingJoinFrame>(Arena*);
template<> ::signal_rtc::PrimaryMeetingLeaveFrame* Arena::CreateMaybeMessage<::signal_rtc::PrimaryMeetingLeaveFrame>(Arena*);
template<> ::signal_rtc::RemoteVideoUpdateFrame* Arena::CreateMaybeMessage<::signal_rtc::RemoteVideoUpdateFrame>(Arena*);
template<> ::signal_rtc::SignalFrame* Arena::CreateMaybeMessage<::signal_rtc::SignalFrame>(Arena*);
template<> ::signal_rtc::StreamAllocation* Arena::CreateMaybeMessage<::signal_rtc::StreamAllocation>(Arena*);
template<> ::signal_rtc::StreamDescriptor* Arena::CreateMaybeMessage<::signal_rtc::StreamDescriptor>(Arena*);
template<> ::signal_rtc::StreamMetricFrame* Arena::CreateMaybeMessage<::signal_rtc::StreamMetricFrame>(Arena*);
template<> ::signal_rtc::SubscribeAckFrame* Arena::CreateMaybeMessage<::signal_rtc::SubscribeAckFrame>(Arena*);
template<> ::signal_rtc::SubscribeFrame* Arena::CreateMaybeMessage<::signal_rtc::SubscribeFrame>(Arena*);
template<> ::signal_rtc::TrackMapping* Arena::CreateMaybeMessage<::signal_rtc::TrackMapping>(Arena*);
template<> ::signal_rtc::TurnCredentials* Arena::CreateMaybeMessage<::signal_rtc::TurnCredentials>(Arena*);
template<> ::signal_rtc::VideoSubscriptionConfiguration* Arena::CreateMaybeMessage<::signal_rtc::VideoSubscriptionConfiguration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace signal_rtc {

enum SignalFrame_Type : int {
  SignalFrame_Type_JOIN = 1,
  SignalFrame_Type_JOIN_ACK = 2,
  SignalFrame_Type_SUBSCRIBE = 3,
  SignalFrame_Type_SUBSCRIBE_ACK = 4,
  SignalFrame_Type_INDEX = 5,
  SignalFrame_Type_PAUSE = 7,
  SignalFrame_Type_RESUME = 8,
  SignalFrame_Type_LEAVE = 9,
  SignalFrame_Type_LEAVE_ACK = 10,
  SignalFrame_Type_BITRATES = 13,
  SignalFrame_Type_AUDIO_CONTROL = 16,
  SignalFrame_Type_AUDIO_METADATA = 17,
  SignalFrame_Type_AUDIO_STREAM_ID_INFO = 18,
  SignalFrame_Type_PING_PONG = 19,
  SignalFrame_Type_AUDIO_STATUS = 20,
  SignalFrame_Type_CLIENT_METRIC = 21,
  SignalFrame_Type_DATA_MESSAGE = 22,
  SignalFrame_Type_AUDIO_TRANSCRIPT = 23,
  SignalFrame_Type_REMOTE_VIDEO_UPDATE = 24,
  SignalFrame_Type_PRIMARY_MEETING_JOIN = 25,
  SignalFrame_Type_PRIMARY_MEETING_JOIN_ACK = 26,
  SignalFrame_Type_PRIMARY_MEETING_LEAVE = 27,
  SignalFrame_Type_BRIDGE_JOIN = 28,
  SignalFrame_Type_BRIDGE_JOIN_ACK = 29,
  SignalFrame_Type_BRIDGE_RESERVE = 30,
  SignalFrame_Type_BRIDGE_RESERVE_ACK = 31
};
bool SignalFrame_Type_IsValid(int value);
constexpr SignalFrame_Type SignalFrame_Type_Type_MIN = SignalFrame_Type_JOIN;
constexpr SignalFrame_Type SignalFrame_Type_Type_MAX = SignalFrame_Type_BRIDGE_RESERVE_ACK;
constexpr int SignalFrame_Type_Type_ARRAYSIZE = SignalFrame_Type_Type_MAX + 1;

const std::string& SignalFrame_Type_Name(SignalFrame_Type value);
template<typename T>
inline const std::string& SignalFrame_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalFrame_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalFrame_Type_Name.");
  return SignalFrame_Type_Name(static_cast<SignalFrame_Type>(enum_t_value));
}
bool SignalFrame_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalFrame_Type* value);
enum Metric_Type : int {
  Metric_Type_VIDEO_ACTUAL_ENCODER_BITRATE = 1,
  Metric_Type_VIDEO_AVAILABLE_SEND_BANDWIDTH = 2,
  Metric_Type_VIDEO_RETRANSMIT_BITRATE = 3,
  Metric_Type_VIDEO_AVAILABLE_RECEIVE_BANDWIDTH = 4,
  Metric_Type_VIDEO_TARGET_ENCODER_BITRATE = 5,
  Metric_Type_VIDEO_BUCKET_DELAY_MS = 6,
  Metric_Type_STUN_RTT_MS = 7,
  Metric_Type_SOCKET_DISCARDED_PPS = 8,
  Metric_Type_RTC_MIC_JITTER_MS = 9,
  Metric_Type_RTC_MIC_PPS = 10,
  Metric_Type_RTC_MIC_FRACTION_PACKET_LOST_PERCENT = 11,
  Metric_Type_RTC_MIC_BITRATE = 12,
  Metric_Type_RTC_MIC_RTT_MS = 13,
  Metric_Type_RTC_SPK_PPS = 14,
  Metric_Type_RTC_SPK_FRACTION_PACKET_LOST_PERCENT = 15,
  Metric_Type_RTC_SPK_JITTER_MS = 16,
  Metric_Type_RTC_SPK_FRACTION_DECODER_LOSS_PERCENT = 17,
  Metric_Type_RTC_SPK_BITRATE = 18,
  Metric_Type_RTC_SPK_CURRENT_DELAY_MS = 19,
  Metric_Type_RTC_SPK_JITTER_BUFFER_MS = 20,
  Metric_Type_VIDEO_SENT_RTT_MS = 21,
  Metric_Type_VIDEO_ENCODE_USAGE_PERCENT = 22,
  Metric_Type_VIDEO_NACKS_RECEIVED = 23,
  Metric_Type_VIDEO_PLIS_RECEIVED = 24,
  Metric_Type_VIDEO_AVERAGE_ENCODE_MS = 25,
  Metric_Type_VIDEO_INPUT_FPS = 26,
  Metric_Type_VIDEO_ENCODE_FPS = 27,
  Metric_Type_VIDEO_SENT_FPS = 28,
  Metric_Type_VIDEO_FIRS_RECEIVED = 29,
  Metric_Type_VIDEO_SENT_PPS = 30,
  Metric_Type_VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT = 31,
  Metric_Type_VIDEO_SENT_BITRATE = 32,
  Metric_Type_VIDEO_DROPPED_FPS = 33,
  Metric_Type_VIDEO_TARGET_DELAY_MS = 34,
  Metric_Type_VIDEO_DECODE_MS = 35,
  Metric_Type_VIDEO_OUTPUT_FPS = 36,
  Metric_Type_VIDEO_RECEIVED_PPS = 37,
  Metric_Type_VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT = 38,
  Metric_Type_VIDEO_RENDER_DELAY_MS = 39,
  Metric_Type_VIDEO_RECEIVED_FPS = 40,
  Metric_Type_VIDEO_DECODE_FPS = 41,
  Metric_Type_VIDEO_NACKS_SENT = 42,
  Metric_Type_VIDEO_FIRS_SENT = 43,
  Metric_Type_VIDEO_RECEIVED_BITRATE = 44,
  Metric_Type_VIDEO_CURRENT_DELAY_MS = 45,
  Metric_Type_VIDEO_JITTER_BUFFER_MS = 46,
  Metric_Type_VIDEO_DISCARDED_PPS = 47,
  Metric_Type_VIDEO_PLIS_SENT = 48,
  Metric_Type_VIDEO_RECEIVED_JITTER_MS = 49,
  Metric_Type_VIDEO_SUBSCRIBES_COMPLETED = 50,
  Metric_Type_VIDEO_RESETS_STARTED = 51,
  Metric_Type_VIDEO_LOCAL_RENDER_FPS = 52,
  Metric_Type_PROCESS_CPU = 54,
  Metric_Type_TOTAL_CPU = 55,
  Metric_Type_VIDEO_REMOTE_RENDER_FPS = 56,
  Metric_Type_VIDEO_INPUT_HEIGHT = 60,
  Metric_Type_VIDEO_INPUT_ASPECT_RATIO = 61,
  Metric_Type_VIDEO_SENT_SIMULCAST_STREAMS = 62,
  Metric_Type_VIDEO_SENT_KEYFRAMES = 63,
  Metric_Type_VIDEO_ENCODE_HEIGHT = 64,
  Metric_Type_VIDEO_ENCODE_ASPECT_RATIO = 65,
  Metric_Type_VIDEO_SENT_QP_SUM = 66,
  Metric_Type_VIDEO_ENCODER_CPU_ADAPTATION_DURATION = 67,
  Metric_Type_VIDEO_ENCODER_BW_ADAPTATION_DURATION = 68,
  Metric_Type_VIDEO_DECODE_HEIGHT = 69,
  Metric_Type_VIDEO_DECODE_ASPECT_RATIO = 70,
  Metric_Type_VIDEO_RECEIVED_KEYFRAMES = 71,
  Metric_Type_VIDEO_RECEIVED_QP_SUM = 72,
  Metric_Type_VIDEO_RECEIVED_TOTAL_FREEZE_DURATION = 73,
  Metric_Type_VIDEO_TARGET_SUBSCRIBED_BITRATE = 74,
  Metric_Type_VIDEO_ACTUAL_SUBSCRIBED_BITRATE = 75,
  Metric_Type_VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES = 76,
  Metric_Type_VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION = 77,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION = 78,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY = 79,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY = 80,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_DROPS = 81,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS = 82,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY = 83,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_SIGMA = 84,
  Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS = 85,
  Metric_Type_VIDEO_ENCODE_WIDTH = 86,
  Metric_Type_VIDEO_DECODE_WIDTH = 87
};
bool Metric_Type_IsValid(int value);
constexpr Metric_Type Metric_Type_Type_MIN = Metric_Type_VIDEO_ACTUAL_ENCODER_BITRATE;
constexpr Metric_Type Metric_Type_Type_MAX = Metric_Type_VIDEO_DECODE_WIDTH;
constexpr int Metric_Type_Type_ARRAYSIZE = Metric_Type_Type_MAX + 1;

const std::string& Metric_Type_Name(Metric_Type value);
template<typename T>
inline const std::string& Metric_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Metric_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Metric_Type_Name.");
  return Metric_Type_Name(static_cast<Metric_Type>(enum_t_value));
}
bool Metric_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Metric_Type* value);
enum AudioTranscriptItem_Type : int {
  AudioTranscriptItem_Type_PRONUNCIATION = 1,
  AudioTranscriptItem_Type_PUNCTUATION = 2
};
bool AudioTranscriptItem_Type_IsValid(int value);
constexpr AudioTranscriptItem_Type AudioTranscriptItem_Type_Type_MIN = AudioTranscriptItem_Type_PRONUNCIATION;
constexpr AudioTranscriptItem_Type AudioTranscriptItem_Type_Type_MAX = AudioTranscriptItem_Type_PUNCTUATION;
constexpr int AudioTranscriptItem_Type_Type_ARRAYSIZE = AudioTranscriptItem_Type_Type_MAX + 1;

const std::string& AudioTranscriptItem_Type_Name(AudioTranscriptItem_Type value);
template<typename T>
inline const std::string& AudioTranscriptItem_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioTranscriptItem_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioTranscriptItem_Type_Name.");
  return AudioTranscriptItem_Type_Name(static_cast<AudioTranscriptItem_Type>(enum_t_value));
}
bool AudioTranscriptItem_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioTranscriptItem_Type* value);
enum MeetingTranscriptionStatus_Type : int {
  MeetingTranscriptionStatus_Type_STARTED = 1,
  MeetingTranscriptionStatus_Type_INTERRUPTED = 2,
  MeetingTranscriptionStatus_Type_RESUMED = 3,
  MeetingTranscriptionStatus_Type_STOPPED = 4,
  MeetingTranscriptionStatus_Type_FAILED = 5
};
bool MeetingTranscriptionStatus_Type_IsValid(int value);
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus_Type_Type_MIN = MeetingTranscriptionStatus_Type_STARTED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus_Type_Type_MAX = MeetingTranscriptionStatus_Type_FAILED;
constexpr int MeetingTranscriptionStatus_Type_Type_ARRAYSIZE = MeetingTranscriptionStatus_Type_Type_MAX + 1;

const std::string& MeetingTranscriptionStatus_Type_Name(MeetingTranscriptionStatus_Type value);
template<typename T>
inline const std::string& MeetingTranscriptionStatus_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MeetingTranscriptionStatus_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MeetingTranscriptionStatus_Type_Name.");
  return MeetingTranscriptionStatus_Type_Name(static_cast<MeetingTranscriptionStatus_Type>(enum_t_value));
}
bool MeetingTranscriptionStatus_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MeetingTranscriptionStatus_Type* value);
enum BridgeReserveFrame_ReservationType : int {
  BridgeReserveFrame_ReservationType_VIDEO_INPUT = 1,
  BridgeReserveFrame_ReservationType_CONTENT_VIDEO_INPUT = 2
};
bool BridgeReserveFrame_ReservationType_IsValid(int value);
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame_ReservationType_ReservationType_MIN = BridgeReserveFrame_ReservationType_VIDEO_INPUT;
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame_ReservationType_ReservationType_MAX = BridgeReserveFrame_ReservationType_CONTENT_VIDEO_INPUT;
constexpr int BridgeReserveFrame_ReservationType_ReservationType_ARRAYSIZE = BridgeReserveFrame_ReservationType_ReservationType_MAX + 1;

const std::string& BridgeReserveFrame_ReservationType_Name(BridgeReserveFrame_ReservationType value);
template<typename T>
inline const std::string& BridgeReserveFrame_ReservationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BridgeReserveFrame_ReservationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BridgeReserveFrame_ReservationType_Name.");
  return BridgeReserveFrame_ReservationType_Name(static_cast<BridgeReserveFrame_ReservationType>(enum_t_value));
}
bool BridgeReserveFrame_ReservationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BridgeReserveFrame_ReservationType* value);
enum BridgeReserveFrame_Action : int {
  BridgeReserveFrame_Action_RESERVE = 1,
  BridgeReserveFrame_Action_RELEASE = 2
};
bool BridgeReserveFrame_Action_IsValid(int value);
constexpr BridgeReserveFrame_Action BridgeReserveFrame_Action_Action_MIN = BridgeReserveFrame_Action_RESERVE;
constexpr BridgeReserveFrame_Action BridgeReserveFrame_Action_Action_MAX = BridgeReserveFrame_Action_RELEASE;
constexpr int BridgeReserveFrame_Action_Action_ARRAYSIZE = BridgeReserveFrame_Action_Action_MAX + 1;

const std::string& BridgeReserveFrame_Action_Name(BridgeReserveFrame_Action value);
template<typename T>
inline const std::string& BridgeReserveFrame_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BridgeReserveFrame_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BridgeReserveFrame_Action_Name.");
  return BridgeReserveFrame_Action_Name(static_cast<BridgeReserveFrame_Action>(enum_t_value));
}
bool BridgeReserveFrame_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BridgeReserveFrame_Action* value);
enum JoinFlags : int {
  SEND_BITRATES = 1,
  HAS_STREAM_UPDATE = 2,
  USE_SEND_SIDE_BWE = 8,
  EXCLUDE_SELF_CONTENT_IN_INDEX = 32
};
bool JoinFlags_IsValid(int value);
constexpr JoinFlags JoinFlags_MIN = SEND_BITRATES;
constexpr JoinFlags JoinFlags_MAX = EXCLUDE_SELF_CONTENT_IN_INDEX;
constexpr int JoinFlags_ARRAYSIZE = JoinFlags_MAX + 1;

const std::string& JoinFlags_Name(JoinFlags value);
template<typename T>
inline const std::string& JoinFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinFlags_Name.");
  return JoinFlags_Name(static_cast<JoinFlags>(enum_t_value));
}
bool JoinFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinFlags* value);
enum StreamServiceType : int {
  RX = 1,
  TX = 2,
  DUPLEX = 3,
  IDLE = 4
};
bool StreamServiceType_IsValid(int value);
constexpr StreamServiceType StreamServiceType_MIN = RX;
constexpr StreamServiceType StreamServiceType_MAX = IDLE;
constexpr int StreamServiceType_ARRAYSIZE = StreamServiceType_MAX + 1;

const std::string& StreamServiceType_Name(StreamServiceType value);
template<typename T>
inline const std::string& StreamServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamServiceType_Name.");
  return StreamServiceType_Name(static_cast<StreamServiceType>(enum_t_value));
}
bool StreamServiceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamServiceType* value);
enum StreamMediaType : int {
  AUDIO = 1,
  VIDEO = 2
};
bool StreamMediaType_IsValid(int value);
constexpr StreamMediaType StreamMediaType_MIN = AUDIO;
constexpr StreamMediaType StreamMediaType_MAX = VIDEO;
constexpr int StreamMediaType_ARRAYSIZE = StreamMediaType_MAX + 1;

const std::string& StreamMediaType_Name(StreamMediaType value);
template<typename T>
inline const std::string& StreamMediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMediaType_Name.");
  return StreamMediaType_Name(static_cast<StreamMediaType>(enum_t_value));
}
bool StreamMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamMediaType* value);
enum PingPongType : int {
  PING = 1,
  PONG = 2
};
bool PingPongType_IsValid(int value);
constexpr PingPongType PingPongType_MIN = PING;
constexpr PingPongType PingPongType_MAX = PONG;
constexpr int PingPongType_ARRAYSIZE = PingPongType_MAX + 1;

const std::string& PingPongType_Name(PingPongType value);
template<typename T>
inline const std::string& PingPongType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PingPongType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PingPongType_Name.");
  return PingPongType_Name(static_cast<PingPongType>(enum_t_value));
}
bool PingPongType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PingPongType* value);
// ===================================================================

class SignalFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.SignalFrame) */ {
 public:
  inline SignalFrame() : SignalFrame(nullptr) {}
  virtual ~SignalFrame();

  SignalFrame(const SignalFrame& from);
  SignalFrame(SignalFrame&& from) noexcept
    : SignalFrame() {
    *this = ::std::move(from);
  }

  inline SignalFrame& operator=(const SignalFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalFrame& operator=(SignalFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SignalFrame& default_instance();

  static inline const SignalFrame* internal_default_instance() {
    return reinterpret_cast<const SignalFrame*>(
               &_SignalFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignalFrame& a, SignalFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SignalFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalFrame* New() const final {
    return CreateMaybeMessage<SignalFrame>(nullptr);
  }

  SignalFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SignalFrame& from);
  void MergeFrom(const SignalFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignalFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.SignalFrame";
  }
  protected:
  explicit SignalFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SignalFrame_Type Type;
  static constexpr Type JOIN =
    SignalFrame_Type_JOIN;
  static constexpr Type JOIN_ACK =
    SignalFrame_Type_JOIN_ACK;
  static constexpr Type SUBSCRIBE =
    SignalFrame_Type_SUBSCRIBE;
  static constexpr Type SUBSCRIBE_ACK =
    SignalFrame_Type_SUBSCRIBE_ACK;
  static constexpr Type INDEX =
    SignalFrame_Type_INDEX;
  static constexpr Type PAUSE =
    SignalFrame_Type_PAUSE;
  static constexpr Type RESUME =
    SignalFrame_Type_RESUME;
  static constexpr Type LEAVE =
    SignalFrame_Type_LEAVE;
  static constexpr Type LEAVE_ACK =
    SignalFrame_Type_LEAVE_ACK;
  static constexpr Type BITRATES =
    SignalFrame_Type_BITRATES;
  static constexpr Type AUDIO_CONTROL =
    SignalFrame_Type_AUDIO_CONTROL;
  static constexpr Type AUDIO_METADATA =
    SignalFrame_Type_AUDIO_METADATA;
  static constexpr Type AUDIO_STREAM_ID_INFO =
    SignalFrame_Type_AUDIO_STREAM_ID_INFO;
  static constexpr Type PING_PONG =
    SignalFrame_Type_PING_PONG;
  static constexpr Type AUDIO_STATUS =
    SignalFrame_Type_AUDIO_STATUS;
  static constexpr Type CLIENT_METRIC =
    SignalFrame_Type_CLIENT_METRIC;
  static constexpr Type DATA_MESSAGE =
    SignalFrame_Type_DATA_MESSAGE;
  static constexpr Type AUDIO_TRANSCRIPT =
    SignalFrame_Type_AUDIO_TRANSCRIPT;
  static constexpr Type REMOTE_VIDEO_UPDATE =
    SignalFrame_Type_REMOTE_VIDEO_UPDATE;
  static constexpr Type PRIMARY_MEETING_JOIN =
    SignalFrame_Type_PRIMARY_MEETING_JOIN;
  static constexpr Type PRIMARY_MEETING_JOIN_ACK =
    SignalFrame_Type_PRIMARY_MEETING_JOIN_ACK;
  static constexpr Type PRIMARY_MEETING_LEAVE =
    SignalFrame_Type_PRIMARY_MEETING_LEAVE;
  static constexpr Type BRIDGE_JOIN =
    SignalFrame_Type_BRIDGE_JOIN;
  static constexpr Type BRIDGE_JOIN_ACK =
    SignalFrame_Type_BRIDGE_JOIN_ACK;
  static constexpr Type BRIDGE_RESERVE =
    SignalFrame_Type_BRIDGE_RESERVE;
  static constexpr Type BRIDGE_RESERVE_ACK =
    SignalFrame_Type_BRIDGE_RESERVE_ACK;
  static inline bool Type_IsValid(int value) {
    return SignalFrame_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SignalFrame_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SignalFrame_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SignalFrame_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SignalFrame_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SignalFrame_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 3,
    kJoinFieldNumber = 4,
    kJoinackFieldNumber = 5,
    kSubFieldNumber = 6,
    kSubackFieldNumber = 7,
    kIndexFieldNumber = 8,
    kPauseFieldNumber = 10,
    kLeaveFieldNumber = 11,
    kLeaveAckFieldNumber = 12,
    kBitratesFieldNumber = 14,
    kAudioControlFieldNumber = 17,
    kAudioMetadataFieldNumber = 18,
    kAudioStreamIdInfoFieldNumber = 19,
    kPingPongFieldNumber = 20,
    kAudioStatusFieldNumber = 21,
    kClientMetricFieldNumber = 22,
    kDataMessageFieldNumber = 23,
    kAudioTranscriptFieldNumber = 24,
    kRemoteVideoUpdateFieldNumber = 25,
    kPrimaryMeetingJoinFieldNumber = 26,
    kPrimaryMeetingJoinAckFieldNumber = 27,
    kPrimaryMeetingLeaveFieldNumber = 28,
    kBridgeJoinFieldNumber = 29,
    kBridgeJoinAckFieldNumber = 30,
    kBridgeReserveFieldNumber = 31,
    kBridgeReserveAckFieldNumber = 32,
    kTimestampMsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .signal_rtc.ErrorFrame error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::signal_rtc::ErrorFrame& error() const;
  ::signal_rtc::ErrorFrame* release_error();
  ::signal_rtc::ErrorFrame* mutable_error();
  void set_allocated_error(::signal_rtc::ErrorFrame* error);
  private:
  const ::signal_rtc::ErrorFrame& _internal_error() const;
  ::signal_rtc::ErrorFrame* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::signal_rtc::ErrorFrame* error);
  ::signal_rtc::ErrorFrame* unsafe_arena_release_error();

  // optional .signal_rtc.JoinFrame join = 4;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::signal_rtc::JoinFrame& join() const;
  ::signal_rtc::JoinFrame* release_join();
  ::signal_rtc::JoinFrame* mutable_join();
  void set_allocated_join(::signal_rtc::JoinFrame* join);
  private:
  const ::signal_rtc::JoinFrame& _internal_join() const;
  ::signal_rtc::JoinFrame* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::signal_rtc::JoinFrame* join);
  ::signal_rtc::JoinFrame* unsafe_arena_release_join();

  // optional .signal_rtc.JoinAckFrame joinack = 5;
  bool has_joinack() const;
  private:
  bool _internal_has_joinack() const;
  public:
  void clear_joinack();
  const ::signal_rtc::JoinAckFrame& joinack() const;
  ::signal_rtc::JoinAckFrame* release_joinack();
  ::signal_rtc::JoinAckFrame* mutable_joinack();
  void set_allocated_joinack(::signal_rtc::JoinAckFrame* joinack);
  private:
  const ::signal_rtc::JoinAckFrame& _internal_joinack() const;
  ::signal_rtc::JoinAckFrame* _internal_mutable_joinack();
  public:
  void unsafe_arena_set_allocated_joinack(
      ::signal_rtc::JoinAckFrame* joinack);
  ::signal_rtc::JoinAckFrame* unsafe_arena_release_joinack();

  // optional .signal_rtc.SubscribeFrame sub = 6;
  bool has_sub() const;
  private:
  bool _internal_has_sub() const;
  public:
  void clear_sub();
  const ::signal_rtc::SubscribeFrame& sub() const;
  ::signal_rtc::SubscribeFrame* release_sub();
  ::signal_rtc::SubscribeFrame* mutable_sub();
  void set_allocated_sub(::signal_rtc::SubscribeFrame* sub);
  private:
  const ::signal_rtc::SubscribeFrame& _internal_sub() const;
  ::signal_rtc::SubscribeFrame* _internal_mutable_sub();
  public:
  void unsafe_arena_set_allocated_sub(
      ::signal_rtc::SubscribeFrame* sub);
  ::signal_rtc::SubscribeFrame* unsafe_arena_release_sub();

  // optional .signal_rtc.SubscribeAckFrame suback = 7;
  bool has_suback() const;
  private:
  bool _internal_has_suback() const;
  public:
  void clear_suback();
  const ::signal_rtc::SubscribeAckFrame& suback() const;
  ::signal_rtc::SubscribeAckFrame* release_suback();
  ::signal_rtc::SubscribeAckFrame* mutable_suback();
  void set_allocated_suback(::signal_rtc::SubscribeAckFrame* suback);
  private:
  const ::signal_rtc::SubscribeAckFrame& _internal_suback() const;
  ::signal_rtc::SubscribeAckFrame* _internal_mutable_suback();
  public:
  void unsafe_arena_set_allocated_suback(
      ::signal_rtc::SubscribeAckFrame* suback);
  ::signal_rtc::SubscribeAckFrame* unsafe_arena_release_suback();

  // optional .signal_rtc.IndexFrame index = 8;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::signal_rtc::IndexFrame& index() const;
  ::signal_rtc::IndexFrame* release_index();
  ::signal_rtc::IndexFrame* mutable_index();
  void set_allocated_index(::signal_rtc::IndexFrame* index);
  private:
  const ::signal_rtc::IndexFrame& _internal_index() const;
  ::signal_rtc::IndexFrame* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::signal_rtc::IndexFrame* index);
  ::signal_rtc::IndexFrame* unsafe_arena_release_index();

  // optional .signal_rtc.PauseResumeFrame pause = 10;
  bool has_pause() const;
  private:
  bool _internal_has_pause() const;
  public:
  void clear_pause();
  const ::signal_rtc::PauseResumeFrame& pause() const;
  ::signal_rtc::PauseResumeFrame* release_pause();
  ::signal_rtc::PauseResumeFrame* mutable_pause();
  void set_allocated_pause(::signal_rtc::PauseResumeFrame* pause);
  private:
  const ::signal_rtc::PauseResumeFrame& _internal_pause() const;
  ::signal_rtc::PauseResumeFrame* _internal_mutable_pause();
  public:
  void unsafe_arena_set_allocated_pause(
      ::signal_rtc::PauseResumeFrame* pause);
  ::signal_rtc::PauseResumeFrame* unsafe_arena_release_pause();

  // optional .signal_rtc.LeaveFrame leave = 11;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;
  public:
  void clear_leave();
  const ::signal_rtc::LeaveFrame& leave() const;
  ::signal_rtc::LeaveFrame* release_leave();
  ::signal_rtc::LeaveFrame* mutable_leave();
  void set_allocated_leave(::signal_rtc::LeaveFrame* leave);
  private:
  const ::signal_rtc::LeaveFrame& _internal_leave() const;
  ::signal_rtc::LeaveFrame* _internal_mutable_leave();
  public:
  void unsafe_arena_set_allocated_leave(
      ::signal_rtc::LeaveFrame* leave);
  ::signal_rtc::LeaveFrame* unsafe_arena_release_leave();

  // optional .signal_rtc.LeaveAckFrame leave_ack = 12;
  bool has_leave_ack() const;
  private:
  bool _internal_has_leave_ack() const;
  public:
  void clear_leave_ack();
  const ::signal_rtc::LeaveAckFrame& leave_ack() const;
  ::signal_rtc::LeaveAckFrame* release_leave_ack();
  ::signal_rtc::LeaveAckFrame* mutable_leave_ack();
  void set_allocated_leave_ack(::signal_rtc::LeaveAckFrame* leave_ack);
  private:
  const ::signal_rtc::LeaveAckFrame& _internal_leave_ack() const;
  ::signal_rtc::LeaveAckFrame* _internal_mutable_leave_ack();
  public:
  void unsafe_arena_set_allocated_leave_ack(
      ::signal_rtc::LeaveAckFrame* leave_ack);
  ::signal_rtc::LeaveAckFrame* unsafe_arena_release_leave_ack();

  // optional .signal_rtc.BitrateFrame bitrates = 14;
  bool has_bitrates() const;
  private:
  bool _internal_has_bitrates() const;
  public:
  void clear_bitrates();
  const ::signal_rtc::BitrateFrame& bitrates() const;
  ::signal_rtc::BitrateFrame* release_bitrates();
  ::signal_rtc::BitrateFrame* mutable_bitrates();
  void set_allocated_bitrates(::signal_rtc::BitrateFrame* bitrates);
  private:
  const ::signal_rtc::BitrateFrame& _internal_bitrates() const;
  ::signal_rtc::BitrateFrame* _internal_mutable_bitrates();
  public:
  void unsafe_arena_set_allocated_bitrates(
      ::signal_rtc::BitrateFrame* bitrates);
  ::signal_rtc::BitrateFrame* unsafe_arena_release_bitrates();

  // optional .signal_rtc.AudioControlFrame audio_control = 17;
  bool has_audio_control() const;
  private:
  bool _internal_has_audio_control() const;
  public:
  void clear_audio_control();
  const ::signal_rtc::AudioControlFrame& audio_control() const;
  ::signal_rtc::AudioControlFrame* release_audio_control();
  ::signal_rtc::AudioControlFrame* mutable_audio_control();
  void set_allocated_audio_control(::signal_rtc::AudioControlFrame* audio_control);
  private:
  const ::signal_rtc::AudioControlFrame& _internal_audio_control() const;
  ::signal_rtc::AudioControlFrame* _internal_mutable_audio_control();
  public:
  void unsafe_arena_set_allocated_audio_control(
      ::signal_rtc::AudioControlFrame* audio_control);
  ::signal_rtc::AudioControlFrame* unsafe_arena_release_audio_control();

  // optional .signal_rtc.AudioMetadataFrame audio_metadata = 18;
  bool has_audio_metadata() const;
  private:
  bool _internal_has_audio_metadata() const;
  public:
  void clear_audio_metadata();
  const ::signal_rtc::AudioMetadataFrame& audio_metadata() const;
  ::signal_rtc::AudioMetadataFrame* release_audio_metadata();
  ::signal_rtc::AudioMetadataFrame* mutable_audio_metadata();
  void set_allocated_audio_metadata(::signal_rtc::AudioMetadataFrame* audio_metadata);
  private:
  const ::signal_rtc::AudioMetadataFrame& _internal_audio_metadata() const;
  ::signal_rtc::AudioMetadataFrame* _internal_mutable_audio_metadata();
  public:
  void unsafe_arena_set_allocated_audio_metadata(
      ::signal_rtc::AudioMetadataFrame* audio_metadata);
  ::signal_rtc::AudioMetadataFrame* unsafe_arena_release_audio_metadata();

  // optional .signal_rtc.AudioStreamIdInfoFrame audio_stream_id_info = 19;
  bool has_audio_stream_id_info() const;
  private:
  bool _internal_has_audio_stream_id_info() const;
  public:
  void clear_audio_stream_id_info();
  const ::signal_rtc::AudioStreamIdInfoFrame& audio_stream_id_info() const;
  ::signal_rtc::AudioStreamIdInfoFrame* release_audio_stream_id_info();
  ::signal_rtc::AudioStreamIdInfoFrame* mutable_audio_stream_id_info();
  void set_allocated_audio_stream_id_info(::signal_rtc::AudioStreamIdInfoFrame* audio_stream_id_info);
  private:
  const ::signal_rtc::AudioStreamIdInfoFrame& _internal_audio_stream_id_info() const;
  ::signal_rtc::AudioStreamIdInfoFrame* _internal_mutable_audio_stream_id_info();
  public:
  void unsafe_arena_set_allocated_audio_stream_id_info(
      ::signal_rtc::AudioStreamIdInfoFrame* audio_stream_id_info);
  ::signal_rtc::AudioStreamIdInfoFrame* unsafe_arena_release_audio_stream_id_info();

  // optional .signal_rtc.PingPongFrame ping_pong = 20;
  bool has_ping_pong() const;
  private:
  bool _internal_has_ping_pong() const;
  public:
  void clear_ping_pong();
  const ::signal_rtc::PingPongFrame& ping_pong() const;
  ::signal_rtc::PingPongFrame* release_ping_pong();
  ::signal_rtc::PingPongFrame* mutable_ping_pong();
  void set_allocated_ping_pong(::signal_rtc::PingPongFrame* ping_pong);
  private:
  const ::signal_rtc::PingPongFrame& _internal_ping_pong() const;
  ::signal_rtc::PingPongFrame* _internal_mutable_ping_pong();
  public:
  void unsafe_arena_set_allocated_ping_pong(
      ::signal_rtc::PingPongFrame* ping_pong);
  ::signal_rtc::PingPongFrame* unsafe_arena_release_ping_pong();

  // optional .signal_rtc.AudioStatusFrame audio_status = 21;
  bool has_audio_status() const;
  private:
  bool _internal_has_audio_status() const;
  public:
  void clear_audio_status();
  const ::signal_rtc::AudioStatusFrame& audio_status() const;
  ::signal_rtc::AudioStatusFrame* release_audio_status();
  ::signal_rtc::AudioStatusFrame* mutable_audio_status();
  void set_allocated_audio_status(::signal_rtc::AudioStatusFrame* audio_status);
  private:
  const ::signal_rtc::AudioStatusFrame& _internal_audio_status() const;
  ::signal_rtc::AudioStatusFrame* _internal_mutable_audio_status();
  public:
  void unsafe_arena_set_allocated_audio_status(
      ::signal_rtc::AudioStatusFrame* audio_status);
  ::signal_rtc::AudioStatusFrame* unsafe_arena_release_audio_status();

  // optional .signal_rtc.ClientMetricFrame client_metric = 22;
  bool has_client_metric() const;
  private:
  bool _internal_has_client_metric() const;
  public:
  void clear_client_metric();
  const ::signal_rtc::ClientMetricFrame& client_metric() const;
  ::signal_rtc::ClientMetricFrame* release_client_metric();
  ::signal_rtc::ClientMetricFrame* mutable_client_metric();
  void set_allocated_client_metric(::signal_rtc::ClientMetricFrame* client_metric);
  private:
  const ::signal_rtc::ClientMetricFrame& _internal_client_metric() const;
  ::signal_rtc::ClientMetricFrame* _internal_mutable_client_metric();
  public:
  void unsafe_arena_set_allocated_client_metric(
      ::signal_rtc::ClientMetricFrame* client_metric);
  ::signal_rtc::ClientMetricFrame* unsafe_arena_release_client_metric();

  // optional .signal_rtc.DataMessageFrame data_message = 23;
  bool has_data_message() const;
  private:
  bool _internal_has_data_message() const;
  public:
  void clear_data_message();
  const ::signal_rtc::DataMessageFrame& data_message() const;
  ::signal_rtc::DataMessageFrame* release_data_message();
  ::signal_rtc::DataMessageFrame* mutable_data_message();
  void set_allocated_data_message(::signal_rtc::DataMessageFrame* data_message);
  private:
  const ::signal_rtc::DataMessageFrame& _internal_data_message() const;
  ::signal_rtc::DataMessageFrame* _internal_mutable_data_message();
  public:
  void unsafe_arena_set_allocated_data_message(
      ::signal_rtc::DataMessageFrame* data_message);
  ::signal_rtc::DataMessageFrame* unsafe_arena_release_data_message();

  // optional .signal_rtc.AudioTranscriptFrame audio_transcript = 24;
  bool has_audio_transcript() const;
  private:
  bool _internal_has_audio_transcript() const;
  public:
  void clear_audio_transcript();
  const ::signal_rtc::AudioTranscriptFrame& audio_transcript() const;
  ::signal_rtc::AudioTranscriptFrame* release_audio_transcript();
  ::signal_rtc::AudioTranscriptFrame* mutable_audio_transcript();
  void set_allocated_audio_transcript(::signal_rtc::AudioTranscriptFrame* audio_transcript);
  private:
  const ::signal_rtc::AudioTranscriptFrame& _internal_audio_transcript() const;
  ::signal_rtc::AudioTranscriptFrame* _internal_mutable_audio_transcript();
  public:
  void unsafe_arena_set_allocated_audio_transcript(
      ::signal_rtc::AudioTranscriptFrame* audio_transcript);
  ::signal_rtc::AudioTranscriptFrame* unsafe_arena_release_audio_transcript();

  // optional .signal_rtc.RemoteVideoUpdateFrame remote_video_update = 25;
  bool has_remote_video_update() const;
  private:
  bool _internal_has_remote_video_update() const;
  public:
  void clear_remote_video_update();
  const ::signal_rtc::RemoteVideoUpdateFrame& remote_video_update() const;
  ::signal_rtc::RemoteVideoUpdateFrame* release_remote_video_update();
  ::signal_rtc::RemoteVideoUpdateFrame* mutable_remote_video_update();
  void set_allocated_remote_video_update(::signal_rtc::RemoteVideoUpdateFrame* remote_video_update);
  private:
  const ::signal_rtc::RemoteVideoUpdateFrame& _internal_remote_video_update() const;
  ::signal_rtc::RemoteVideoUpdateFrame* _internal_mutable_remote_video_update();
  public:
  void unsafe_arena_set_allocated_remote_video_update(
      ::signal_rtc::RemoteVideoUpdateFrame* remote_video_update);
  ::signal_rtc::RemoteVideoUpdateFrame* unsafe_arena_release_remote_video_update();

  // optional .signal_rtc.PrimaryMeetingJoinFrame primary_meeting_join = 26;
  bool has_primary_meeting_join() const;
  private:
  bool _internal_has_primary_meeting_join() const;
  public:
  void clear_primary_meeting_join();
  const ::signal_rtc::PrimaryMeetingJoinFrame& primary_meeting_join() const;
  ::signal_rtc::PrimaryMeetingJoinFrame* release_primary_meeting_join();
  ::signal_rtc::PrimaryMeetingJoinFrame* mutable_primary_meeting_join();
  void set_allocated_primary_meeting_join(::signal_rtc::PrimaryMeetingJoinFrame* primary_meeting_join);
  private:
  const ::signal_rtc::PrimaryMeetingJoinFrame& _internal_primary_meeting_join() const;
  ::signal_rtc::PrimaryMeetingJoinFrame* _internal_mutable_primary_meeting_join();
  public:
  void unsafe_arena_set_allocated_primary_meeting_join(
      ::signal_rtc::PrimaryMeetingJoinFrame* primary_meeting_join);
  ::signal_rtc::PrimaryMeetingJoinFrame* unsafe_arena_release_primary_meeting_join();

  // optional .signal_rtc.PrimaryMeetingJoinAckFrame primary_meeting_join_ack = 27;
  bool has_primary_meeting_join_ack() const;
  private:
  bool _internal_has_primary_meeting_join_ack() const;
  public:
  void clear_primary_meeting_join_ack();
  const ::signal_rtc::PrimaryMeetingJoinAckFrame& primary_meeting_join_ack() const;
  ::signal_rtc::PrimaryMeetingJoinAckFrame* release_primary_meeting_join_ack();
  ::signal_rtc::PrimaryMeetingJoinAckFrame* mutable_primary_meeting_join_ack();
  void set_allocated_primary_meeting_join_ack(::signal_rtc::PrimaryMeetingJoinAckFrame* primary_meeting_join_ack);
  private:
  const ::signal_rtc::PrimaryMeetingJoinAckFrame& _internal_primary_meeting_join_ack() const;
  ::signal_rtc::PrimaryMeetingJoinAckFrame* _internal_mutable_primary_meeting_join_ack();
  public:
  void unsafe_arena_set_allocated_primary_meeting_join_ack(
      ::signal_rtc::PrimaryMeetingJoinAckFrame* primary_meeting_join_ack);
  ::signal_rtc::PrimaryMeetingJoinAckFrame* unsafe_arena_release_primary_meeting_join_ack();

  // optional .signal_rtc.PrimaryMeetingLeaveFrame primary_meeting_leave = 28;
  bool has_primary_meeting_leave() const;
  private:
  bool _internal_has_primary_meeting_leave() const;
  public:
  void clear_primary_meeting_leave();
  const ::signal_rtc::PrimaryMeetingLeaveFrame& primary_meeting_leave() const;
  ::signal_rtc::PrimaryMeetingLeaveFrame* release_primary_meeting_leave();
  ::signal_rtc::PrimaryMeetingLeaveFrame* mutable_primary_meeting_leave();
  void set_allocated_primary_meeting_leave(::signal_rtc::PrimaryMeetingLeaveFrame* primary_meeting_leave);
  private:
  const ::signal_rtc::PrimaryMeetingLeaveFrame& _internal_primary_meeting_leave() const;
  ::signal_rtc::PrimaryMeetingLeaveFrame* _internal_mutable_primary_meeting_leave();
  public:
  void unsafe_arena_set_allocated_primary_meeting_leave(
      ::signal_rtc::PrimaryMeetingLeaveFrame* primary_meeting_leave);
  ::signal_rtc::PrimaryMeetingLeaveFrame* unsafe_arena_release_primary_meeting_leave();

  // optional .signal_rtc.BridgeJoinFrame bridge_join = 29;
  bool has_bridge_join() const;
  private:
  bool _internal_has_bridge_join() const;
  public:
  void clear_bridge_join();
  const ::signal_rtc::BridgeJoinFrame& bridge_join() const;
  ::signal_rtc::BridgeJoinFrame* release_bridge_join();
  ::signal_rtc::BridgeJoinFrame* mutable_bridge_join();
  void set_allocated_bridge_join(::signal_rtc::BridgeJoinFrame* bridge_join);
  private:
  const ::signal_rtc::BridgeJoinFrame& _internal_bridge_join() const;
  ::signal_rtc::BridgeJoinFrame* _internal_mutable_bridge_join();
  public:
  void unsafe_arena_set_allocated_bridge_join(
      ::signal_rtc::BridgeJoinFrame* bridge_join);
  ::signal_rtc::BridgeJoinFrame* unsafe_arena_release_bridge_join();

  // optional .signal_rtc.BridgeJoinAckFrame bridge_join_ack = 30;
  bool has_bridge_join_ack() const;
  private:
  bool _internal_has_bridge_join_ack() const;
  public:
  void clear_bridge_join_ack();
  const ::signal_rtc::BridgeJoinAckFrame& bridge_join_ack() const;
  ::signal_rtc::BridgeJoinAckFrame* release_bridge_join_ack();
  ::signal_rtc::BridgeJoinAckFrame* mutable_bridge_join_ack();
  void set_allocated_bridge_join_ack(::signal_rtc::BridgeJoinAckFrame* bridge_join_ack);
  private:
  const ::signal_rtc::BridgeJoinAckFrame& _internal_bridge_join_ack() const;
  ::signal_rtc::BridgeJoinAckFrame* _internal_mutable_bridge_join_ack();
  public:
  void unsafe_arena_set_allocated_bridge_join_ack(
      ::signal_rtc::BridgeJoinAckFrame* bridge_join_ack);
  ::signal_rtc::BridgeJoinAckFrame* unsafe_arena_release_bridge_join_ack();

  // optional .signal_rtc.BridgeReserveFrame bridge_reserve = 31;
  bool has_bridge_reserve() const;
  private:
  bool _internal_has_bridge_reserve() const;
  public:
  void clear_bridge_reserve();
  const ::signal_rtc::BridgeReserveFrame& bridge_reserve() const;
  ::signal_rtc::BridgeReserveFrame* release_bridge_reserve();
  ::signal_rtc::BridgeReserveFrame* mutable_bridge_reserve();
  void set_allocated_bridge_reserve(::signal_rtc::BridgeReserveFrame* bridge_reserve);
  private:
  const ::signal_rtc::BridgeReserveFrame& _internal_bridge_reserve() const;
  ::signal_rtc::BridgeReserveFrame* _internal_mutable_bridge_reserve();
  public:
  void unsafe_arena_set_allocated_bridge_reserve(
      ::signal_rtc::BridgeReserveFrame* bridge_reserve);
  ::signal_rtc::BridgeReserveFrame* unsafe_arena_release_bridge_reserve();

  // optional .signal_rtc.BridgeReserveAckFrame bridge_reserve_ack = 32;
  bool has_bridge_reserve_ack() const;
  private:
  bool _internal_has_bridge_reserve_ack() const;
  public:
  void clear_bridge_reserve_ack();
  const ::signal_rtc::BridgeReserveAckFrame& bridge_reserve_ack() const;
  ::signal_rtc::BridgeReserveAckFrame* release_bridge_reserve_ack();
  ::signal_rtc::BridgeReserveAckFrame* mutable_bridge_reserve_ack();
  void set_allocated_bridge_reserve_ack(::signal_rtc::BridgeReserveAckFrame* bridge_reserve_ack);
  private:
  const ::signal_rtc::BridgeReserveAckFrame& _internal_bridge_reserve_ack() const;
  ::signal_rtc::BridgeReserveAckFrame* _internal_mutable_bridge_reserve_ack();
  public:
  void unsafe_arena_set_allocated_bridge_reserve_ack(
      ::signal_rtc::BridgeReserveAckFrame* bridge_reserve_ack);
  ::signal_rtc::BridgeReserveAckFrame* unsafe_arena_release_bridge_reserve_ack();

  // required uint64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  private:
  bool _internal_has_timestamp_ms() const;
  public:
  void clear_timestamp_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_ms() const;
  void set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .signal_rtc.SignalFrame.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::SignalFrame_Type type() const;
  void set_type(::signal_rtc::SignalFrame_Type value);
  private:
  ::signal_rtc::SignalFrame_Type _internal_type() const;
  void _internal_set_type(::signal_rtc::SignalFrame_Type value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.SignalFrame)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::signal_rtc::ErrorFrame* error_;
  ::signal_rtc::JoinFrame* join_;
  ::signal_rtc::JoinAckFrame* joinack_;
  ::signal_rtc::SubscribeFrame* sub_;
  ::signal_rtc::SubscribeAckFrame* suback_;
  ::signal_rtc::IndexFrame* index_;
  ::signal_rtc::PauseResumeFrame* pause_;
  ::signal_rtc::LeaveFrame* leave_;
  ::signal_rtc::LeaveAckFrame* leave_ack_;
  ::signal_rtc::BitrateFrame* bitrates_;
  ::signal_rtc::AudioControlFrame* audio_control_;
  ::signal_rtc::AudioMetadataFrame* audio_metadata_;
  ::signal_rtc::AudioStreamIdInfoFrame* audio_stream_id_info_;
  ::signal_rtc::PingPongFrame* ping_pong_;
  ::signal_rtc::AudioStatusFrame* audio_status_;
  ::signal_rtc::ClientMetricFrame* client_metric_;
  ::signal_rtc::DataMessageFrame* data_message_;
  ::signal_rtc::AudioTranscriptFrame* audio_transcript_;
  ::signal_rtc::RemoteVideoUpdateFrame* remote_video_update_;
  ::signal_rtc::PrimaryMeetingJoinFrame* primary_meeting_join_;
  ::signal_rtc::PrimaryMeetingJoinAckFrame* primary_meeting_join_ack_;
  ::signal_rtc::PrimaryMeetingLeaveFrame* primary_meeting_leave_;
  ::signal_rtc::BridgeJoinFrame* bridge_join_;
  ::signal_rtc::BridgeJoinAckFrame* bridge_join_ack_;
  ::signal_rtc::BridgeReserveFrame* bridge_reserve_;
  ::signal_rtc::BridgeReserveAckFrame* bridge_reserve_ack_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_ms_;
  int type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class ErrorFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.ErrorFrame) */ {
 public:
  inline ErrorFrame() : ErrorFrame(nullptr) {}
  virtual ~ErrorFrame();

  ErrorFrame(const ErrorFrame& from);
  ErrorFrame(ErrorFrame&& from) noexcept
    : ErrorFrame() {
    *this = ::std::move(from);
  }

  inline ErrorFrame& operator=(const ErrorFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorFrame& operator=(ErrorFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ErrorFrame& default_instance();

  static inline const ErrorFrame* internal_default_instance() {
    return reinterpret_cast<const ErrorFrame*>(
               &_ErrorFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ErrorFrame& a, ErrorFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ErrorFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorFrame* New() const final {
    return CreateMaybeMessage<ErrorFrame>(nullptr);
  }

  ErrorFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ErrorFrame& from);
  void MergeFrom(const ErrorFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.ErrorFrame";
  }
  protected:
  explicit ErrorFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional uint32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.ErrorFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class ClientDetails PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.ClientDetails) */ {
 public:
  inline ClientDetails() : ClientDetails(nullptr) {}
  virtual ~ClientDetails();

  ClientDetails(const ClientDetails& from);
  ClientDetails(ClientDetails&& from) noexcept
    : ClientDetails() {
    *this = ::std::move(from);
  }

  inline ClientDetails& operator=(const ClientDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientDetails& operator=(ClientDetails&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientDetails& default_instance();

  static inline const ClientDetails* internal_default_instance() {
    return reinterpret_cast<const ClientDetails*>(
               &_ClientDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientDetails& a, ClientDetails& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientDetails* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientDetails* New() const final {
    return CreateMaybeMessage<ClientDetails>(nullptr);
  }

  ClientDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientDetails>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientDetails& from);
  void MergeFrom(const ClientDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientDetails* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.ClientDetails";
  }
  protected:
  explicit ClientDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kAppVersionFieldNumber = 2,
    kDeviceModelFieldNumber = 3,
    kDeviceMakeFieldNumber = 4,
    kPlatformNameFieldNumber = 5,
    kPlatformVersionFieldNumber = 6,
    kClientSourceFieldNumber = 7,
    kChimeSdkVersionFieldNumber = 8,
  };
  // optional string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  void set_app_name(const std::string& value);
  void set_app_name(std::string&& value);
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  std::string* mutable_app_name();
  std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // optional string app_version = 2;
  bool has_app_version() const;
  private:
  bool _internal_has_app_version() const;
  public:
  void clear_app_version();
  const std::string& app_version() const;
  void set_app_version(const std::string& value);
  void set_app_version(std::string&& value);
  void set_app_version(const char* value);
  void set_app_version(const char* value, size_t size);
  std::string* mutable_app_version();
  std::string* release_app_version();
  void set_allocated_app_version(std::string* app_version);
  private:
  const std::string& _internal_app_version() const;
  void _internal_set_app_version(const std::string& value);
  std::string* _internal_mutable_app_version();
  public:

  // optional string device_model = 3;
  bool has_device_model() const;
  private:
  bool _internal_has_device_model() const;
  public:
  void clear_device_model();
  const std::string& device_model() const;
  void set_device_model(const std::string& value);
  void set_device_model(std::string&& value);
  void set_device_model(const char* value);
  void set_device_model(const char* value, size_t size);
  std::string* mutable_device_model();
  std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // optional string device_make = 4;
  bool has_device_make() const;
  private:
  bool _internal_has_device_make() const;
  public:
  void clear_device_make();
  const std::string& device_make() const;
  void set_device_make(const std::string& value);
  void set_device_make(std::string&& value);
  void set_device_make(const char* value);
  void set_device_make(const char* value, size_t size);
  std::string* mutable_device_make();
  std::string* release_device_make();
  void set_allocated_device_make(std::string* device_make);
  private:
  const std::string& _internal_device_make() const;
  void _internal_set_device_make(const std::string& value);
  std::string* _internal_mutable_device_make();
  public:

  // optional string platform_name = 5;
  bool has_platform_name() const;
  private:
  bool _internal_has_platform_name() const;
  public:
  void clear_platform_name();
  const std::string& platform_name() const;
  void set_platform_name(const std::string& value);
  void set_platform_name(std::string&& value);
  void set_platform_name(const char* value);
  void set_platform_name(const char* value, size_t size);
  std::string* mutable_platform_name();
  std::string* release_platform_name();
  void set_allocated_platform_name(std::string* platform_name);
  private:
  const std::string& _internal_platform_name() const;
  void _internal_set_platform_name(const std::string& value);
  std::string* _internal_mutable_platform_name();
  public:

  // optional string platform_version = 6;
  bool has_platform_version() const;
  private:
  bool _internal_has_platform_version() const;
  public:
  void clear_platform_version();
  const std::string& platform_version() const;
  void set_platform_version(const std::string& value);
  void set_platform_version(std::string&& value);
  void set_platform_version(const char* value);
  void set_platform_version(const char* value, size_t size);
  std::string* mutable_platform_version();
  std::string* release_platform_version();
  void set_allocated_platform_version(std::string* platform_version);
  private:
  const std::string& _internal_platform_version() const;
  void _internal_set_platform_version(const std::string& value);
  std::string* _internal_mutable_platform_version();
  public:

  // optional string client_source = 7;
  bool has_client_source() const;
  private:
  bool _internal_has_client_source() const;
  public:
  void clear_client_source();
  const std::string& client_source() const;
  void set_client_source(const std::string& value);
  void set_client_source(std::string&& value);
  void set_client_source(const char* value);
  void set_client_source(const char* value, size_t size);
  std::string* mutable_client_source();
  std::string* release_client_source();
  void set_allocated_client_source(std::string* client_source);
  private:
  const std::string& _internal_client_source() const;
  void _internal_set_client_source(const std::string& value);
  std::string* _internal_mutable_client_source();
  public:

  // optional string chime_sdk_version = 8;
  bool has_chime_sdk_version() const;
  private:
  bool _internal_has_chime_sdk_version() const;
  public:
  void clear_chime_sdk_version();
  const std::string& chime_sdk_version() const;
  void set_chime_sdk_version(const std::string& value);
  void set_chime_sdk_version(std::string&& value);
  void set_chime_sdk_version(const char* value);
  void set_chime_sdk_version(const char* value, size_t size);
  std::string* mutable_chime_sdk_version();
  std::string* release_chime_sdk_version();
  void set_allocated_chime_sdk_version(std::string* chime_sdk_version);
  private:
  const std::string& _internal_chime_sdk_version() const;
  void _internal_set_chime_sdk_version(const std::string& value);
  std::string* _internal_mutable_chime_sdk_version();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.ClientDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_make_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chime_sdk_version_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class JoinFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.JoinFrame) */ {
 public:
  inline JoinFrame() : JoinFrame(nullptr) {}
  virtual ~JoinFrame();

  JoinFrame(const JoinFrame& from);
  JoinFrame(JoinFrame&& from) noexcept
    : JoinFrame() {
    *this = ::std::move(from);
  }

  inline JoinFrame& operator=(const JoinFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinFrame& operator=(JoinFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinFrame& default_instance();

  static inline const JoinFrame* internal_default_instance() {
    return reinterpret_cast<const JoinFrame*>(
               &_JoinFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JoinFrame& a, JoinFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(JoinFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinFrame* New() const final {
    return CreateMaybeMessage<JoinFrame>(nullptr);
  }

  JoinFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const JoinFrame& from);
  void MergeFrom(const JoinFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.JoinFrame";
  }
  protected:
  explicit JoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledExperimentsFieldNumber = 5,
    kClientDetailsFieldNumber = 4,
    kAudioSessionIdFieldNumber = 6,
    kFlagsFieldNumber = 3,
    kProtocolVersionFieldNumber = 1,
    kMaxNumOfVideosFieldNumber = 2,
  };
  // repeated string enabled_experiments = 5;
  int enabled_experiments_size() const;
  private:
  int _internal_enabled_experiments_size() const;
  public:
  void clear_enabled_experiments();
  const std::string& enabled_experiments(int index) const;
  std::string* mutable_enabled_experiments(int index);
  void set_enabled_experiments(int index, const std::string& value);
  void set_enabled_experiments(int index, std::string&& value);
  void set_enabled_experiments(int index, const char* value);
  void set_enabled_experiments(int index, const char* value, size_t size);
  std::string* add_enabled_experiments();
  void add_enabled_experiments(const std::string& value);
  void add_enabled_experiments(std::string&& value);
  void add_enabled_experiments(const char* value);
  void add_enabled_experiments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enabled_experiments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enabled_experiments();
  private:
  const std::string& _internal_enabled_experiments(int index) const;
  std::string* _internal_add_enabled_experiments();
  public:

  // optional .signal_rtc.ClientDetails client_details = 4;
  bool has_client_details() const;
  private:
  bool _internal_has_client_details() const;
  public:
  void clear_client_details();
  const ::signal_rtc::ClientDetails& client_details() const;
  ::signal_rtc::ClientDetails* release_client_details();
  ::signal_rtc::ClientDetails* mutable_client_details();
  void set_allocated_client_details(::signal_rtc::ClientDetails* client_details);
  private:
  const ::signal_rtc::ClientDetails& _internal_client_details() const;
  ::signal_rtc::ClientDetails* _internal_mutable_client_details();
  public:
  void unsafe_arena_set_allocated_client_details(
      ::signal_rtc::ClientDetails* client_details);
  ::signal_rtc::ClientDetails* unsafe_arena_release_client_details();

  // optional uint64 audio_session_id = 6;
  bool has_audio_session_id() const;
  private:
  bool _internal_has_audio_session_id() const;
  public:
  void clear_audio_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 audio_session_id() const;
  void set_audio_session_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_audio_session_id() const;
  void _internal_set_audio_session_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 flags = 3;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 protocol_version = 1 [default = 2];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_num_of_videos = 2 [default = 8];
  bool has_max_num_of_videos() const;
  private:
  bool _internal_has_max_num_of_videos() const;
  public:
  void clear_max_num_of_videos();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_num_of_videos() const;
  void set_max_num_of_videos(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_num_of_videos() const;
  void _internal_set_max_num_of_videos(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.JoinFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enabled_experiments_;
  ::signal_rtc::ClientDetails* client_details_;
  ::PROTOBUF_NAMESPACE_ID::uint64 audio_session_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_num_of_videos_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class JoinAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.JoinAckFrame) */ {
 public:
  inline JoinAckFrame() : JoinAckFrame(nullptr) {}
  virtual ~JoinAckFrame();

  JoinAckFrame(const JoinAckFrame& from);
  JoinAckFrame(JoinAckFrame&& from) noexcept
    : JoinAckFrame() {
    *this = ::std::move(from);
  }

  inline JoinAckFrame& operator=(const JoinAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinAckFrame& operator=(JoinAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JoinAckFrame& default_instance();

  static inline const JoinAckFrame* internal_default_instance() {
    return reinterpret_cast<const JoinAckFrame*>(
               &_JoinAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JoinAckFrame& a, JoinAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(JoinAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinAckFrame* New() const final {
    return CreateMaybeMessage<JoinAckFrame>(nullptr);
  }

  JoinAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const JoinAckFrame& from);
  void MergeFrom(const JoinAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.JoinAckFrame";
  }
  protected:
  explicit JoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTurnCredentialsFieldNumber = 1,
    kVideoSubscriptionLimitFieldNumber = 2,
  };
  // optional .signal_rtc.TurnCredentials turn_credentials = 1;
  bool has_turn_credentials() const;
  private:
  bool _internal_has_turn_credentials() const;
  public:
  void clear_turn_credentials();
  const ::signal_rtc::TurnCredentials& turn_credentials() const;
  ::signal_rtc::TurnCredentials* release_turn_credentials();
  ::signal_rtc::TurnCredentials* mutable_turn_credentials();
  void set_allocated_turn_credentials(::signal_rtc::TurnCredentials* turn_credentials);
  private:
  const ::signal_rtc::TurnCredentials& _internal_turn_credentials() const;
  ::signal_rtc::TurnCredentials* _internal_mutable_turn_credentials();
  public:
  void unsafe_arena_set_allocated_turn_credentials(
      ::signal_rtc::TurnCredentials* turn_credentials);
  ::signal_rtc::TurnCredentials* unsafe_arena_release_turn_credentials();

  // optional uint32 video_subscription_limit = 2;
  bool has_video_subscription_limit() const;
  private:
  bool _internal_has_video_subscription_limit() const;
  public:
  void clear_video_subscription_limit();
  ::PROTOBUF_NAMESPACE_ID::uint32 video_subscription_limit() const;
  void set_video_subscription_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_video_subscription_limit() const;
  void _internal_set_video_subscription_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.JoinAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::signal_rtc::TurnCredentials* turn_credentials_;
  ::PROTOBUF_NAMESPACE_ID::uint32 video_subscription_limit_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class BridgeJoinFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.BridgeJoinFrame) */ {
 public:
  inline BridgeJoinFrame() : BridgeJoinFrame(nullptr) {}
  virtual ~BridgeJoinFrame();

  BridgeJoinFrame(const BridgeJoinFrame& from);
  BridgeJoinFrame(BridgeJoinFrame&& from) noexcept
    : BridgeJoinFrame() {
    *this = ::std::move(from);
  }

  inline BridgeJoinFrame& operator=(const BridgeJoinFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeJoinFrame& operator=(BridgeJoinFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BridgeJoinFrame& default_instance();

  static inline const BridgeJoinFrame* internal_default_instance() {
    return reinterpret_cast<const BridgeJoinFrame*>(
               &_BridgeJoinFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BridgeJoinFrame& a, BridgeJoinFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BridgeJoinFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeJoinFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BridgeJoinFrame* New() const final {
    return CreateMaybeMessage<BridgeJoinFrame>(nullptr);
  }

  BridgeJoinFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BridgeJoinFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BridgeJoinFrame& from);
  void MergeFrom(const BridgeJoinFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BridgeJoinFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.BridgeJoinFrame";
  }
  protected:
  explicit BridgeJoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDtlsFingerprintFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // optional string dtls_fingerprint = 2;
  bool has_dtls_fingerprint() const;
  private:
  bool _internal_has_dtls_fingerprint() const;
  public:
  void clear_dtls_fingerprint();
  const std::string& dtls_fingerprint() const;
  void set_dtls_fingerprint(const std::string& value);
  void set_dtls_fingerprint(std::string&& value);
  void set_dtls_fingerprint(const char* value);
  void set_dtls_fingerprint(const char* value, size_t size);
  std::string* mutable_dtls_fingerprint();
  std::string* release_dtls_fingerprint();
  void set_allocated_dtls_fingerprint(std::string* dtls_fingerprint);
  private:
  const std::string& _internal_dtls_fingerprint() const;
  void _internal_set_dtls_fingerprint(const std::string& value);
  std::string* _internal_mutable_dtls_fingerprint();
  public:

  // optional uint32 protocol_version = 1 [default = 1];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.BridgeJoinFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtls_fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_version_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class BridgeJoinAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.BridgeJoinAckFrame) */ {
 public:
  inline BridgeJoinAckFrame() : BridgeJoinAckFrame(nullptr) {}
  virtual ~BridgeJoinAckFrame();

  BridgeJoinAckFrame(const BridgeJoinAckFrame& from);
  BridgeJoinAckFrame(BridgeJoinAckFrame&& from) noexcept
    : BridgeJoinAckFrame() {
    *this = ::std::move(from);
  }

  inline BridgeJoinAckFrame& operator=(const BridgeJoinAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeJoinAckFrame& operator=(BridgeJoinAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BridgeJoinAckFrame& default_instance();

  static inline const BridgeJoinAckFrame* internal_default_instance() {
    return reinterpret_cast<const BridgeJoinAckFrame*>(
               &_BridgeJoinAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BridgeJoinAckFrame& a, BridgeJoinAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BridgeJoinAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeJoinAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BridgeJoinAckFrame* New() const final {
    return CreateMaybeMessage<BridgeJoinAckFrame>(nullptr);
  }

  BridgeJoinAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BridgeJoinAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BridgeJoinAckFrame& from);
  void MergeFrom(const BridgeJoinAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BridgeJoinAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.BridgeJoinAckFrame";
  }
  protected:
  explicit BridgeJoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListenerIpPortFieldNumber = 2,
    kTurnCredentialsFieldNumber = 1,
  };
  // optional string listener_ip_port = 2;
  bool has_listener_ip_port() const;
  private:
  bool _internal_has_listener_ip_port() const;
  public:
  void clear_listener_ip_port();
  const std::string& listener_ip_port() const;
  void set_listener_ip_port(const std::string& value);
  void set_listener_ip_port(std::string&& value);
  void set_listener_ip_port(const char* value);
  void set_listener_ip_port(const char* value, size_t size);
  std::string* mutable_listener_ip_port();
  std::string* release_listener_ip_port();
  void set_allocated_listener_ip_port(std::string* listener_ip_port);
  private:
  const std::string& _internal_listener_ip_port() const;
  void _internal_set_listener_ip_port(const std::string& value);
  std::string* _internal_mutable_listener_ip_port();
  public:

  // optional .signal_rtc.TurnCredentials turn_credentials = 1;
  bool has_turn_credentials() const;
  private:
  bool _internal_has_turn_credentials() const;
  public:
  void clear_turn_credentials();
  const ::signal_rtc::TurnCredentials& turn_credentials() const;
  ::signal_rtc::TurnCredentials* release_turn_credentials();
  ::signal_rtc::TurnCredentials* mutable_turn_credentials();
  void set_allocated_turn_credentials(::signal_rtc::TurnCredentials* turn_credentials);
  private:
  const ::signal_rtc::TurnCredentials& _internal_turn_credentials() const;
  ::signal_rtc::TurnCredentials* _internal_mutable_turn_credentials();
  public:
  void unsafe_arena_set_allocated_turn_credentials(
      ::signal_rtc::TurnCredentials* turn_credentials);
  ::signal_rtc::TurnCredentials* unsafe_arena_release_turn_credentials();

  // @@protoc_insertion_point(class_scope:signal_rtc.BridgeJoinAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr listener_ip_port_;
  ::signal_rtc::TurnCredentials* turn_credentials_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class LeaveFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.LeaveFrame) */ {
 public:
  inline LeaveFrame() : LeaveFrame(nullptr) {}
  virtual ~LeaveFrame();

  LeaveFrame(const LeaveFrame& from);
  LeaveFrame(LeaveFrame&& from) noexcept
    : LeaveFrame() {
    *this = ::std::move(from);
  }

  inline LeaveFrame& operator=(const LeaveFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveFrame& operator=(LeaveFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LeaveFrame& default_instance();

  static inline const LeaveFrame* internal_default_instance() {
    return reinterpret_cast<const LeaveFrame*>(
               &_LeaveFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LeaveFrame& a, LeaveFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LeaveFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveFrame* New() const final {
    return CreateMaybeMessage<LeaveFrame>(nullptr);
  }

  LeaveFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LeaveFrame& from);
  void MergeFrom(const LeaveFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaveFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.LeaveFrame";
  }
  protected:
  explicit LeaveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:signal_rtc.LeaveFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class LeaveAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.LeaveAckFrame) */ {
 public:
  inline LeaveAckFrame() : LeaveAckFrame(nullptr) {}
  virtual ~LeaveAckFrame();

  LeaveAckFrame(const LeaveAckFrame& from);
  LeaveAckFrame(LeaveAckFrame&& from) noexcept
    : LeaveAckFrame() {
    *this = ::std::move(from);
  }

  inline LeaveAckFrame& operator=(const LeaveAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveAckFrame& operator=(LeaveAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LeaveAckFrame& default_instance();

  static inline const LeaveAckFrame* internal_default_instance() {
    return reinterpret_cast<const LeaveAckFrame*>(
               &_LeaveAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LeaveAckFrame& a, LeaveAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LeaveAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveAckFrame* New() const final {
    return CreateMaybeMessage<LeaveAckFrame>(nullptr);
  }

  LeaveAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LeaveAckFrame& from);
  void MergeFrom(const LeaveAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaveAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.LeaveAckFrame";
  }
  protected:
  explicit LeaveAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:signal_rtc.LeaveAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SubscribeFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.SubscribeFrame) */ {
 public:
  inline SubscribeFrame() : SubscribeFrame(nullptr) {}
  virtual ~SubscribeFrame();

  SubscribeFrame(const SubscribeFrame& from);
  SubscribeFrame(SubscribeFrame&& from) noexcept
    : SubscribeFrame() {
    *this = ::std::move(from);
  }

  inline SubscribeFrame& operator=(const SubscribeFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeFrame& operator=(SubscribeFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SubscribeFrame& default_instance();

  static inline const SubscribeFrame* internal_default_instance() {
    return reinterpret_cast<const SubscribeFrame*>(
               &_SubscribeFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SubscribeFrame& a, SubscribeFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SubscribeFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeFrame* New() const final {
    return CreateMaybeMessage<SubscribeFrame>(nullptr);
  }

  SubscribeFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubscribeFrame& from);
  void MergeFrom(const SubscribeFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.SubscribeFrame";
  }
  protected:
  explicit SubscribeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendStreamsFieldNumber = 2,
    kReceiveStreamIdsFieldNumber = 3,
    kSdpOfferFieldNumber = 4,
    kXrpHostFieldNumber = 5,
    kXrpCheckinFieldNumber = 6,
    kXrpMutedFieldNumber = 7,
    kDuplexFieldNumber = 1,
  };
  // repeated .signal_rtc.StreamDescriptor send_streams = 2;
  int send_streams_size() const;
  private:
  int _internal_send_streams_size() const;
  public:
  void clear_send_streams();
  ::signal_rtc::StreamDescriptor* mutable_send_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >*
      mutable_send_streams();
  private:
  const ::signal_rtc::StreamDescriptor& _internal_send_streams(int index) const;
  ::signal_rtc::StreamDescriptor* _internal_add_send_streams();
  public:
  const ::signal_rtc::StreamDescriptor& send_streams(int index) const;
  ::signal_rtc::StreamDescriptor* add_send_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >&
      send_streams() const;

  // repeated uint32 receive_stream_ids = 3;
  int receive_stream_ids_size() const;
  private:
  int _internal_receive_stream_ids_size() const;
  public:
  void clear_receive_stream_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_receive_stream_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_receive_stream_ids() const;
  void _internal_add_receive_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_receive_stream_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 receive_stream_ids(int index) const;
  void set_receive_stream_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_receive_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      receive_stream_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_receive_stream_ids();

  // optional string sdp_offer = 4;
  bool has_sdp_offer() const;
  private:
  bool _internal_has_sdp_offer() const;
  public:
  void clear_sdp_offer();
  const std::string& sdp_offer() const;
  void set_sdp_offer(const std::string& value);
  void set_sdp_offer(std::string&& value);
  void set_sdp_offer(const char* value);
  void set_sdp_offer(const char* value, size_t size);
  std::string* mutable_sdp_offer();
  std::string* release_sdp_offer();
  void set_allocated_sdp_offer(std::string* sdp_offer);
  private:
  const std::string& _internal_sdp_offer() const;
  void _internal_set_sdp_offer(const std::string& value);
  std::string* _internal_mutable_sdp_offer();
  public:

  // optional string xrp_host = 5;
  bool has_xrp_host() const;
  private:
  bool _internal_has_xrp_host() const;
  public:
  void clear_xrp_host();
  const std::string& xrp_host() const;
  void set_xrp_host(const std::string& value);
  void set_xrp_host(std::string&& value);
  void set_xrp_host(const char* value);
  void set_xrp_host(const char* value, size_t size);
  std::string* mutable_xrp_host();
  std::string* release_xrp_host();
  void set_allocated_xrp_host(std::string* xrp_host);
  private:
  const std::string& _internal_xrp_host() const;
  void _internal_set_xrp_host(const std::string& value);
  std::string* _internal_mutable_xrp_host();
  public:

  // optional bool xrp_checkin = 6;
  bool has_xrp_checkin() const;
  private:
  bool _internal_has_xrp_checkin() const;
  public:
  void clear_xrp_checkin();
  bool xrp_checkin() const;
  void set_xrp_checkin(bool value);
  private:
  bool _internal_xrp_checkin() const;
  void _internal_set_xrp_checkin(bool value);
  public:

  // optional bool xrp_muted = 7;
  bool has_xrp_muted() const;
  private:
  bool _internal_has_xrp_muted() const;
  public:
  void clear_xrp_muted();
  bool xrp_muted() const;
  void set_xrp_muted(bool value);
  private:
  bool _internal_xrp_muted() const;
  void _internal_set_xrp_muted(bool value);
  public:

  // optional .signal_rtc.StreamServiceType duplex = 1 [default = RX];
  bool has_duplex() const;
  private:
  bool _internal_has_duplex() const;
  public:
  void clear_duplex();
  ::signal_rtc::StreamServiceType duplex() const;
  void set_duplex(::signal_rtc::StreamServiceType value);
  private:
  ::signal_rtc::StreamServiceType _internal_duplex() const;
  void _internal_set_duplex(::signal_rtc::StreamServiceType value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.SubscribeFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor > send_streams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > receive_stream_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_offer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xrp_host_;
  bool xrp_checkin_;
  bool xrp_muted_;
  int duplex_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SubscribeAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.SubscribeAckFrame) */ {
 public:
  inline SubscribeAckFrame() : SubscribeAckFrame(nullptr) {}
  virtual ~SubscribeAckFrame();

  SubscribeAckFrame(const SubscribeAckFrame& from);
  SubscribeAckFrame(SubscribeAckFrame&& from) noexcept
    : SubscribeAckFrame() {
    *this = ::std::move(from);
  }

  inline SubscribeAckFrame& operator=(const SubscribeAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeAckFrame& operator=(SubscribeAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SubscribeAckFrame& default_instance();

  static inline const SubscribeAckFrame* internal_default_instance() {
    return reinterpret_cast<const SubscribeAckFrame*>(
               &_SubscribeAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubscribeAckFrame& a, SubscribeAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SubscribeAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeAckFrame* New() const final {
    return CreateMaybeMessage<SubscribeAckFrame>(nullptr);
  }

  SubscribeAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SubscribeAckFrame& from);
  void MergeFrom(const SubscribeAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.SubscribeAckFrame";
  }
  protected:
  explicit SubscribeAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocationsFieldNumber = 2,
    kTracksFieldNumber = 4,
    kSdpAnswerFieldNumber = 3,
    kDuplexFieldNumber = 1,
  };
  // repeated .signal_rtc.StreamAllocation allocations = 2;
  int allocations_size() const;
  private:
  int _internal_allocations_size() const;
  public:
  void clear_allocations();
  ::signal_rtc::StreamAllocation* mutable_allocations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamAllocation >*
      mutable_allocations();
  private:
  const ::signal_rtc::StreamAllocation& _internal_allocations(int index) const;
  ::signal_rtc::StreamAllocation* _internal_add_allocations();
  public:
  const ::signal_rtc::StreamAllocation& allocations(int index) const;
  ::signal_rtc::StreamAllocation* add_allocations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamAllocation >&
      allocations() const;

  // repeated .signal_rtc.TrackMapping tracks = 4;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::signal_rtc::TrackMapping* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::TrackMapping >*
      mutable_tracks();
  private:
  const ::signal_rtc::TrackMapping& _internal_tracks(int index) const;
  ::signal_rtc::TrackMapping* _internal_add_tracks();
  public:
  const ::signal_rtc::TrackMapping& tracks(int index) const;
  ::signal_rtc::TrackMapping* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::TrackMapping >&
      tracks() const;

  // optional string sdp_answer = 3;
  bool has_sdp_answer() const;
  private:
  bool _internal_has_sdp_answer() const;
  public:
  void clear_sdp_answer();
  const std::string& sdp_answer() const;
  void set_sdp_answer(const std::string& value);
  void set_sdp_answer(std::string&& value);
  void set_sdp_answer(const char* value);
  void set_sdp_answer(const char* value, size_t size);
  std::string* mutable_sdp_answer();
  std::string* release_sdp_answer();
  void set_allocated_sdp_answer(std::string* sdp_answer);
  private:
  const std::string& _internal_sdp_answer() const;
  void _internal_set_sdp_answer(const std::string& value);
  std::string* _internal_mutable_sdp_answer();
  public:

  // optional .signal_rtc.StreamServiceType duplex = 1;
  bool has_duplex() const;
  private:
  bool _internal_has_duplex() const;
  public:
  void clear_duplex();
  ::signal_rtc::StreamServiceType duplex() const;
  void set_duplex(::signal_rtc::StreamServiceType value);
  private:
  ::signal_rtc::StreamServiceType _internal_duplex() const;
  void _internal_set_duplex(::signal_rtc::StreamServiceType value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.SubscribeAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamAllocation > allocations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::TrackMapping > tracks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_answer_;
  int duplex_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class IndexFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.IndexFrame) */ {
 public:
  inline IndexFrame() : IndexFrame(nullptr) {}
  virtual ~IndexFrame();

  IndexFrame(const IndexFrame& from);
  IndexFrame(IndexFrame&& from) noexcept
    : IndexFrame() {
    *this = ::std::move(from);
  }

  inline IndexFrame& operator=(const IndexFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexFrame& operator=(IndexFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IndexFrame& default_instance();

  static inline const IndexFrame* internal_default_instance() {
    return reinterpret_cast<const IndexFrame*>(
               &_IndexFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IndexFrame& a, IndexFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(IndexFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexFrame* New() const final {
    return CreateMaybeMessage<IndexFrame>(nullptr);
  }

  IndexFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IndexFrame& from);
  void MergeFrom(const IndexFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IndexFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.IndexFrame";
  }
  protected:
  explicit IndexFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 2,
    kPausedAtSourceIdsFieldNumber = 3,
    kAtCapacityFieldNumber = 1,
    kNumParticipantsFieldNumber = 4,
  };
  // repeated .signal_rtc.StreamDescriptor sources = 2;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::signal_rtc::StreamDescriptor* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >*
      mutable_sources();
  private:
  const ::signal_rtc::StreamDescriptor& _internal_sources(int index) const;
  ::signal_rtc::StreamDescriptor* _internal_add_sources();
  public:
  const ::signal_rtc::StreamDescriptor& sources(int index) const;
  ::signal_rtc::StreamDescriptor* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >&
      sources() const;

  // repeated uint32 paused_at_source_ids = 3;
  int paused_at_source_ids_size() const;
  private:
  int _internal_paused_at_source_ids_size() const;
  public:
  void clear_paused_at_source_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_paused_at_source_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_paused_at_source_ids() const;
  void _internal_add_paused_at_source_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_paused_at_source_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 paused_at_source_ids(int index) const;
  void set_paused_at_source_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_paused_at_source_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      paused_at_source_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_paused_at_source_ids();

  // optional bool at_capacity = 1;
  bool has_at_capacity() const;
  private:
  bool _internal_has_at_capacity() const;
  public:
  void clear_at_capacity();
  bool at_capacity() const;
  void set_at_capacity(bool value);
  private:
  bool _internal_at_capacity() const;
  void _internal_set_at_capacity(bool value);
  public:

  // optional uint32 num_participants = 4;
  bool has_num_participants() const;
  private:
  bool _internal_has_num_participants() const;
  public:
  void clear_num_participants();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_participants() const;
  void set_num_participants(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_participants() const;
  void _internal_set_num_participants(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.IndexFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > paused_at_source_ids_;
  bool at_capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_participants_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class PauseResumeFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.PauseResumeFrame) */ {
 public:
  inline PauseResumeFrame() : PauseResumeFrame(nullptr) {}
  virtual ~PauseResumeFrame();

  PauseResumeFrame(const PauseResumeFrame& from);
  PauseResumeFrame(PauseResumeFrame&& from) noexcept
    : PauseResumeFrame() {
    *this = ::std::move(from);
  }

  inline PauseResumeFrame& operator=(const PauseResumeFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseResumeFrame& operator=(PauseResumeFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PauseResumeFrame& default_instance();

  static inline const PauseResumeFrame* internal_default_instance() {
    return reinterpret_cast<const PauseResumeFrame*>(
               &_PauseResumeFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PauseResumeFrame& a, PauseResumeFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PauseResumeFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseResumeFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PauseResumeFrame* New() const final {
    return CreateMaybeMessage<PauseResumeFrame>(nullptr);
  }

  PauseResumeFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PauseResumeFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PauseResumeFrame& from);
  void MergeFrom(const PauseResumeFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PauseResumeFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.PauseResumeFrame";
  }
  protected:
  explicit PauseResumeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdsFieldNumber = 1,
  };
  // repeated uint32 stream_ids = 1;
  int stream_ids_size() const;
  private:
  int _internal_stream_ids_size() const;
  public:
  void clear_stream_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_stream_ids() const;
  void _internal_add_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_stream_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_ids(int index) const;
  void set_stream_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      stream_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_stream_ids();

  // @@protoc_insertion_point(class_scope:signal_rtc.PauseResumeFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > stream_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class BitrateFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.BitrateFrame) */ {
 public:
  inline BitrateFrame() : BitrateFrame(nullptr) {}
  virtual ~BitrateFrame();

  BitrateFrame(const BitrateFrame& from);
  BitrateFrame(BitrateFrame&& from) noexcept
    : BitrateFrame() {
    *this = ::std::move(from);
  }

  inline BitrateFrame& operator=(const BitrateFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitrateFrame& operator=(BitrateFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BitrateFrame& default_instance();

  static inline const BitrateFrame* internal_default_instance() {
    return reinterpret_cast<const BitrateFrame*>(
               &_BitrateFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BitrateFrame& a, BitrateFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BitrateFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitrateFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitrateFrame* New() const final {
    return CreateMaybeMessage<BitrateFrame>(nullptr);
  }

  BitrateFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitrateFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BitrateFrame& from);
  void MergeFrom(const BitrateFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BitrateFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.BitrateFrame";
  }
  protected:
  explicit BitrateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitratesFieldNumber = 1,
  };
  // repeated .signal_rtc.Bitrate bitrates = 1;
  int bitrates_size() const;
  private:
  int _internal_bitrates_size() const;
  public:
  void clear_bitrates();
  ::signal_rtc::Bitrate* mutable_bitrates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Bitrate >*
      mutable_bitrates();
  private:
  const ::signal_rtc::Bitrate& _internal_bitrates(int index) const;
  ::signal_rtc::Bitrate* _internal_add_bitrates();
  public:
  const ::signal_rtc::Bitrate& bitrates(int index) const;
  ::signal_rtc::Bitrate* add_bitrates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Bitrate >&
      bitrates() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.BitrateFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Bitrate > bitrates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class StreamDescriptor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.StreamDescriptor) */ {
 public:
  inline StreamDescriptor() : StreamDescriptor(nullptr) {}
  virtual ~StreamDescriptor();

  StreamDescriptor(const StreamDescriptor& from);
  StreamDescriptor(StreamDescriptor&& from) noexcept
    : StreamDescriptor() {
    *this = ::std::move(from);
  }

  inline StreamDescriptor& operator=(const StreamDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDescriptor& operator=(StreamDescriptor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamDescriptor& default_instance();

  static inline const StreamDescriptor* internal_default_instance() {
    return reinterpret_cast<const StreamDescriptor*>(
               &_StreamDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StreamDescriptor& a, StreamDescriptor& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamDescriptor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamDescriptor* New() const final {
    return CreateMaybeMessage<StreamDescriptor>(nullptr);
  }

  StreamDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamDescriptor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StreamDescriptor& from);
  void MergeFrom(const StreamDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.StreamDescriptor";
  }
  protected:
  explicit StreamDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackLabelFieldNumber = 4,
    kProfileUuidFieldNumber = 8,
    kExternalUserIdFieldNumber = 10,
    kStreamIdFieldNumber = 1,
    kFramerateFieldNumber = 2,
    kMaxBitrateKbpsFieldNumber = 3,
    kProfileIdFieldNumber = 5,
    kGroupIdFieldNumber = 6,
    kAvgBitrateBpsFieldNumber = 7,
    kMediaTypeFieldNumber = 9,
  };
  // optional string track_label = 4;
  bool has_track_label() const;
  private:
  bool _internal_has_track_label() const;
  public:
  void clear_track_label();
  const std::string& track_label() const;
  void set_track_label(const std::string& value);
  void set_track_label(std::string&& value);
  void set_track_label(const char* value);
  void set_track_label(const char* value, size_t size);
  std::string* mutable_track_label();
  std::string* release_track_label();
  void set_allocated_track_label(std::string* track_label);
  private:
  const std::string& _internal_track_label() const;
  void _internal_set_track_label(const std::string& value);
  std::string* _internal_mutable_track_label();
  public:

  // optional string profile_uuid = 8;
  bool has_profile_uuid() const;
  private:
  bool _internal_has_profile_uuid() const;
  public:
  void clear_profile_uuid();
  const std::string& profile_uuid() const;
  void set_profile_uuid(const std::string& value);
  void set_profile_uuid(std::string&& value);
  void set_profile_uuid(const char* value);
  void set_profile_uuid(const char* value, size_t size);
  std::string* mutable_profile_uuid();
  std::string* release_profile_uuid();
  void set_allocated_profile_uuid(std::string* profile_uuid);
  private:
  const std::string& _internal_profile_uuid() const;
  void _internal_set_profile_uuid(const std::string& value);
  std::string* _internal_mutable_profile_uuid();
  public:

  // optional string external_user_id = 10;
  bool has_external_user_id() const;
  private:
  bool _internal_has_external_user_id() const;
  public:
  void clear_external_user_id();
  const std::string& external_user_id() const;
  void set_external_user_id(const std::string& value);
  void set_external_user_id(std::string&& value);
  void set_external_user_id(const char* value);
  void set_external_user_id(const char* value, size_t size);
  std::string* mutable_external_user_id();
  std::string* release_external_user_id();
  void set_allocated_external_user_id(std::string* external_user_id);
  private:
  const std::string& _internal_external_user_id() const;
  void _internal_set_external_user_id(const std::string& value);
  std::string* _internal_mutable_external_user_id();
  public:

  // optional uint32 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 framerate = 2;
  bool has_framerate() const;
  private:
  bool _internal_has_framerate() const;
  public:
  void clear_framerate();
  ::PROTOBUF_NAMESPACE_ID::uint32 framerate() const;
  void set_framerate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_framerate() const;
  void _internal_set_framerate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_bitrate_kbps = 3;
  bool has_max_bitrate_kbps() const;
  private:
  bool _internal_has_max_bitrate_kbps() const;
  public:
  void clear_max_bitrate_kbps();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bitrate_kbps() const;
  void set_max_bitrate_kbps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_bitrate_kbps() const;
  void _internal_set_max_bitrate_kbps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 profile_id = 5;
  bool has_profile_id() const;
  private:
  bool _internal_has_profile_id() const;
  public:
  void clear_profile_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 profile_id() const;
  void set_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_profile_id() const;
  void _internal_set_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 group_id = 6;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 avg_bitrate_bps = 7;
  bool has_avg_bitrate_bps() const;
  private:
  bool _internal_has_avg_bitrate_bps() const;
  public:
  void clear_avg_bitrate_bps();
  ::PROTOBUF_NAMESPACE_ID::uint32 avg_bitrate_bps() const;
  void set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_avg_bitrate_bps() const;
  void _internal_set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .signal_rtc.StreamMediaType media_type = 9;
  bool has_media_type() const;
  private:
  bool _internal_has_media_type() const;
  public:
  void clear_media_type();
  ::signal_rtc::StreamMediaType media_type() const;
  void set_media_type(::signal_rtc::StreamMediaType value);
  private:
  ::signal_rtc::StreamMediaType _internal_media_type() const;
  void _internal_set_media_type(::signal_rtc::StreamMediaType value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.StreamDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 framerate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bitrate_kbps_;
  ::PROTOBUF_NAMESPACE_ID::uint32 profile_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 avg_bitrate_bps_;
  int media_type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class StreamAllocation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.StreamAllocation) */ {
 public:
  inline StreamAllocation() : StreamAllocation(nullptr) {}
  virtual ~StreamAllocation();

  StreamAllocation(const StreamAllocation& from);
  StreamAllocation(StreamAllocation&& from) noexcept
    : StreamAllocation() {
    *this = ::std::move(from);
  }

  inline StreamAllocation& operator=(const StreamAllocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamAllocation& operator=(StreamAllocation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamAllocation& default_instance();

  static inline const StreamAllocation* internal_default_instance() {
    return reinterpret_cast<const StreamAllocation*>(
               &_StreamAllocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StreamAllocation& a, StreamAllocation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamAllocation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamAllocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamAllocation* New() const final {
    return CreateMaybeMessage<StreamAllocation>(nullptr);
  }

  StreamAllocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamAllocation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StreamAllocation& from);
  void MergeFrom(const StreamAllocation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamAllocation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.StreamAllocation";
  }
  protected:
  explicit StreamAllocation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackLabelFieldNumber = 1,
    kStreamIdFieldNumber = 2,
    kGroupIdFieldNumber = 3,
  };
  // optional string track_label = 1;
  bool has_track_label() const;
  private:
  bool _internal_has_track_label() const;
  public:
  void clear_track_label();
  const std::string& track_label() const;
  void set_track_label(const std::string& value);
  void set_track_label(std::string&& value);
  void set_track_label(const char* value);
  void set_track_label(const char* value, size_t size);
  std::string* mutable_track_label();
  std::string* release_track_label();
  void set_allocated_track_label(std::string* track_label);
  private:
  const std::string& _internal_track_label() const;
  void _internal_set_track_label(const std::string& value);
  std::string* _internal_mutable_track_label();
  public:

  // optional uint32 stream_id = 2;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 group_id = 3;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.StreamAllocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_label_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class TrackMapping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.TrackMapping) */ {
 public:
  inline TrackMapping() : TrackMapping(nullptr) {}
  virtual ~TrackMapping();

  TrackMapping(const TrackMapping& from);
  TrackMapping(TrackMapping&& from) noexcept
    : TrackMapping() {
    *this = ::std::move(from);
  }

  inline TrackMapping& operator=(const TrackMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackMapping& operator=(TrackMapping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TrackMapping& default_instance();

  static inline const TrackMapping* internal_default_instance() {
    return reinterpret_cast<const TrackMapping*>(
               &_TrackMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TrackMapping& a, TrackMapping& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TrackMapping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrackMapping* New() const final {
    return CreateMaybeMessage<TrackMapping>(nullptr);
  }

  TrackMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackMapping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TrackMapping& from);
  void MergeFrom(const TrackMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrackMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.TrackMapping";
  }
  protected:
  explicit TrackMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackLabelFieldNumber = 3,
    kStreamIdFieldNumber = 1,
    kSsrcFieldNumber = 2,
  };
  // optional string track_label = 3;
  bool has_track_label() const;
  private:
  bool _internal_has_track_label() const;
  public:
  void clear_track_label();
  const std::string& track_label() const;
  void set_track_label(const std::string& value);
  void set_track_label(std::string&& value);
  void set_track_label(const char* value);
  void set_track_label(const char* value, size_t size);
  std::string* mutable_track_label();
  std::string* release_track_label();
  void set_allocated_track_label(std::string* track_label);
  private:
  const std::string& _internal_track_label() const;
  void _internal_set_track_label(const std::string& value);
  std::string* _internal_mutable_track_label();
  public:

  // optional uint32 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 ssrc = 2;
  bool has_ssrc() const;
  private:
  bool _internal_has_ssrc() const;
  public:
  void clear_ssrc();
  ::PROTOBUF_NAMESPACE_ID::uint32 ssrc() const;
  void set_ssrc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ssrc() const;
  void _internal_set_ssrc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.TrackMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_label_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ssrc_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Bitrate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.Bitrate) */ {
 public:
  inline Bitrate() : Bitrate(nullptr) {}
  virtual ~Bitrate();

  Bitrate(const Bitrate& from);
  Bitrate(Bitrate&& from) noexcept
    : Bitrate() {
    *this = ::std::move(from);
  }

  inline Bitrate& operator=(const Bitrate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bitrate& operator=(Bitrate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Bitrate& default_instance();

  static inline const Bitrate* internal_default_instance() {
    return reinterpret_cast<const Bitrate*>(
               &_Bitrate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Bitrate& a, Bitrate& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Bitrate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bitrate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bitrate* New() const final {
    return CreateMaybeMessage<Bitrate>(nullptr);
  }

  Bitrate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bitrate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Bitrate& from);
  void MergeFrom(const Bitrate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bitrate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.Bitrate";
  }
  protected:
  explicit Bitrate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceStreamIdFieldNumber = 1,
    kAvgBitrateBpsFieldNumber = 2,
  };
  // optional uint32 source_stream_id = 1;
  bool has_source_stream_id() const;
  private:
  bool _internal_has_source_stream_id() const;
  public:
  void clear_source_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 source_stream_id() const;
  void set_source_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_source_stream_id() const;
  void _internal_set_source_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 avg_bitrate_bps = 2;
  bool has_avg_bitrate_bps() const;
  private:
  bool _internal_has_avg_bitrate_bps() const;
  public:
  void clear_avg_bitrate_bps();
  ::PROTOBUF_NAMESPACE_ID::uint32 avg_bitrate_bps() const;
  void set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_avg_bitrate_bps() const;
  void _internal_set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.Bitrate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 source_stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 avg_bitrate_bps_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioControlFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioControlFrame) */ {
 public:
  inline AudioControlFrame() : AudioControlFrame(nullptr) {}
  virtual ~AudioControlFrame();

  AudioControlFrame(const AudioControlFrame& from);
  AudioControlFrame(AudioControlFrame&& from) noexcept
    : AudioControlFrame() {
    *this = ::std::move(from);
  }

  inline AudioControlFrame& operator=(const AudioControlFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioControlFrame& operator=(AudioControlFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioControlFrame& default_instance();

  static inline const AudioControlFrame* internal_default_instance() {
    return reinterpret_cast<const AudioControlFrame*>(
               &_AudioControlFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AudioControlFrame& a, AudioControlFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioControlFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioControlFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioControlFrame* New() const final {
    return CreateMaybeMessage<AudioControlFrame>(nullptr);
  }

  AudioControlFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioControlFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioControlFrame& from);
  void MergeFrom(const AudioControlFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioControlFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioControlFrame";
  }
  protected:
  explicit AudioControlFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutedFieldNumber = 1,
  };
  // optional bool muted = 1;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioControlFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool muted_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioMetadataFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioMetadataFrame) */ {
 public:
  inline AudioMetadataFrame() : AudioMetadataFrame(nullptr) {}
  virtual ~AudioMetadataFrame();

  AudioMetadataFrame(const AudioMetadataFrame& from);
  AudioMetadataFrame(AudioMetadataFrame&& from) noexcept
    : AudioMetadataFrame() {
    *this = ::std::move(from);
  }

  inline AudioMetadataFrame& operator=(const AudioMetadataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioMetadataFrame& operator=(AudioMetadataFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioMetadataFrame& default_instance();

  static inline const AudioMetadataFrame* internal_default_instance() {
    return reinterpret_cast<const AudioMetadataFrame*>(
               &_AudioMetadataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AudioMetadataFrame& a, AudioMetadataFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioMetadataFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioMetadataFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioMetadataFrame* New() const final {
    return CreateMaybeMessage<AudioMetadataFrame>(nullptr);
  }

  AudioMetadataFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioMetadataFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioMetadataFrame& from);
  void MergeFrom(const AudioMetadataFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioMetadataFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioMetadataFrame";
  }
  protected:
  explicit AudioMetadataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileStatesFieldNumber = 1,
  };
  // repeated .signal_rtc.AudioProfileState profile_states = 1;
  int profile_states_size() const;
  private:
  int _internal_profile_states_size() const;
  public:
  void clear_profile_states();
  ::signal_rtc::AudioProfileState* mutable_profile_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioProfileState >*
      mutable_profile_states();
  private:
  const ::signal_rtc::AudioProfileState& _internal_profile_states(int index) const;
  ::signal_rtc::AudioProfileState* _internal_add_profile_states();
  public:
  const ::signal_rtc::AudioProfileState& profile_states(int index) const;
  ::signal_rtc::AudioProfileState* add_profile_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioProfileState >&
      profile_states() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioMetadataFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioProfileState > profile_states_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioProfileState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioProfileState) */ {
 public:
  inline AudioProfileState() : AudioProfileState(nullptr) {}
  virtual ~AudioProfileState();

  AudioProfileState(const AudioProfileState& from);
  AudioProfileState(AudioProfileState&& from) noexcept
    : AudioProfileState() {
    *this = ::std::move(from);
  }

  inline AudioProfileState& operator=(const AudioProfileState& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioProfileState& operator=(AudioProfileState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioProfileState& default_instance();

  static inline const AudioProfileState* internal_default_instance() {
    return reinterpret_cast<const AudioProfileState*>(
               &_AudioProfileState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AudioProfileState& a, AudioProfileState& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioProfileState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioProfileState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioProfileState* New() const final {
    return CreateMaybeMessage<AudioProfileState>(nullptr);
  }

  AudioProfileState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioProfileState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioProfileState& from);
  void MergeFrom(const AudioProfileState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioProfileState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioProfileState";
  }
  protected:
  explicit AudioProfileState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioStreamIdFieldNumber = 1,
    kVolumeFieldNumber = 2,
    kMutedFieldNumber = 3,
    kSignalStrengthFieldNumber = 4,
    kNtpTimestampFieldNumber = 5,
  };
  // optional uint32 audio_stream_id = 1;
  bool has_audio_stream_id() const;
  private:
  bool _internal_has_audio_stream_id() const;
  public:
  void clear_audio_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_stream_id() const;
  void set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_audio_stream_id() const;
  void _internal_set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 volume = 2;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  ::PROTOBUF_NAMESPACE_ID::uint32 volume() const;
  void set_volume(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_volume() const;
  void _internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool muted = 3;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // optional uint32 signal_strength = 4;
  bool has_signal_strength() const;
  private:
  bool _internal_has_signal_strength() const;
  public:
  void clear_signal_strength();
  ::PROTOBUF_NAMESPACE_ID::uint32 signal_strength() const;
  void set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_signal_strength() const;
  void _internal_set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional fixed64 ntp_timestamp = 5;
  bool has_ntp_timestamp() const;
  private:
  bool _internal_has_ntp_timestamp() const;
  public:
  void clear_ntp_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 ntp_timestamp() const;
  void set_ntp_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ntp_timestamp() const;
  void _internal_set_ntp_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioProfileState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volume_;
  bool muted_;
  ::PROTOBUF_NAMESPACE_ID::uint32 signal_strength_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ntp_timestamp_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamIdInfoFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioStreamIdInfoFrame) */ {
 public:
  inline AudioStreamIdInfoFrame() : AudioStreamIdInfoFrame(nullptr) {}
  virtual ~AudioStreamIdInfoFrame();

  AudioStreamIdInfoFrame(const AudioStreamIdInfoFrame& from);
  AudioStreamIdInfoFrame(AudioStreamIdInfoFrame&& from) noexcept
    : AudioStreamIdInfoFrame() {
    *this = ::std::move(from);
  }

  inline AudioStreamIdInfoFrame& operator=(const AudioStreamIdInfoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamIdInfoFrame& operator=(AudioStreamIdInfoFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioStreamIdInfoFrame& default_instance();

  static inline const AudioStreamIdInfoFrame* internal_default_instance() {
    return reinterpret_cast<const AudioStreamIdInfoFrame*>(
               &_AudioStreamIdInfoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AudioStreamIdInfoFrame& a, AudioStreamIdInfoFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioStreamIdInfoFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamIdInfoFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioStreamIdInfoFrame* New() const final {
    return CreateMaybeMessage<AudioStreamIdInfoFrame>(nullptr);
  }

  AudioStreamIdInfoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioStreamIdInfoFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioStreamIdInfoFrame& from);
  void MergeFrom(const AudioStreamIdInfoFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioStreamIdInfoFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioStreamIdInfoFrame";
  }
  protected:
  explicit AudioStreamIdInfoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 1,
  };
  // repeated .signal_rtc.AudioStreamIdInfo streams = 1;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::signal_rtc::AudioStreamIdInfo* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioStreamIdInfo >*
      mutable_streams();
  private:
  const ::signal_rtc::AudioStreamIdInfo& _internal_streams(int index) const;
  ::signal_rtc::AudioStreamIdInfo* _internal_add_streams();
  public:
  const ::signal_rtc::AudioStreamIdInfo& streams(int index) const;
  ::signal_rtc::AudioStreamIdInfo* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioStreamIdInfo >&
      streams() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioStreamIdInfoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioStreamIdInfo > streams_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamIdInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioStreamIdInfo) */ {
 public:
  inline AudioStreamIdInfo() : AudioStreamIdInfo(nullptr) {}
  virtual ~AudioStreamIdInfo();

  AudioStreamIdInfo(const AudioStreamIdInfo& from);
  AudioStreamIdInfo(AudioStreamIdInfo&& from) noexcept
    : AudioStreamIdInfo() {
    *this = ::std::move(from);
  }

  inline AudioStreamIdInfo& operator=(const AudioStreamIdInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamIdInfo& operator=(AudioStreamIdInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioStreamIdInfo& default_instance();

  static inline const AudioStreamIdInfo* internal_default_instance() {
    return reinterpret_cast<const AudioStreamIdInfo*>(
               &_AudioStreamIdInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AudioStreamIdInfo& a, AudioStreamIdInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioStreamIdInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamIdInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioStreamIdInfo* New() const final {
    return CreateMaybeMessage<AudioStreamIdInfo>(nullptr);
  }

  AudioStreamIdInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioStreamIdInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioStreamIdInfo& from);
  void MergeFrom(const AudioStreamIdInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioStreamIdInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioStreamIdInfo";
  }
  protected:
  explicit AudioStreamIdInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileIdFieldNumber = 2,
    kExternalUserIdFieldNumber = 4,
    kAudioStreamIdFieldNumber = 1,
    kMutedFieldNumber = 3,
    kDroppedFieldNumber = 5,
  };
  // optional string profile_id = 2;
  bool has_profile_id() const;
  private:
  bool _internal_has_profile_id() const;
  public:
  void clear_profile_id();
  const std::string& profile_id() const;
  void set_profile_id(const std::string& value);
  void set_profile_id(std::string&& value);
  void set_profile_id(const char* value);
  void set_profile_id(const char* value, size_t size);
  std::string* mutable_profile_id();
  std::string* release_profile_id();
  void set_allocated_profile_id(std::string* profile_id);
  private:
  const std::string& _internal_profile_id() const;
  void _internal_set_profile_id(const std::string& value);
  std::string* _internal_mutable_profile_id();
  public:

  // optional string external_user_id = 4;
  bool has_external_user_id() const;
  private:
  bool _internal_has_external_user_id() const;
  public:
  void clear_external_user_id();
  const std::string& external_user_id() const;
  void set_external_user_id(const std::string& value);
  void set_external_user_id(std::string&& value);
  void set_external_user_id(const char* value);
  void set_external_user_id(const char* value, size_t size);
  std::string* mutable_external_user_id();
  std::string* release_external_user_id();
  void set_allocated_external_user_id(std::string* external_user_id);
  private:
  const std::string& _internal_external_user_id() const;
  void _internal_set_external_user_id(const std::string& value);
  std::string* _internal_mutable_external_user_id();
  public:

  // optional uint32 audio_stream_id = 1;
  bool has_audio_stream_id() const;
  private:
  bool _internal_has_audio_stream_id() const;
  public:
  void clear_audio_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_stream_id() const;
  void set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_audio_stream_id() const;
  void _internal_set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool muted = 3;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // optional bool dropped = 5;
  bool has_dropped() const;
  private:
  bool _internal_has_dropped() const;
  public:
  void clear_dropped();
  bool dropped() const;
  void set_dropped(bool value);
  private:
  bool _internal_dropped() const;
  void _internal_set_dropped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioStreamIdInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_stream_id_;
  bool muted_;
  bool dropped_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class PingPongFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.PingPongFrame) */ {
 public:
  inline PingPongFrame() : PingPongFrame(nullptr) {}
  virtual ~PingPongFrame();

  PingPongFrame(const PingPongFrame& from);
  PingPongFrame(PingPongFrame&& from) noexcept
    : PingPongFrame() {
    *this = ::std::move(from);
  }

  inline PingPongFrame& operator=(const PingPongFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingPongFrame& operator=(PingPongFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PingPongFrame& default_instance();

  static inline const PingPongFrame* internal_default_instance() {
    return reinterpret_cast<const PingPongFrame*>(
               &_PingPongFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PingPongFrame& a, PingPongFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PingPongFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingPongFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingPongFrame* New() const final {
    return CreateMaybeMessage<PingPongFrame>(nullptr);
  }

  PingPongFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingPongFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PingPongFrame& from);
  void MergeFrom(const PingPongFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingPongFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.PingPongFrame";
  }
  protected:
  explicit PingPongFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required uint32 ping_id = 2;
  bool has_ping_id() const;
  private:
  bool _internal_has_ping_id() const;
  public:
  void clear_ping_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 ping_id() const;
  void set_ping_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ping_id() const;
  void _internal_set_ping_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .signal_rtc.PingPongType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::PingPongType type() const;
  void set_type(::signal_rtc::PingPongType value);
  private:
  ::signal_rtc::PingPongType _internal_type() const;
  void _internal_set_type(::signal_rtc::PingPongType value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.PingPongFrame)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ping_id_;
  int type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioStatusFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioStatusFrame) */ {
 public:
  inline AudioStatusFrame() : AudioStatusFrame(nullptr) {}
  virtual ~AudioStatusFrame();

  AudioStatusFrame(const AudioStatusFrame& from);
  AudioStatusFrame(AudioStatusFrame&& from) noexcept
    : AudioStatusFrame() {
    *this = ::std::move(from);
  }

  inline AudioStatusFrame& operator=(const AudioStatusFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStatusFrame& operator=(AudioStatusFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioStatusFrame& default_instance();

  static inline const AudioStatusFrame* internal_default_instance() {
    return reinterpret_cast<const AudioStatusFrame*>(
               &_AudioStatusFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AudioStatusFrame& a, AudioStatusFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioStatusFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStatusFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioStatusFrame* New() const final {
    return CreateMaybeMessage<AudioStatusFrame>(nullptr);
  }

  AudioStatusFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioStatusFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioStatusFrame& from);
  void MergeFrom(const AudioStatusFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioStatusFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioStatusFrame";
  }
  protected:
  explicit AudioStatusFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXrpStatusFieldNumber = 1,
  };
  // optional uint32 xrp_status = 1;
  bool has_xrp_status() const;
  private:
  bool _internal_has_xrp_status() const;
  public:
  void clear_xrp_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 xrp_status() const;
  void set_xrp_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_xrp_status() const;
  void _internal_set_xrp_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioStatusFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 xrp_status_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Metric PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.Metric) */ {
 public:
  inline Metric() : Metric(nullptr) {}
  virtual ~Metric();

  Metric(const Metric& from);
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metric& operator=(Metric&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Metric& default_instance();

  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Metric* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Metric* New() const final {
    return CreateMaybeMessage<Metric>(nullptr);
  }

  Metric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Metric>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Metric& from);
  void MergeFrom(const Metric& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metric* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.Metric";
  }
  protected:
  explicit Metric(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Metric_Type Type;
  static constexpr Type VIDEO_ACTUAL_ENCODER_BITRATE =
    Metric_Type_VIDEO_ACTUAL_ENCODER_BITRATE;
  static constexpr Type VIDEO_AVAILABLE_SEND_BANDWIDTH =
    Metric_Type_VIDEO_AVAILABLE_SEND_BANDWIDTH;
  static constexpr Type VIDEO_RETRANSMIT_BITRATE =
    Metric_Type_VIDEO_RETRANSMIT_BITRATE;
  static constexpr Type VIDEO_AVAILABLE_RECEIVE_BANDWIDTH =
    Metric_Type_VIDEO_AVAILABLE_RECEIVE_BANDWIDTH;
  static constexpr Type VIDEO_TARGET_ENCODER_BITRATE =
    Metric_Type_VIDEO_TARGET_ENCODER_BITRATE;
  static constexpr Type VIDEO_BUCKET_DELAY_MS =
    Metric_Type_VIDEO_BUCKET_DELAY_MS;
  static constexpr Type STUN_RTT_MS =
    Metric_Type_STUN_RTT_MS;
  static constexpr Type SOCKET_DISCARDED_PPS =
    Metric_Type_SOCKET_DISCARDED_PPS;
  static constexpr Type RTC_MIC_JITTER_MS =
    Metric_Type_RTC_MIC_JITTER_MS;
  static constexpr Type RTC_MIC_PPS =
    Metric_Type_RTC_MIC_PPS;
  static constexpr Type RTC_MIC_FRACTION_PACKET_LOST_PERCENT =
    Metric_Type_RTC_MIC_FRACTION_PACKET_LOST_PERCENT;
  static constexpr Type RTC_MIC_BITRATE =
    Metric_Type_RTC_MIC_BITRATE;
  static constexpr Type RTC_MIC_RTT_MS =
    Metric_Type_RTC_MIC_RTT_MS;
  static constexpr Type RTC_SPK_PPS =
    Metric_Type_RTC_SPK_PPS;
  static constexpr Type RTC_SPK_FRACTION_PACKET_LOST_PERCENT =
    Metric_Type_RTC_SPK_FRACTION_PACKET_LOST_PERCENT;
  static constexpr Type RTC_SPK_JITTER_MS =
    Metric_Type_RTC_SPK_JITTER_MS;
  static constexpr Type RTC_SPK_FRACTION_DECODER_LOSS_PERCENT =
    Metric_Type_RTC_SPK_FRACTION_DECODER_LOSS_PERCENT;
  static constexpr Type RTC_SPK_BITRATE =
    Metric_Type_RTC_SPK_BITRATE;
  static constexpr Type RTC_SPK_CURRENT_DELAY_MS =
    Metric_Type_RTC_SPK_CURRENT_DELAY_MS;
  static constexpr Type RTC_SPK_JITTER_BUFFER_MS =
    Metric_Type_RTC_SPK_JITTER_BUFFER_MS;
  static constexpr Type VIDEO_SENT_RTT_MS =
    Metric_Type_VIDEO_SENT_RTT_MS;
  static constexpr Type VIDEO_ENCODE_USAGE_PERCENT =
    Metric_Type_VIDEO_ENCODE_USAGE_PERCENT;
  static constexpr Type VIDEO_NACKS_RECEIVED =
    Metric_Type_VIDEO_NACKS_RECEIVED;
  static constexpr Type VIDEO_PLIS_RECEIVED =
    Metric_Type_VIDEO_PLIS_RECEIVED;
  static constexpr Type VIDEO_AVERAGE_ENCODE_MS =
    Metric_Type_VIDEO_AVERAGE_ENCODE_MS;
  static constexpr Type VIDEO_INPUT_FPS =
    Metric_Type_VIDEO_INPUT_FPS;
  static constexpr Type VIDEO_ENCODE_FPS =
    Metric_Type_VIDEO_ENCODE_FPS;
  static constexpr Type VIDEO_SENT_FPS =
    Metric_Type_VIDEO_SENT_FPS;
  static constexpr Type VIDEO_FIRS_RECEIVED =
    Metric_Type_VIDEO_FIRS_RECEIVED;
  static constexpr Type VIDEO_SENT_PPS =
    Metric_Type_VIDEO_SENT_PPS;
  static constexpr Type VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT =
    Metric_Type_VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT;
  static constexpr Type VIDEO_SENT_BITRATE =
    Metric_Type_VIDEO_SENT_BITRATE;
  static constexpr Type VIDEO_DROPPED_FPS =
    Metric_Type_VIDEO_DROPPED_FPS;
  static constexpr Type VIDEO_TARGET_DELAY_MS =
    Metric_Type_VIDEO_TARGET_DELAY_MS;
  static constexpr Type VIDEO_DECODE_MS =
    Metric_Type_VIDEO_DECODE_MS;
  static constexpr Type VIDEO_OUTPUT_FPS =
    Metric_Type_VIDEO_OUTPUT_FPS;
  static constexpr Type VIDEO_RECEIVED_PPS =
    Metric_Type_VIDEO_RECEIVED_PPS;
  static constexpr Type VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT =
    Metric_Type_VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT;
  static constexpr Type VIDEO_RENDER_DELAY_MS =
    Metric_Type_VIDEO_RENDER_DELAY_MS;
  static constexpr Type VIDEO_RECEIVED_FPS =
    Metric_Type_VIDEO_RECEIVED_FPS;
  static constexpr Type VIDEO_DECODE_FPS =
    Metric_Type_VIDEO_DECODE_FPS;
  static constexpr Type VIDEO_NACKS_SENT =
    Metric_Type_VIDEO_NACKS_SENT;
  static constexpr Type VIDEO_FIRS_SENT =
    Metric_Type_VIDEO_FIRS_SENT;
  static constexpr Type VIDEO_RECEIVED_BITRATE =
    Metric_Type_VIDEO_RECEIVED_BITRATE;
  static constexpr Type VIDEO_CURRENT_DELAY_MS =
    Metric_Type_VIDEO_CURRENT_DELAY_MS;
  static constexpr Type VIDEO_JITTER_BUFFER_MS =
    Metric_Type_VIDEO_JITTER_BUFFER_MS;
  static constexpr Type VIDEO_DISCARDED_PPS =
    Metric_Type_VIDEO_DISCARDED_PPS;
  static constexpr Type VIDEO_PLIS_SENT =
    Metric_Type_VIDEO_PLIS_SENT;
  static constexpr Type VIDEO_RECEIVED_JITTER_MS =
    Metric_Type_VIDEO_RECEIVED_JITTER_MS;
  static constexpr Type VIDEO_SUBSCRIBES_COMPLETED =
    Metric_Type_VIDEO_SUBSCRIBES_COMPLETED;
  static constexpr Type VIDEO_RESETS_STARTED =
    Metric_Type_VIDEO_RESETS_STARTED;
  static constexpr Type VIDEO_LOCAL_RENDER_FPS =
    Metric_Type_VIDEO_LOCAL_RENDER_FPS;
  static constexpr Type PROCESS_CPU =
    Metric_Type_PROCESS_CPU;
  static constexpr Type TOTAL_CPU =
    Metric_Type_TOTAL_CPU;
  static constexpr Type VIDEO_REMOTE_RENDER_FPS =
    Metric_Type_VIDEO_REMOTE_RENDER_FPS;
  static constexpr Type VIDEO_INPUT_HEIGHT =
    Metric_Type_VIDEO_INPUT_HEIGHT;
  static constexpr Type VIDEO_INPUT_ASPECT_RATIO =
    Metric_Type_VIDEO_INPUT_ASPECT_RATIO;
  static constexpr Type VIDEO_SENT_SIMULCAST_STREAMS =
    Metric_Type_VIDEO_SENT_SIMULCAST_STREAMS;
  static constexpr Type VIDEO_SENT_KEYFRAMES =
    Metric_Type_VIDEO_SENT_KEYFRAMES;
  static constexpr Type VIDEO_ENCODE_HEIGHT =
    Metric_Type_VIDEO_ENCODE_HEIGHT;
  static constexpr Type VIDEO_ENCODE_ASPECT_RATIO =
    Metric_Type_VIDEO_ENCODE_ASPECT_RATIO;
  static constexpr Type VIDEO_SENT_QP_SUM =
    Metric_Type_VIDEO_SENT_QP_SUM;
  static constexpr Type VIDEO_ENCODER_CPU_ADAPTATION_DURATION =
    Metric_Type_VIDEO_ENCODER_CPU_ADAPTATION_DURATION;
  static constexpr Type VIDEO_ENCODER_BW_ADAPTATION_DURATION =
    Metric_Type_VIDEO_ENCODER_BW_ADAPTATION_DURATION;
  static constexpr Type VIDEO_DECODE_HEIGHT =
    Metric_Type_VIDEO_DECODE_HEIGHT;
  static constexpr Type VIDEO_DECODE_ASPECT_RATIO =
    Metric_Type_VIDEO_DECODE_ASPECT_RATIO;
  static constexpr Type VIDEO_RECEIVED_KEYFRAMES =
    Metric_Type_VIDEO_RECEIVED_KEYFRAMES;
  static constexpr Type VIDEO_RECEIVED_QP_SUM =
    Metric_Type_VIDEO_RECEIVED_QP_SUM;
  static constexpr Type VIDEO_RECEIVED_TOTAL_FREEZE_DURATION =
    Metric_Type_VIDEO_RECEIVED_TOTAL_FREEZE_DURATION;
  static constexpr Type VIDEO_TARGET_SUBSCRIBED_BITRATE =
    Metric_Type_VIDEO_TARGET_SUBSCRIBED_BITRATE;
  static constexpr Type VIDEO_ACTUAL_SUBSCRIBED_BITRATE =
    Metric_Type_VIDEO_ACTUAL_SUBSCRIBED_BITRATE;
  static constexpr Type VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES =
    Metric_Type_VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES;
  static constexpr Type VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION =
    Metric_Type_VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_FRAME_DROPS =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_DROPS;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_SIGMA =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_SIGMA;
  static constexpr Type VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS =
    Metric_Type_VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS;
  static constexpr Type VIDEO_ENCODE_WIDTH =
    Metric_Type_VIDEO_ENCODE_WIDTH;
  static constexpr Type VIDEO_DECODE_WIDTH =
    Metric_Type_VIDEO_DECODE_WIDTH;
  static inline bool Type_IsValid(int value) {
    return Metric_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Metric_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Metric_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Metric_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Metric_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Metric_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional double value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // optional .signal_rtc.Metric.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::Metric_Type type() const;
  void set_type(::signal_rtc::Metric_Type value);
  private:
  ::signal_rtc::Metric_Type _internal_type() const;
  void _internal_set_type(::signal_rtc::Metric_Type value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.Metric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double value_;
  int type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class StreamMetricFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.StreamMetricFrame) */ {
 public:
  inline StreamMetricFrame() : StreamMetricFrame(nullptr) {}
  virtual ~StreamMetricFrame();

  StreamMetricFrame(const StreamMetricFrame& from);
  StreamMetricFrame(StreamMetricFrame&& from) noexcept
    : StreamMetricFrame() {
    *this = ::std::move(from);
  }

  inline StreamMetricFrame& operator=(const StreamMetricFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMetricFrame& operator=(StreamMetricFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamMetricFrame& default_instance();

  static inline const StreamMetricFrame* internal_default_instance() {
    return reinterpret_cast<const StreamMetricFrame*>(
               &_StreamMetricFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StreamMetricFrame& a, StreamMetricFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamMetricFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMetricFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamMetricFrame* New() const final {
    return CreateMaybeMessage<StreamMetricFrame>(nullptr);
  }

  StreamMetricFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamMetricFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StreamMetricFrame& from);
  void MergeFrom(const StreamMetricFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamMetricFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.StreamMetricFrame";
  }
  protected:
  explicit StreamMetricFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 5,
    kStreamIdFieldNumber = 3,
    kGroupIdFieldNumber = 4,
  };
  // repeated .signal_rtc.Metric metrics = 5;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::signal_rtc::Metric* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >*
      mutable_metrics();
  private:
  const ::signal_rtc::Metric& _internal_metrics(int index) const;
  ::signal_rtc::Metric* _internal_add_metrics();
  public:
  const ::signal_rtc::Metric& metrics(int index) const;
  ::signal_rtc::Metric* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >&
      metrics() const;

  // optional uint32 stream_id = 3;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 group_id = 4;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.StreamMetricFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric > metrics_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class ClientMetricFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.ClientMetricFrame) */ {
 public:
  inline ClientMetricFrame() : ClientMetricFrame(nullptr) {}
  virtual ~ClientMetricFrame();

  ClientMetricFrame(const ClientMetricFrame& from);
  ClientMetricFrame(ClientMetricFrame&& from) noexcept
    : ClientMetricFrame() {
    *this = ::std::move(from);
  }

  inline ClientMetricFrame& operator=(const ClientMetricFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMetricFrame& operator=(ClientMetricFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientMetricFrame& default_instance();

  static inline const ClientMetricFrame* internal_default_instance() {
    return reinterpret_cast<const ClientMetricFrame*>(
               &_ClientMetricFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ClientMetricFrame& a, ClientMetricFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientMetricFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMetricFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientMetricFrame* New() const final {
    return CreateMaybeMessage<ClientMetricFrame>(nullptr);
  }

  ClientMetricFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientMetricFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientMetricFrame& from);
  void MergeFrom(const ClientMetricFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientMetricFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.ClientMetricFrame";
  }
  protected:
  explicit ClientMetricFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalMetricsFieldNumber = 1,
    kStreamMetricFramesFieldNumber = 2,
  };
  // repeated .signal_rtc.Metric global_metrics = 1;
  int global_metrics_size() const;
  private:
  int _internal_global_metrics_size() const;
  public:
  void clear_global_metrics();
  ::signal_rtc::Metric* mutable_global_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >*
      mutable_global_metrics();
  private:
  const ::signal_rtc::Metric& _internal_global_metrics(int index) const;
  ::signal_rtc::Metric* _internal_add_global_metrics();
  public:
  const ::signal_rtc::Metric& global_metrics(int index) const;
  ::signal_rtc::Metric* add_global_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >&
      global_metrics() const;

  // repeated .signal_rtc.StreamMetricFrame stream_metric_frames = 2;
  int stream_metric_frames_size() const;
  private:
  int _internal_stream_metric_frames_size() const;
  public:
  void clear_stream_metric_frames();
  ::signal_rtc::StreamMetricFrame* mutable_stream_metric_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamMetricFrame >*
      mutable_stream_metric_frames();
  private:
  const ::signal_rtc::StreamMetricFrame& _internal_stream_metric_frames(int index) const;
  ::signal_rtc::StreamMetricFrame* _internal_add_stream_metric_frames();
  public:
  const ::signal_rtc::StreamMetricFrame& stream_metric_frames(int index) const;
  ::signal_rtc::StreamMetricFrame* add_stream_metric_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamMetricFrame >&
      stream_metric_frames() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.ClientMetricFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric > global_metrics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamMetricFrame > stream_metric_frames_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DataMessageFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.DataMessageFrame) */ {
 public:
  inline DataMessageFrame() : DataMessageFrame(nullptr) {}
  virtual ~DataMessageFrame();

  DataMessageFrame(const DataMessageFrame& from);
  DataMessageFrame(DataMessageFrame&& from) noexcept
    : DataMessageFrame() {
    *this = ::std::move(from);
  }

  inline DataMessageFrame& operator=(const DataMessageFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessageFrame& operator=(DataMessageFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessageFrame& default_instance();

  static inline const DataMessageFrame* internal_default_instance() {
    return reinterpret_cast<const DataMessageFrame*>(
               &_DataMessageFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DataMessageFrame& a, DataMessageFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataMessageFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessageFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMessageFrame* New() const final {
    return CreateMaybeMessage<DataMessageFrame>(nullptr);
  }

  DataMessageFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMessageFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DataMessageFrame& from);
  void MergeFrom(const DataMessageFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessageFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.DataMessageFrame";
  }
  protected:
  explicit DataMessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .signal_rtc.DataMessagePayload messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::signal_rtc::DataMessagePayload* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::DataMessagePayload >*
      mutable_messages();
  private:
  const ::signal_rtc::DataMessagePayload& _internal_messages(int index) const;
  ::signal_rtc::DataMessagePayload* _internal_add_messages();
  public:
  const ::signal_rtc::DataMessagePayload& messages(int index) const;
  ::signal_rtc::DataMessagePayload* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::DataMessagePayload >&
      messages() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.DataMessageFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::DataMessagePayload > messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DataMessagePayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.DataMessagePayload) */ {
 public:
  inline DataMessagePayload() : DataMessagePayload(nullptr) {}
  virtual ~DataMessagePayload();

  DataMessagePayload(const DataMessagePayload& from);
  DataMessagePayload(DataMessagePayload&& from) noexcept
    : DataMessagePayload() {
    *this = ::std::move(from);
  }

  inline DataMessagePayload& operator=(const DataMessagePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessagePayload& operator=(DataMessagePayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessagePayload& default_instance();

  static inline const DataMessagePayload* internal_default_instance() {
    return reinterpret_cast<const DataMessagePayload*>(
               &_DataMessagePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DataMessagePayload& a, DataMessagePayload& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataMessagePayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessagePayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMessagePayload* New() const final {
    return CreateMaybeMessage<DataMessagePayload>(nullptr);
  }

  DataMessagePayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMessagePayload>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DataMessagePayload& from);
  void MergeFrom(const DataMessagePayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessagePayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.DataMessagePayload";
  }
  protected:
  explicit DataMessagePayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kDataFieldNumber = 2,
    kSenderProfileIdFieldNumber = 4,
    kSenderExternalUserIdFieldNumber = 6,
    kIngestTimeNsFieldNumber = 5,
    kLifetimeMsFieldNumber = 3,
  };
  // optional string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  void set_topic(const std::string& value);
  void set_topic(std::string&& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  std::string* mutable_topic();
  std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional string sender_profile_id = 4;
  bool has_sender_profile_id() const;
  private:
  bool _internal_has_sender_profile_id() const;
  public:
  void clear_sender_profile_id();
  const std::string& sender_profile_id() const;
  void set_sender_profile_id(const std::string& value);
  void set_sender_profile_id(std::string&& value);
  void set_sender_profile_id(const char* value);
  void set_sender_profile_id(const char* value, size_t size);
  std::string* mutable_sender_profile_id();
  std::string* release_sender_profile_id();
  void set_allocated_sender_profile_id(std::string* sender_profile_id);
  private:
  const std::string& _internal_sender_profile_id() const;
  void _internal_set_sender_profile_id(const std::string& value);
  std::string* _internal_mutable_sender_profile_id();
  public:

  // optional string sender_external_user_id = 6;
  bool has_sender_external_user_id() const;
  private:
  bool _internal_has_sender_external_user_id() const;
  public:
  void clear_sender_external_user_id();
  const std::string& sender_external_user_id() const;
  void set_sender_external_user_id(const std::string& value);
  void set_sender_external_user_id(std::string&& value);
  void set_sender_external_user_id(const char* value);
  void set_sender_external_user_id(const char* value, size_t size);
  std::string* mutable_sender_external_user_id();
  std::string* release_sender_external_user_id();
  void set_allocated_sender_external_user_id(std::string* sender_external_user_id);
  private:
  const std::string& _internal_sender_external_user_id() const;
  void _internal_set_sender_external_user_id(const std::string& value);
  std::string* _internal_mutable_sender_external_user_id();
  public:

  // optional int64 ingest_time_ns = 5;
  bool has_ingest_time_ns() const;
  private:
  bool _internal_has_ingest_time_ns() const;
  public:
  void clear_ingest_time_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 ingest_time_ns() const;
  void set_ingest_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ingest_time_ns() const;
  void _internal_set_ingest_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint32 lifetime_ms = 3;
  bool has_lifetime_ms() const;
  private:
  bool _internal_has_lifetime_ms() const;
  public:
  void clear_lifetime_ms();
  ::PROTOBUF_NAMESPACE_ID::uint32 lifetime_ms() const;
  void set_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lifetime_ms() const;
  void _internal_set_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.DataMessagePayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_profile_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_external_user_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 ingest_time_ns_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lifetime_ms_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class TurnCredentials PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.TurnCredentials) */ {
 public:
  inline TurnCredentials() : TurnCredentials(nullptr) {}
  virtual ~TurnCredentials();

  TurnCredentials(const TurnCredentials& from);
  TurnCredentials(TurnCredentials&& from) noexcept
    : TurnCredentials() {
    *this = ::std::move(from);
  }

  inline TurnCredentials& operator=(const TurnCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnCredentials& operator=(TurnCredentials&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TurnCredentials& default_instance();

  static inline const TurnCredentials* internal_default_instance() {
    return reinterpret_cast<const TurnCredentials*>(
               &_TurnCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TurnCredentials& a, TurnCredentials& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TurnCredentials* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TurnCredentials* New() const final {
    return CreateMaybeMessage<TurnCredentials>(nullptr);
  }

  TurnCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TurnCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TurnCredentials& from);
  void MergeFrom(const TurnCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TurnCredentials* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.TurnCredentials";
  }
  protected:
  explicit TurnCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrisFieldNumber = 4,
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kTtlFieldNumber = 3,
  };
  // repeated string uris = 4;
  int uris_size() const;
  private:
  int _internal_uris_size() const;
  public:
  void clear_uris();
  const std::string& uris(int index) const;
  std::string* mutable_uris(int index);
  void set_uris(int index, const std::string& value);
  void set_uris(int index, std::string&& value);
  void set_uris(int index, const char* value);
  void set_uris(int index, const char* value, size_t size);
  std::string* add_uris();
  void add_uris(const std::string& value);
  void add_uris(std::string&& value);
  void add_uris(const char* value);
  void add_uris(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uris() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uris();
  private:
  const std::string& _internal_uris(int index) const;
  std::string* _internal_add_uris();
  public:

  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional uint32 ttl = 3;
  bool has_ttl() const;
  private:
  bool _internal_has_ttl() const;
  public:
  void clear_ttl();
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl() const;
  void set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ttl() const;
  void _internal_set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.TurnCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uris_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptItem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptItem) */ {
 public:
  inline AudioTranscriptItem() : AudioTranscriptItem(nullptr) {}
  virtual ~AudioTranscriptItem();

  AudioTranscriptItem(const AudioTranscriptItem& from);
  AudioTranscriptItem(AudioTranscriptItem&& from) noexcept
    : AudioTranscriptItem() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptItem& operator=(const AudioTranscriptItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptItem& operator=(AudioTranscriptItem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptItem& default_instance();

  static inline const AudioTranscriptItem* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptItem*>(
               &_AudioTranscriptItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AudioTranscriptItem& a, AudioTranscriptItem& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptItem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptItem* New() const final {
    return CreateMaybeMessage<AudioTranscriptItem>(nullptr);
  }

  AudioTranscriptItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptItem& from);
  void MergeFrom(const AudioTranscriptItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptItem";
  }
  protected:
  explicit AudioTranscriptItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AudioTranscriptItem_Type Type;
  static constexpr Type PRONUNCIATION =
    AudioTranscriptItem_Type_PRONUNCIATION;
  static constexpr Type PUNCTUATION =
    AudioTranscriptItem_Type_PUNCTUATION;
  static inline bool Type_IsValid(int value) {
    return AudioTranscriptItem_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    AudioTranscriptItem_Type_Type_MIN;
  static constexpr Type Type_MAX =
    AudioTranscriptItem_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    AudioTranscriptItem_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return AudioTranscriptItem_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return AudioTranscriptItem_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kSpeakerAttendeeIdFieldNumber = 3,
    kSpeakerExternalUserIdFieldNumber = 4,
    kEndTimeFieldNumber = 2,
    kStartTimeFieldNumber = 5,
    kConfidenceFieldNumber = 8,
    kVocabularyFilterMatchFieldNumber = 7,
    kStableFieldNumber = 9,
    kTypeFieldNumber = 6,
  };
  // optional string content = 1;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional string speaker_attendee_id = 3;
  bool has_speaker_attendee_id() const;
  private:
  bool _internal_has_speaker_attendee_id() const;
  public:
  void clear_speaker_attendee_id();
  const std::string& speaker_attendee_id() const;
  void set_speaker_attendee_id(const std::string& value);
  void set_speaker_attendee_id(std::string&& value);
  void set_speaker_attendee_id(const char* value);
  void set_speaker_attendee_id(const char* value, size_t size);
  std::string* mutable_speaker_attendee_id();
  std::string* release_speaker_attendee_id();
  void set_allocated_speaker_attendee_id(std::string* speaker_attendee_id);
  private:
  const std::string& _internal_speaker_attendee_id() const;
  void _internal_set_speaker_attendee_id(const std::string& value);
  std::string* _internal_mutable_speaker_attendee_id();
  public:

  // optional string speaker_external_user_id = 4;
  bool has_speaker_external_user_id() const;
  private:
  bool _internal_has_speaker_external_user_id() const;
  public:
  void clear_speaker_external_user_id();
  const std::string& speaker_external_user_id() const;
  void set_speaker_external_user_id(const std::string& value);
  void set_speaker_external_user_id(std::string&& value);
  void set_speaker_external_user_id(const char* value);
  void set_speaker_external_user_id(const char* value, size_t size);
  std::string* mutable_speaker_external_user_id();
  std::string* release_speaker_external_user_id();
  void set_allocated_speaker_external_user_id(std::string* speaker_external_user_id);
  private:
  const std::string& _internal_speaker_external_user_id() const;
  void _internal_set_speaker_external_user_id(const std::string& value);
  std::string* _internal_mutable_speaker_external_user_id();
  public:

  // optional int64 end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 start_time = 5;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional double confidence = 8;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // optional bool vocabulary_filter_match = 7;
  bool has_vocabulary_filter_match() const;
  private:
  bool _internal_has_vocabulary_filter_match() const;
  public:
  void clear_vocabulary_filter_match();
  bool vocabulary_filter_match() const;
  void set_vocabulary_filter_match(bool value);
  private:
  bool _internal_vocabulary_filter_match() const;
  void _internal_set_vocabulary_filter_match(bool value);
  public:

  // optional bool stable = 9;
  bool has_stable() const;
  private:
  bool _internal_has_stable() const;
  public:
  void clear_stable();
  bool stable() const;
  void set_stable(bool value);
  private:
  bool _internal_stable() const;
  void _internal_set_stable(bool value);
  public:

  // optional .signal_rtc.AudioTranscriptItem.Type type = 6;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::AudioTranscriptItem_Type type() const;
  void set_type(::signal_rtc::AudioTranscriptItem_Type value);
  private:
  ::signal_rtc::AudioTranscriptItem_Type _internal_type() const;
  void _internal_set_type(::signal_rtc::AudioTranscriptItem_Type value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_attendee_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_external_user_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  double confidence_;
  bool vocabulary_filter_match_;
  bool stable_;
  int type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptEntity) */ {
 public:
  inline AudioTranscriptEntity() : AudioTranscriptEntity(nullptr) {}
  virtual ~AudioTranscriptEntity();

  AudioTranscriptEntity(const AudioTranscriptEntity& from);
  AudioTranscriptEntity(AudioTranscriptEntity&& from) noexcept
    : AudioTranscriptEntity() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptEntity& operator=(const AudioTranscriptEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptEntity& operator=(AudioTranscriptEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptEntity& default_instance();

  static inline const AudioTranscriptEntity* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptEntity*>(
               &_AudioTranscriptEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AudioTranscriptEntity& a, AudioTranscriptEntity& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptEntity* New() const final {
    return CreateMaybeMessage<AudioTranscriptEntity>(nullptr);
  }

  AudioTranscriptEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptEntity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptEntity& from);
  void MergeFrom(const AudioTranscriptEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptEntity";
  }
  protected:
  explicit AudioTranscriptEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 1,
    kContentFieldNumber = 3,
    kTypeFieldNumber = 6,
    kConfidenceFieldNumber = 2,
    kEndTimeFieldNumber = 4,
    kStartTimeFieldNumber = 5,
  };
  // optional string category = 1;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const std::string& category() const;
  void set_category(const std::string& value);
  void set_category(std::string&& value);
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  std::string* mutable_category();
  std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // optional string content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional string type = 6;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional double confidence = 2;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // optional int64 end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 start_time = 5;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  double confidence_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptAlternative PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptAlternative) */ {
 public:
  inline AudioTranscriptAlternative() : AudioTranscriptAlternative(nullptr) {}
  virtual ~AudioTranscriptAlternative();

  AudioTranscriptAlternative(const AudioTranscriptAlternative& from);
  AudioTranscriptAlternative(AudioTranscriptAlternative&& from) noexcept
    : AudioTranscriptAlternative() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptAlternative& operator=(const AudioTranscriptAlternative& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptAlternative& operator=(AudioTranscriptAlternative&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptAlternative& default_instance();

  static inline const AudioTranscriptAlternative* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptAlternative*>(
               &_AudioTranscriptAlternative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AudioTranscriptAlternative& a, AudioTranscriptAlternative& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptAlternative* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptAlternative* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptAlternative* New() const final {
    return CreateMaybeMessage<AudioTranscriptAlternative>(nullptr);
  }

  AudioTranscriptAlternative* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptAlternative>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptAlternative& from);
  void MergeFrom(const AudioTranscriptAlternative& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptAlternative* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptAlternative";
  }
  protected:
  explicit AudioTranscriptAlternative(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kEntitiesFieldNumber = 3,
    kTranscriptFieldNumber = 2,
  };
  // repeated .signal_rtc.AudioTranscriptItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::signal_rtc::AudioTranscriptItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptItem >*
      mutable_items();
  private:
  const ::signal_rtc::AudioTranscriptItem& _internal_items(int index) const;
  ::signal_rtc::AudioTranscriptItem* _internal_add_items();
  public:
  const ::signal_rtc::AudioTranscriptItem& items(int index) const;
  ::signal_rtc::AudioTranscriptItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptItem >&
      items() const;

  // repeated .signal_rtc.AudioTranscriptEntity entities = 3;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::signal_rtc::AudioTranscriptEntity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEntity >*
      mutable_entities();
  private:
  const ::signal_rtc::AudioTranscriptEntity& _internal_entities(int index) const;
  ::signal_rtc::AudioTranscriptEntity* _internal_add_entities();
  public:
  const ::signal_rtc::AudioTranscriptEntity& entities(int index) const;
  ::signal_rtc::AudioTranscriptEntity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEntity >&
      entities() const;

  // optional string transcript = 2;
  bool has_transcript() const;
  private:
  bool _internal_has_transcript() const;
  public:
  void clear_transcript();
  const std::string& transcript() const;
  void set_transcript(const std::string& value);
  void set_transcript(std::string&& value);
  void set_transcript(const char* value);
  void set_transcript(const char* value, size_t size);
  std::string* mutable_transcript();
  std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptAlternative)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptItem > items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEntity > entities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptResult) */ {
 public:
  inline AudioTranscriptResult() : AudioTranscriptResult(nullptr) {}
  virtual ~AudioTranscriptResult();

  AudioTranscriptResult(const AudioTranscriptResult& from);
  AudioTranscriptResult(AudioTranscriptResult&& from) noexcept
    : AudioTranscriptResult() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptResult& operator=(const AudioTranscriptResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptResult& operator=(AudioTranscriptResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptResult& default_instance();

  static inline const AudioTranscriptResult* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptResult*>(
               &_AudioTranscriptResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(AudioTranscriptResult& a, AudioTranscriptResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptResult* New() const final {
    return CreateMaybeMessage<AudioTranscriptResult>(nullptr);
  }

  AudioTranscriptResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptResult& from);
  void MergeFrom(const AudioTranscriptResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptResult";
  }
  protected:
  explicit AudioTranscriptResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternativesFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultIdFieldNumber = 5,
    kEndTimeFieldNumber = 3,
    kStartTimeFieldNumber = 6,
    kIsPartialFieldNumber = 4,
  };
  // repeated .signal_rtc.AudioTranscriptAlternative alternatives = 1;
  int alternatives_size() const;
  private:
  int _internal_alternatives_size() const;
  public:
  void clear_alternatives();
  ::signal_rtc::AudioTranscriptAlternative* mutable_alternatives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptAlternative >*
      mutable_alternatives();
  private:
  const ::signal_rtc::AudioTranscriptAlternative& _internal_alternatives(int index) const;
  ::signal_rtc::AudioTranscriptAlternative* _internal_add_alternatives();
  public:
  const ::signal_rtc::AudioTranscriptAlternative& alternatives(int index) const;
  ::signal_rtc::AudioTranscriptAlternative* add_alternatives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptAlternative >&
      alternatives() const;

  // optional string channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // optional string result_id = 5;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const std::string& result_id() const;
  void set_result_id(const std::string& value);
  void set_result_id(std::string&& value);
  void set_result_id(const char* value);
  void set_result_id(const char* value, size_t size);
  std::string* mutable_result_id();
  std::string* release_result_id();
  void set_allocated_result_id(std::string* result_id);
  private:
  const std::string& _internal_result_id() const;
  void _internal_set_result_id(const std::string& value);
  std::string* _internal_mutable_result_id();
  public:

  // optional int64 end_time = 3;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 start_time = 6;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_partial = 4;
  bool has_is_partial() const;
  private:
  bool _internal_has_is_partial() const;
  public:
  void clear_is_partial();
  bool is_partial() const;
  void set_is_partial(bool value);
  private:
  bool _internal_is_partial() const;
  void _internal_set_is_partial(bool value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptAlternative > alternatives_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  bool is_partial_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscript PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscript) */ {
 public:
  inline AudioTranscript() : AudioTranscript(nullptr) {}
  virtual ~AudioTranscript();

  AudioTranscript(const AudioTranscript& from);
  AudioTranscript(AudioTranscript&& from) noexcept
    : AudioTranscript() {
    *this = ::std::move(from);
  }

  inline AudioTranscript& operator=(const AudioTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscript& operator=(AudioTranscript&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscript& default_instance();

  static inline const AudioTranscript* internal_default_instance() {
    return reinterpret_cast<const AudioTranscript*>(
               &_AudioTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AudioTranscript& a, AudioTranscript& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscript* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscript* New() const final {
    return CreateMaybeMessage<AudioTranscript>(nullptr);
  }

  AudioTranscript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscript>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscript& from);
  void MergeFrom(const AudioTranscript& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscript* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscript";
  }
  protected:
  explicit AudioTranscript(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .signal_rtc.AudioTranscriptResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::signal_rtc::AudioTranscriptResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptResult >*
      mutable_results();
  private:
  const ::signal_rtc::AudioTranscriptResult& _internal_results(int index) const;
  ::signal_rtc::AudioTranscriptResult* _internal_add_results();
  public:
  const ::signal_rtc::AudioTranscriptResult& results(int index) const;
  ::signal_rtc::AudioTranscriptResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptResult > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class MeetingTranscriptionStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.MeetingTranscriptionStatus) */ {
 public:
  inline MeetingTranscriptionStatus() : MeetingTranscriptionStatus(nullptr) {}
  virtual ~MeetingTranscriptionStatus();

  MeetingTranscriptionStatus(const MeetingTranscriptionStatus& from);
  MeetingTranscriptionStatus(MeetingTranscriptionStatus&& from) noexcept
    : MeetingTranscriptionStatus() {
    *this = ::std::move(from);
  }

  inline MeetingTranscriptionStatus& operator=(const MeetingTranscriptionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeetingTranscriptionStatus& operator=(MeetingTranscriptionStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MeetingTranscriptionStatus& default_instance();

  static inline const MeetingTranscriptionStatus* internal_default_instance() {
    return reinterpret_cast<const MeetingTranscriptionStatus*>(
               &_MeetingTranscriptionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MeetingTranscriptionStatus& a, MeetingTranscriptionStatus& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MeetingTranscriptionStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeetingTranscriptionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeetingTranscriptionStatus* New() const final {
    return CreateMaybeMessage<MeetingTranscriptionStatus>(nullptr);
  }

  MeetingTranscriptionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeetingTranscriptionStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MeetingTranscriptionStatus& from);
  void MergeFrom(const MeetingTranscriptionStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MeetingTranscriptionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.MeetingTranscriptionStatus";
  }
  protected:
  explicit MeetingTranscriptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MeetingTranscriptionStatus_Type Type;
  static constexpr Type STARTED =
    MeetingTranscriptionStatus_Type_STARTED;
  static constexpr Type INTERRUPTED =
    MeetingTranscriptionStatus_Type_INTERRUPTED;
  static constexpr Type RESUMED =
    MeetingTranscriptionStatus_Type_RESUMED;
  static constexpr Type STOPPED =
    MeetingTranscriptionStatus_Type_STOPPED;
  static constexpr Type FAILED =
    MeetingTranscriptionStatus_Type_FAILED;
  static inline bool Type_IsValid(int value) {
    return MeetingTranscriptionStatus_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    MeetingTranscriptionStatus_Type_Type_MIN;
  static constexpr Type Type_MAX =
    MeetingTranscriptionStatus_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    MeetingTranscriptionStatus_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return MeetingTranscriptionStatus_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return MeetingTranscriptionStatus_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTranscriptionRegionFieldNumber = 3,
    kTranscriptionConfigurationFieldNumber = 4,
    kMessageFieldNumber = 5,
    kEventTimeFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string transcription_region = 3;
  bool has_transcription_region() const;
  private:
  bool _internal_has_transcription_region() const;
  public:
  void clear_transcription_region();
  const std::string& transcription_region() const;
  void set_transcription_region(const std::string& value);
  void set_transcription_region(std::string&& value);
  void set_transcription_region(const char* value);
  void set_transcription_region(const char* value, size_t size);
  std::string* mutable_transcription_region();
  std::string* release_transcription_region();
  void set_allocated_transcription_region(std::string* transcription_region);
  private:
  const std::string& _internal_transcription_region() const;
  void _internal_set_transcription_region(const std::string& value);
  std::string* _internal_mutable_transcription_region();
  public:

  // optional string transcription_configuration = 4;
  bool has_transcription_configuration() const;
  private:
  bool _internal_has_transcription_configuration() const;
  public:
  void clear_transcription_configuration();
  const std::string& transcription_configuration() const;
  void set_transcription_configuration(const std::string& value);
  void set_transcription_configuration(std::string&& value);
  void set_transcription_configuration(const char* value);
  void set_transcription_configuration(const char* value, size_t size);
  std::string* mutable_transcription_configuration();
  std::string* release_transcription_configuration();
  void set_allocated_transcription_configuration(std::string* transcription_configuration);
  private:
  const std::string& _internal_transcription_configuration() const;
  void _internal_set_transcription_configuration(const std::string& value);
  std::string* _internal_mutable_transcription_configuration();
  public:

  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional int64 event_time = 2;
  bool has_event_time() const;
  private:
  bool _internal_has_event_time() const;
  public:
  void clear_event_time();
  ::PROTOBUF_NAMESPACE_ID::int64 event_time() const;
  void set_event_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_event_time() const;
  void _internal_set_event_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .signal_rtc.MeetingTranscriptionStatus.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::MeetingTranscriptionStatus_Type type() const;
  void set_type(::signal_rtc::MeetingTranscriptionStatus_Type value);
  private:
  ::signal_rtc::MeetingTranscriptionStatus_Type _internal_type() const;
  void _internal_set_type(::signal_rtc::MeetingTranscriptionStatus_Type value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.MeetingTranscriptionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcription_region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcription_configuration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int64 event_time_;
  int type_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptEvent) */ {
 public:
  inline AudioTranscriptEvent() : AudioTranscriptEvent(nullptr) {}
  virtual ~AudioTranscriptEvent();

  AudioTranscriptEvent(const AudioTranscriptEvent& from);
  AudioTranscriptEvent(AudioTranscriptEvent&& from) noexcept
    : AudioTranscriptEvent() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptEvent& operator=(const AudioTranscriptEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptEvent& operator=(AudioTranscriptEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptEvent& default_instance();

  enum EventCase {
    kStatus = 1,
    kTranscript = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const AudioTranscriptEvent* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptEvent*>(
               &_AudioTranscriptEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AudioTranscriptEvent& a, AudioTranscriptEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptEvent* New() const final {
    return CreateMaybeMessage<AudioTranscriptEvent>(nullptr);
  }

  AudioTranscriptEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptEvent& from);
  void MergeFrom(const AudioTranscriptEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptEvent";
  }
  protected:
  explicit AudioTranscriptEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kTranscriptFieldNumber = 2,
  };
  // .signal_rtc.MeetingTranscriptionStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::signal_rtc::MeetingTranscriptionStatus& status() const;
  ::signal_rtc::MeetingTranscriptionStatus* release_status();
  ::signal_rtc::MeetingTranscriptionStatus* mutable_status();
  void set_allocated_status(::signal_rtc::MeetingTranscriptionStatus* status);
  private:
  const ::signal_rtc::MeetingTranscriptionStatus& _internal_status() const;
  ::signal_rtc::MeetingTranscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::signal_rtc::MeetingTranscriptionStatus* status);
  ::signal_rtc::MeetingTranscriptionStatus* unsafe_arena_release_status();

  // .signal_rtc.AudioTranscript transcript = 2;
  bool has_transcript() const;
  private:
  bool _internal_has_transcript() const;
  public:
  void clear_transcript();
  const ::signal_rtc::AudioTranscript& transcript() const;
  ::signal_rtc::AudioTranscript* release_transcript();
  ::signal_rtc::AudioTranscript* mutable_transcript();
  void set_allocated_transcript(::signal_rtc::AudioTranscript* transcript);
  private:
  const ::signal_rtc::AudioTranscript& _internal_transcript() const;
  ::signal_rtc::AudioTranscript* _internal_mutable_transcript();
  public:
  void unsafe_arena_set_allocated_transcript(
      ::signal_rtc::AudioTranscript* transcript);
  ::signal_rtc::AudioTranscript* unsafe_arena_release_transcript();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptEvent)
 private:
  class _Internal;
  void set_has_status();
  void set_has_transcript();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    EventUnion() {}
    ::signal_rtc::MeetingTranscriptionStatus* status_;
    ::signal_rtc::AudioTranscript* transcript_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioTranscriptFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.AudioTranscriptFrame) */ {
 public:
  inline AudioTranscriptFrame() : AudioTranscriptFrame(nullptr) {}
  virtual ~AudioTranscriptFrame();

  AudioTranscriptFrame(const AudioTranscriptFrame& from);
  AudioTranscriptFrame(AudioTranscriptFrame&& from) noexcept
    : AudioTranscriptFrame() {
    *this = ::std::move(from);
  }

  inline AudioTranscriptFrame& operator=(const AudioTranscriptFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTranscriptFrame& operator=(AudioTranscriptFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioTranscriptFrame& default_instance();

  static inline const AudioTranscriptFrame* internal_default_instance() {
    return reinterpret_cast<const AudioTranscriptFrame*>(
               &_AudioTranscriptFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AudioTranscriptFrame& a, AudioTranscriptFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioTranscriptFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTranscriptFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioTranscriptFrame* New() const final {
    return CreateMaybeMessage<AudioTranscriptFrame>(nullptr);
  }

  AudioTranscriptFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioTranscriptFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioTranscriptFrame& from);
  void MergeFrom(const AudioTranscriptFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioTranscriptFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.AudioTranscriptFrame";
  }
  protected:
  explicit AudioTranscriptFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .signal_rtc.AudioTranscriptEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::signal_rtc::AudioTranscriptEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEvent >*
      mutable_events();
  private:
  const ::signal_rtc::AudioTranscriptEvent& _internal_events(int index) const;
  ::signal_rtc::AudioTranscriptEvent* _internal_add_events();
  public:
  const ::signal_rtc::AudioTranscriptEvent& events(int index) const;
  ::signal_rtc::AudioTranscriptEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEvent >&
      events() const;

  // @@protoc_insertion_point(class_scope:signal_rtc.AudioTranscriptFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEvent > events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class RemoteVideoUpdateFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.RemoteVideoUpdateFrame) */ {
 public:
  inline RemoteVideoUpdateFrame() : RemoteVideoUpdateFrame(nullptr) {}
  virtual ~RemoteVideoUpdateFrame();

  RemoteVideoUpdateFrame(const RemoteVideoUpdateFrame& from);
  RemoteVideoUpdateFrame(RemoteVideoUpdateFrame&& from) noexcept
    : RemoteVideoUpdateFrame() {
    *this = ::std::move(from);
  }

  inline RemoteVideoUpdateFrame& operator=(const RemoteVideoUpdateFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteVideoUpdateFrame& operator=(RemoteVideoUpdateFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoteVideoUpdateFrame& default_instance();

  static inline const RemoteVideoUpdateFrame* internal_default_instance() {
    return reinterpret_cast<const RemoteVideoUpdateFrame*>(
               &_RemoteVideoUpdateFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RemoteVideoUpdateFrame& a, RemoteVideoUpdateFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RemoteVideoUpdateFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteVideoUpdateFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteVideoUpdateFrame* New() const final {
    return CreateMaybeMessage<RemoteVideoUpdateFrame>(nullptr);
  }

  RemoteVideoUpdateFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteVideoUpdateFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RemoteVideoUpdateFrame& from);
  void MergeFrom(const RemoteVideoUpdateFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteVideoUpdateFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.RemoteVideoUpdateFrame";
  }
  protected:
  explicit RemoteVideoUpdateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddedOrUpdatedVideoSubscriptionsFieldNumber = 1,
    kRemovedVideoSubscriptionMidsFieldNumber = 2,
  };
  // repeated .signal_rtc.VideoSubscriptionConfiguration added_or_updated_video_subscriptions = 1;
  int added_or_updated_video_subscriptions_size() const;
  private:
  int _internal_added_or_updated_video_subscriptions_size() const;
  public:
  void clear_added_or_updated_video_subscriptions();
  ::signal_rtc::VideoSubscriptionConfiguration* mutable_added_or_updated_video_subscriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::VideoSubscriptionConfiguration >*
      mutable_added_or_updated_video_subscriptions();
  private:
  const ::signal_rtc::VideoSubscriptionConfiguration& _internal_added_or_updated_video_subscriptions(int index) const;
  ::signal_rtc::VideoSubscriptionConfiguration* _internal_add_added_or_updated_video_subscriptions();
  public:
  const ::signal_rtc::VideoSubscriptionConfiguration& added_or_updated_video_subscriptions(int index) const;
  ::signal_rtc::VideoSubscriptionConfiguration* add_added_or_updated_video_subscriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::VideoSubscriptionConfiguration >&
      added_or_updated_video_subscriptions() const;

  // repeated string removed_video_subscription_mids = 2;
  int removed_video_subscription_mids_size() const;
  private:
  int _internal_removed_video_subscription_mids_size() const;
  public:
  void clear_removed_video_subscription_mids();
  const std::string& removed_video_subscription_mids(int index) const;
  std::string* mutable_removed_video_subscription_mids(int index);
  void set_removed_video_subscription_mids(int index, const std::string& value);
  void set_removed_video_subscription_mids(int index, std::string&& value);
  void set_removed_video_subscription_mids(int index, const char* value);
  void set_removed_video_subscription_mids(int index, const char* value, size_t size);
  std::string* add_removed_video_subscription_mids();
  void add_removed_video_subscription_mids(const std::string& value);
  void add_removed_video_subscription_mids(std::string&& value);
  void add_removed_video_subscription_mids(const char* value);
  void add_removed_video_subscription_mids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& removed_video_subscription_mids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_removed_video_subscription_mids();
  private:
  const std::string& _internal_removed_video_subscription_mids(int index) const;
  std::string* _internal_add_removed_video_subscription_mids();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.RemoteVideoUpdateFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::VideoSubscriptionConfiguration > added_or_updated_video_subscriptions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> removed_video_subscription_mids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class VideoSubscriptionConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.VideoSubscriptionConfiguration) */ {
 public:
  inline VideoSubscriptionConfiguration() : VideoSubscriptionConfiguration(nullptr) {}
  virtual ~VideoSubscriptionConfiguration();

  VideoSubscriptionConfiguration(const VideoSubscriptionConfiguration& from);
  VideoSubscriptionConfiguration(VideoSubscriptionConfiguration&& from) noexcept
    : VideoSubscriptionConfiguration() {
    *this = ::std::move(from);
  }

  inline VideoSubscriptionConfiguration& operator=(const VideoSubscriptionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSubscriptionConfiguration& operator=(VideoSubscriptionConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VideoSubscriptionConfiguration& default_instance();

  static inline const VideoSubscriptionConfiguration* internal_default_instance() {
    return reinterpret_cast<const VideoSubscriptionConfiguration*>(
               &_VideoSubscriptionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(VideoSubscriptionConfiguration& a, VideoSubscriptionConfiguration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoSubscriptionConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSubscriptionConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoSubscriptionConfiguration* New() const final {
    return CreateMaybeMessage<VideoSubscriptionConfiguration>(nullptr);
  }

  VideoSubscriptionConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoSubscriptionConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VideoSubscriptionConfiguration& from);
  void MergeFrom(const VideoSubscriptionConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoSubscriptionConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.VideoSubscriptionConfiguration";
  }
  protected:
  explicit VideoSubscriptionConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidFieldNumber = 1,
    kAttendeeIdFieldNumber = 2,
    kStreamIdFieldNumber = 3,
  };
  // required string mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  const std::string& mid() const;
  void set_mid(const std::string& value);
  void set_mid(std::string&& value);
  void set_mid(const char* value);
  void set_mid(const char* value, size_t size);
  std::string* mutable_mid();
  std::string* release_mid();
  void set_allocated_mid(std::string* mid);
  private:
  const std::string& _internal_mid() const;
  void _internal_set_mid(const std::string& value);
  std::string* _internal_mutable_mid();
  public:

  // optional string attendee_id = 2;
  bool has_attendee_id() const;
  private:
  bool _internal_has_attendee_id() const;
  public:
  void clear_attendee_id();
  const std::string& attendee_id() const;
  void set_attendee_id(const std::string& value);
  void set_attendee_id(std::string&& value);
  void set_attendee_id(const char* value);
  void set_attendee_id(const char* value, size_t size);
  std::string* mutable_attendee_id();
  std::string* release_attendee_id();
  void set_allocated_attendee_id(std::string* attendee_id);
  private:
  const std::string& _internal_attendee_id() const;
  void _internal_set_attendee_id(const std::string& value);
  std::string* _internal_mutable_attendee_id();
  public:

  // optional uint32 stream_id = 3;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.VideoSubscriptionConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attendee_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_id_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class PrimaryMeetingJoinFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.PrimaryMeetingJoinFrame) */ {
 public:
  inline PrimaryMeetingJoinFrame() : PrimaryMeetingJoinFrame(nullptr) {}
  virtual ~PrimaryMeetingJoinFrame();

  PrimaryMeetingJoinFrame(const PrimaryMeetingJoinFrame& from);
  PrimaryMeetingJoinFrame(PrimaryMeetingJoinFrame&& from) noexcept
    : PrimaryMeetingJoinFrame() {
    *this = ::std::move(from);
  }

  inline PrimaryMeetingJoinFrame& operator=(const PrimaryMeetingJoinFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimaryMeetingJoinFrame& operator=(PrimaryMeetingJoinFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrimaryMeetingJoinFrame& default_instance();

  static inline const PrimaryMeetingJoinFrame* internal_default_instance() {
    return reinterpret_cast<const PrimaryMeetingJoinFrame*>(
               &_PrimaryMeetingJoinFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(PrimaryMeetingJoinFrame& a, PrimaryMeetingJoinFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PrimaryMeetingJoinFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimaryMeetingJoinFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrimaryMeetingJoinFrame* New() const final {
    return CreateMaybeMessage<PrimaryMeetingJoinFrame>(nullptr);
  }

  PrimaryMeetingJoinFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrimaryMeetingJoinFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PrimaryMeetingJoinFrame& from);
  void MergeFrom(const PrimaryMeetingJoinFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrimaryMeetingJoinFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.PrimaryMeetingJoinFrame";
  }
  protected:
  explicit PrimaryMeetingJoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialsFieldNumber = 1,
  };
  // optional .signal_rtc.MeetingSessionCredentials credentials = 1;
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::signal_rtc::MeetingSessionCredentials& credentials() const;
  ::signal_rtc::MeetingSessionCredentials* release_credentials();
  ::signal_rtc::MeetingSessionCredentials* mutable_credentials();
  void set_allocated_credentials(::signal_rtc::MeetingSessionCredentials* credentials);
  private:
  const ::signal_rtc::MeetingSessionCredentials& _internal_credentials() const;
  ::signal_rtc::MeetingSessionCredentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::signal_rtc::MeetingSessionCredentials* credentials);
  ::signal_rtc::MeetingSessionCredentials* unsafe_arena_release_credentials();

  // @@protoc_insertion_point(class_scope:signal_rtc.PrimaryMeetingJoinFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::signal_rtc::MeetingSessionCredentials* credentials_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class PrimaryMeetingJoinAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.PrimaryMeetingJoinAckFrame) */ {
 public:
  inline PrimaryMeetingJoinAckFrame() : PrimaryMeetingJoinAckFrame(nullptr) {}
  virtual ~PrimaryMeetingJoinAckFrame();

  PrimaryMeetingJoinAckFrame(const PrimaryMeetingJoinAckFrame& from);
  PrimaryMeetingJoinAckFrame(PrimaryMeetingJoinAckFrame&& from) noexcept
    : PrimaryMeetingJoinAckFrame() {
    *this = ::std::move(from);
  }

  inline PrimaryMeetingJoinAckFrame& operator=(const PrimaryMeetingJoinAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimaryMeetingJoinAckFrame& operator=(PrimaryMeetingJoinAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrimaryMeetingJoinAckFrame& default_instance();

  static inline const PrimaryMeetingJoinAckFrame* internal_default_instance() {
    return reinterpret_cast<const PrimaryMeetingJoinAckFrame*>(
               &_PrimaryMeetingJoinAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PrimaryMeetingJoinAckFrame& a, PrimaryMeetingJoinAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PrimaryMeetingJoinAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimaryMeetingJoinAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrimaryMeetingJoinAckFrame* New() const final {
    return CreateMaybeMessage<PrimaryMeetingJoinAckFrame>(nullptr);
  }

  PrimaryMeetingJoinAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrimaryMeetingJoinAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PrimaryMeetingJoinAckFrame& from);
  void MergeFrom(const PrimaryMeetingJoinAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrimaryMeetingJoinAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.PrimaryMeetingJoinAckFrame";
  }
  protected:
  explicit PrimaryMeetingJoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttendeeIdFieldNumber = 1,
  };
  // optional string attendee_id = 1;
  bool has_attendee_id() const;
  private:
  bool _internal_has_attendee_id() const;
  public:
  void clear_attendee_id();
  const std::string& attendee_id() const;
  void set_attendee_id(const std::string& value);
  void set_attendee_id(std::string&& value);
  void set_attendee_id(const char* value);
  void set_attendee_id(const char* value, size_t size);
  std::string* mutable_attendee_id();
  std::string* release_attendee_id();
  void set_allocated_attendee_id(std::string* attendee_id);
  private:
  const std::string& _internal_attendee_id() const;
  void _internal_set_attendee_id(const std::string& value);
  std::string* _internal_mutable_attendee_id();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.PrimaryMeetingJoinAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attendee_id_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class PrimaryMeetingLeaveFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.PrimaryMeetingLeaveFrame) */ {
 public:
  inline PrimaryMeetingLeaveFrame() : PrimaryMeetingLeaveFrame(nullptr) {}
  virtual ~PrimaryMeetingLeaveFrame();

  PrimaryMeetingLeaveFrame(const PrimaryMeetingLeaveFrame& from);
  PrimaryMeetingLeaveFrame(PrimaryMeetingLeaveFrame&& from) noexcept
    : PrimaryMeetingLeaveFrame() {
    *this = ::std::move(from);
  }

  inline PrimaryMeetingLeaveFrame& operator=(const PrimaryMeetingLeaveFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimaryMeetingLeaveFrame& operator=(PrimaryMeetingLeaveFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrimaryMeetingLeaveFrame& default_instance();

  static inline const PrimaryMeetingLeaveFrame* internal_default_instance() {
    return reinterpret_cast<const PrimaryMeetingLeaveFrame*>(
               &_PrimaryMeetingLeaveFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PrimaryMeetingLeaveFrame& a, PrimaryMeetingLeaveFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PrimaryMeetingLeaveFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimaryMeetingLeaveFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrimaryMeetingLeaveFrame* New() const final {
    return CreateMaybeMessage<PrimaryMeetingLeaveFrame>(nullptr);
  }

  PrimaryMeetingLeaveFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrimaryMeetingLeaveFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PrimaryMeetingLeaveFrame& from);
  void MergeFrom(const PrimaryMeetingLeaveFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrimaryMeetingLeaveFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.PrimaryMeetingLeaveFrame";
  }
  protected:
  explicit PrimaryMeetingLeaveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:signal_rtc.PrimaryMeetingLeaveFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class BridgeReserveFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.BridgeReserveFrame) */ {
 public:
  inline BridgeReserveFrame() : BridgeReserveFrame(nullptr) {}
  virtual ~BridgeReserveFrame();

  BridgeReserveFrame(const BridgeReserveFrame& from);
  BridgeReserveFrame(BridgeReserveFrame&& from) noexcept
    : BridgeReserveFrame() {
    *this = ::std::move(from);
  }

  inline BridgeReserveFrame& operator=(const BridgeReserveFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeReserveFrame& operator=(BridgeReserveFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BridgeReserveFrame& default_instance();

  static inline const BridgeReserveFrame* internal_default_instance() {
    return reinterpret_cast<const BridgeReserveFrame*>(
               &_BridgeReserveFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(BridgeReserveFrame& a, BridgeReserveFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BridgeReserveFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeReserveFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BridgeReserveFrame* New() const final {
    return CreateMaybeMessage<BridgeReserveFrame>(nullptr);
  }

  BridgeReserveFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BridgeReserveFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BridgeReserveFrame& from);
  void MergeFrom(const BridgeReserveFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BridgeReserveFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.BridgeReserveFrame";
  }
  protected:
  explicit BridgeReserveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BridgeReserveFrame_ReservationType ReservationType;
  static constexpr ReservationType VIDEO_INPUT =
    BridgeReserveFrame_ReservationType_VIDEO_INPUT;
  static constexpr ReservationType CONTENT_VIDEO_INPUT =
    BridgeReserveFrame_ReservationType_CONTENT_VIDEO_INPUT;
  static inline bool ReservationType_IsValid(int value) {
    return BridgeReserveFrame_ReservationType_IsValid(value);
  }
  static constexpr ReservationType ReservationType_MIN =
    BridgeReserveFrame_ReservationType_ReservationType_MIN;
  static constexpr ReservationType ReservationType_MAX =
    BridgeReserveFrame_ReservationType_ReservationType_MAX;
  static constexpr int ReservationType_ARRAYSIZE =
    BridgeReserveFrame_ReservationType_ReservationType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ReservationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReservationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReservationType_Name.");
    return BridgeReserveFrame_ReservationType_Name(enum_t_value);
  }
  static inline bool ReservationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReservationType* value) {
    return BridgeReserveFrame_ReservationType_Parse(name, value);
  }

  typedef BridgeReserveFrame_Action Action;
  static constexpr Action RESERVE =
    BridgeReserveFrame_Action_RESERVE;
  static constexpr Action RELEASE =
    BridgeReserveFrame_Action_RELEASE;
  static inline bool Action_IsValid(int value) {
    return BridgeReserveFrame_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    BridgeReserveFrame_Action_Action_MIN;
  static constexpr Action Action_MAX =
    BridgeReserveFrame_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    BridgeReserveFrame_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return BridgeReserveFrame_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return BridgeReserveFrame_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestTokenFieldNumber = 3,
    kTypeFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // optional string client_request_token = 3;
  bool has_client_request_token() const;
  private:
  bool _internal_has_client_request_token() const;
  public:
  void clear_client_request_token();
  const std::string& client_request_token() const;
  void set_client_request_token(const std::string& value);
  void set_client_request_token(std::string&& value);
  void set_client_request_token(const char* value);
  void set_client_request_token(const char* value, size_t size);
  std::string* mutable_client_request_token();
  std::string* release_client_request_token();
  void set_allocated_client_request_token(std::string* client_request_token);
  private:
  const std::string& _internal_client_request_token() const;
  void _internal_set_client_request_token(const std::string& value);
  std::string* _internal_mutable_client_request_token();
  public:

  // optional .signal_rtc.BridgeReserveFrame.ReservationType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::signal_rtc::BridgeReserveFrame_ReservationType type() const;
  void set_type(::signal_rtc::BridgeReserveFrame_ReservationType value);
  private:
  ::signal_rtc::BridgeReserveFrame_ReservationType _internal_type() const;
  void _internal_set_type(::signal_rtc::BridgeReserveFrame_ReservationType value);
  public:

  // optional .signal_rtc.BridgeReserveFrame.Action action = 2;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::signal_rtc::BridgeReserveFrame_Action action() const;
  void set_action(::signal_rtc::BridgeReserveFrame_Action value);
  private:
  ::signal_rtc::BridgeReserveFrame_Action _internal_action() const;
  void _internal_set_action(::signal_rtc::BridgeReserveFrame_Action value);
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.BridgeReserveFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_request_token_;
  int type_;
  int action_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class BridgeReserveAckFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.BridgeReserveAckFrame) */ {
 public:
  inline BridgeReserveAckFrame() : BridgeReserveAckFrame(nullptr) {}
  virtual ~BridgeReserveAckFrame();

  BridgeReserveAckFrame(const BridgeReserveAckFrame& from);
  BridgeReserveAckFrame(BridgeReserveAckFrame&& from) noexcept
    : BridgeReserveAckFrame() {
    *this = ::std::move(from);
  }

  inline BridgeReserveAckFrame& operator=(const BridgeReserveAckFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeReserveAckFrame& operator=(BridgeReserveAckFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BridgeReserveAckFrame& default_instance();

  static inline const BridgeReserveAckFrame* internal_default_instance() {
    return reinterpret_cast<const BridgeReserveAckFrame*>(
               &_BridgeReserveAckFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(BridgeReserveAckFrame& a, BridgeReserveAckFrame& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BridgeReserveAckFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeReserveAckFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BridgeReserveAckFrame* New() const final {
    return CreateMaybeMessage<BridgeReserveAckFrame>(nullptr);
  }

  BridgeReserveAckFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BridgeReserveAckFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BridgeReserveAckFrame& from);
  void MergeFrom(const BridgeReserveAckFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BridgeReserveAckFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.BridgeReserveAckFrame";
  }
  protected:
  explicit BridgeReserveAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestTokenFieldNumber = 1,
  };
  // optional string client_request_token = 1;
  bool has_client_request_token() const;
  private:
  bool _internal_has_client_request_token() const;
  public:
  void clear_client_request_token();
  const std::string& client_request_token() const;
  void set_client_request_token(const std::string& value);
  void set_client_request_token(std::string&& value);
  void set_client_request_token(const char* value);
  void set_client_request_token(const char* value, size_t size);
  std::string* mutable_client_request_token();
  std::string* release_client_request_token();
  void set_allocated_client_request_token(std::string* client_request_token);
  private:
  const std::string& _internal_client_request_token() const;
  void _internal_set_client_request_token(const std::string& value);
  std::string* _internal_mutable_client_request_token();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.BridgeReserveAckFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_request_token_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class MeetingSessionCredentials PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:signal_rtc.MeetingSessionCredentials) */ {
 public:
  inline MeetingSessionCredentials() : MeetingSessionCredentials(nullptr) {}
  virtual ~MeetingSessionCredentials();

  MeetingSessionCredentials(const MeetingSessionCredentials& from);
  MeetingSessionCredentials(MeetingSessionCredentials&& from) noexcept
    : MeetingSessionCredentials() {
    *this = ::std::move(from);
  }

  inline MeetingSessionCredentials& operator=(const MeetingSessionCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeetingSessionCredentials& operator=(MeetingSessionCredentials&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MeetingSessionCredentials& default_instance();

  static inline const MeetingSessionCredentials* internal_default_instance() {
    return reinterpret_cast<const MeetingSessionCredentials*>(
               &_MeetingSessionCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MeetingSessionCredentials& a, MeetingSessionCredentials& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MeetingSessionCredentials* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeetingSessionCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeetingSessionCredentials* New() const final {
    return CreateMaybeMessage<MeetingSessionCredentials>(nullptr);
  }

  MeetingSessionCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeetingSessionCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MeetingSessionCredentials& from);
  void MergeFrom(const MeetingSessionCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MeetingSessionCredentials* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signal_rtc.MeetingSessionCredentials";
  }
  protected:
  explicit MeetingSessionCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttendeeIdFieldNumber = 1,
    kExternalUserIdFieldNumber = 2,
    kJoinTokenFieldNumber = 3,
  };
  // optional string attendee_id = 1;
  bool has_attendee_id() const;
  private:
  bool _internal_has_attendee_id() const;
  public:
  void clear_attendee_id();
  const std::string& attendee_id() const;
  void set_attendee_id(const std::string& value);
  void set_attendee_id(std::string&& value);
  void set_attendee_id(const char* value);
  void set_attendee_id(const char* value, size_t size);
  std::string* mutable_attendee_id();
  std::string* release_attendee_id();
  void set_allocated_attendee_id(std::string* attendee_id);
  private:
  const std::string& _internal_attendee_id() const;
  void _internal_set_attendee_id(const std::string& value);
  std::string* _internal_mutable_attendee_id();
  public:

  // optional string external_user_id = 2;
  bool has_external_user_id() const;
  private:
  bool _internal_has_external_user_id() const;
  public:
  void clear_external_user_id();
  const std::string& external_user_id() const;
  void set_external_user_id(const std::string& value);
  void set_external_user_id(std::string&& value);
  void set_external_user_id(const char* value);
  void set_external_user_id(const char* value, size_t size);
  std::string* mutable_external_user_id();
  std::string* release_external_user_id();
  void set_allocated_external_user_id(std::string* external_user_id);
  private:
  const std::string& _internal_external_user_id() const;
  void _internal_set_external_user_id(const std::string& value);
  std::string* _internal_mutable_external_user_id();
  public:

  // optional string join_token = 3;
  bool has_join_token() const;
  private:
  bool _internal_has_join_token() const;
  public:
  void clear_join_token();
  const std::string& join_token() const;
  void set_join_token(const std::string& value);
  void set_join_token(std::string&& value);
  void set_join_token(const char* value);
  void set_join_token(const char* value, size_t size);
  std::string* mutable_join_token();
  std::string* release_join_token();
  void set_allocated_join_token(std::string* join_token);
  private:
  const std::string& _internal_join_token() const;
  void _internal_set_join_token(const std::string& value);
  std::string* _internal_mutable_join_token();
  public:

  // @@protoc_insertion_point(class_scope:signal_rtc.MeetingSessionCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attendee_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr join_token_;
  friend struct ::TableStruct_video_5fcontrol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignalFrame

// required uint64 timestamp_ms = 1;
inline bool SignalFrame::_internal_has_timestamp_ms() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool SignalFrame::has_timestamp_ms() const {
  return _internal_has_timestamp_ms();
}
inline void SignalFrame::clear_timestamp_ms() {
  timestamp_ms_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignalFrame::_internal_timestamp_ms() const {
  return timestamp_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignalFrame::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void SignalFrame::_internal_set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x04000000u;
  timestamp_ms_ = value;
}
inline void SignalFrame::set_timestamp_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SignalFrame.timestamp_ms)
}

// required .signal_rtc.SignalFrame.Type type = 2;
inline bool SignalFrame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool SignalFrame::has_type() const {
  return _internal_has_type();
}
inline void SignalFrame::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::signal_rtc::SignalFrame_Type SignalFrame::_internal_type() const {
  return static_cast< ::signal_rtc::SignalFrame_Type >(type_);
}
inline ::signal_rtc::SignalFrame_Type SignalFrame::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.type)
  return _internal_type();
}
inline void SignalFrame::_internal_set_type(::signal_rtc::SignalFrame_Type value) {
  assert(::signal_rtc::SignalFrame_Type_IsValid(value));
  _has_bits_[0] |= 0x08000000u;
  type_ = value;
}
inline void SignalFrame::set_type(::signal_rtc::SignalFrame_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SignalFrame.type)
}

// optional .signal_rtc.ErrorFrame error = 3;
inline bool SignalFrame::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool SignalFrame::has_error() const {
  return _internal_has_error();
}
inline void SignalFrame::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::signal_rtc::ErrorFrame& SignalFrame::_internal_error() const {
  const ::signal_rtc::ErrorFrame* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::ErrorFrame&>(
      ::signal_rtc::_ErrorFrame_default_instance_);
}
inline const ::signal_rtc::ErrorFrame& SignalFrame::error() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.error)
  return _internal_error();
}
inline void SignalFrame::unsafe_arena_set_allocated_error(
    ::signal_rtc::ErrorFrame* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.error)
}
inline ::signal_rtc::ErrorFrame* SignalFrame::release_error() {
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::ErrorFrame* temp = error_;
  error_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::ErrorFrame* SignalFrame::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.error)
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::ErrorFrame* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::signal_rtc::ErrorFrame* SignalFrame::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::ErrorFrame>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::signal_rtc::ErrorFrame* SignalFrame::mutable_error() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.error)
  return _internal_mutable_error();
}
inline void SignalFrame::set_allocated_error(::signal_rtc::ErrorFrame* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.error)
}

// optional .signal_rtc.JoinFrame join = 4;
inline bool SignalFrame::_internal_has_join() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || join_ != nullptr);
  return value;
}
inline bool SignalFrame::has_join() const {
  return _internal_has_join();
}
inline void SignalFrame::clear_join() {
  if (join_ != nullptr) join_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::signal_rtc::JoinFrame& SignalFrame::_internal_join() const {
  const ::signal_rtc::JoinFrame* p = join_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::JoinFrame&>(
      ::signal_rtc::_JoinFrame_default_instance_);
}
inline const ::signal_rtc::JoinFrame& SignalFrame::join() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.join)
  return _internal_join();
}
inline void SignalFrame::unsafe_arena_set_allocated_join(
    ::signal_rtc::JoinFrame* join) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(join_);
  }
  join_ = join;
  if (join) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.join)
}
inline ::signal_rtc::JoinFrame* SignalFrame::release_join() {
  _has_bits_[0] &= ~0x00000002u;
  ::signal_rtc::JoinFrame* temp = join_;
  join_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::JoinFrame* SignalFrame::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.join)
  _has_bits_[0] &= ~0x00000002u;
  ::signal_rtc::JoinFrame* temp = join_;
  join_ = nullptr;
  return temp;
}
inline ::signal_rtc::JoinFrame* SignalFrame::_internal_mutable_join() {
  _has_bits_[0] |= 0x00000002u;
  if (join_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::JoinFrame>(GetArena());
    join_ = p;
  }
  return join_;
}
inline ::signal_rtc::JoinFrame* SignalFrame::mutable_join() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.join)
  return _internal_mutable_join();
}
inline void SignalFrame::set_allocated_join(::signal_rtc::JoinFrame* join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete join_;
  }
  if (join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(join);
    if (message_arena != submessage_arena) {
      join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  join_ = join;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.join)
}

// optional .signal_rtc.JoinAckFrame joinack = 5;
inline bool SignalFrame::_internal_has_joinack() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || joinack_ != nullptr);
  return value;
}
inline bool SignalFrame::has_joinack() const {
  return _internal_has_joinack();
}
inline void SignalFrame::clear_joinack() {
  if (joinack_ != nullptr) joinack_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::signal_rtc::JoinAckFrame& SignalFrame::_internal_joinack() const {
  const ::signal_rtc::JoinAckFrame* p = joinack_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::JoinAckFrame&>(
      ::signal_rtc::_JoinAckFrame_default_instance_);
}
inline const ::signal_rtc::JoinAckFrame& SignalFrame::joinack() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.joinack)
  return _internal_joinack();
}
inline void SignalFrame::unsafe_arena_set_allocated_joinack(
    ::signal_rtc::JoinAckFrame* joinack) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joinack_);
  }
  joinack_ = joinack;
  if (joinack) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.joinack)
}
inline ::signal_rtc::JoinAckFrame* SignalFrame::release_joinack() {
  _has_bits_[0] &= ~0x00000004u;
  ::signal_rtc::JoinAckFrame* temp = joinack_;
  joinack_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::JoinAckFrame* SignalFrame::unsafe_arena_release_joinack() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.joinack)
  _has_bits_[0] &= ~0x00000004u;
  ::signal_rtc::JoinAckFrame* temp = joinack_;
  joinack_ = nullptr;
  return temp;
}
inline ::signal_rtc::JoinAckFrame* SignalFrame::_internal_mutable_joinack() {
  _has_bits_[0] |= 0x00000004u;
  if (joinack_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::JoinAckFrame>(GetArena());
    joinack_ = p;
  }
  return joinack_;
}
inline ::signal_rtc::JoinAckFrame* SignalFrame::mutable_joinack() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.joinack)
  return _internal_mutable_joinack();
}
inline void SignalFrame::set_allocated_joinack(::signal_rtc::JoinAckFrame* joinack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joinack_;
  }
  if (joinack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joinack);
    if (message_arena != submessage_arena) {
      joinack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joinack, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  joinack_ = joinack;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.joinack)
}

// optional .signal_rtc.SubscribeFrame sub = 6;
inline bool SignalFrame::_internal_has_sub() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || sub_ != nullptr);
  return value;
}
inline bool SignalFrame::has_sub() const {
  return _internal_has_sub();
}
inline void SignalFrame::clear_sub() {
  if (sub_ != nullptr) sub_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::signal_rtc::SubscribeFrame& SignalFrame::_internal_sub() const {
  const ::signal_rtc::SubscribeFrame* p = sub_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::SubscribeFrame&>(
      ::signal_rtc::_SubscribeFrame_default_instance_);
}
inline const ::signal_rtc::SubscribeFrame& SignalFrame::sub() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.sub)
  return _internal_sub();
}
inline void SignalFrame::unsafe_arena_set_allocated_sub(
    ::signal_rtc::SubscribeFrame* sub) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_);
  }
  sub_ = sub;
  if (sub) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.sub)
}
inline ::signal_rtc::SubscribeFrame* SignalFrame::release_sub() {
  _has_bits_[0] &= ~0x00000008u;
  ::signal_rtc::SubscribeFrame* temp = sub_;
  sub_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::SubscribeFrame* SignalFrame::unsafe_arena_release_sub() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.sub)
  _has_bits_[0] &= ~0x00000008u;
  ::signal_rtc::SubscribeFrame* temp = sub_;
  sub_ = nullptr;
  return temp;
}
inline ::signal_rtc::SubscribeFrame* SignalFrame::_internal_mutable_sub() {
  _has_bits_[0] |= 0x00000008u;
  if (sub_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::SubscribeFrame>(GetArena());
    sub_ = p;
  }
  return sub_;
}
inline ::signal_rtc::SubscribeFrame* SignalFrame::mutable_sub() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.sub)
  return _internal_mutable_sub();
}
inline void SignalFrame::set_allocated_sub(::signal_rtc::SubscribeFrame* sub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sub_;
  }
  if (sub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sub);
    if (message_arena != submessage_arena) {
      sub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sub_ = sub;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.sub)
}

// optional .signal_rtc.SubscribeAckFrame suback = 7;
inline bool SignalFrame::_internal_has_suback() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || suback_ != nullptr);
  return value;
}
inline bool SignalFrame::has_suback() const {
  return _internal_has_suback();
}
inline void SignalFrame::clear_suback() {
  if (suback_ != nullptr) suback_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::signal_rtc::SubscribeAckFrame& SignalFrame::_internal_suback() const {
  const ::signal_rtc::SubscribeAckFrame* p = suback_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::SubscribeAckFrame&>(
      ::signal_rtc::_SubscribeAckFrame_default_instance_);
}
inline const ::signal_rtc::SubscribeAckFrame& SignalFrame::suback() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.suback)
  return _internal_suback();
}
inline void SignalFrame::unsafe_arena_set_allocated_suback(
    ::signal_rtc::SubscribeAckFrame* suback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suback_);
  }
  suback_ = suback;
  if (suback) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.suback)
}
inline ::signal_rtc::SubscribeAckFrame* SignalFrame::release_suback() {
  _has_bits_[0] &= ~0x00000010u;
  ::signal_rtc::SubscribeAckFrame* temp = suback_;
  suback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::SubscribeAckFrame* SignalFrame::unsafe_arena_release_suback() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.suback)
  _has_bits_[0] &= ~0x00000010u;
  ::signal_rtc::SubscribeAckFrame* temp = suback_;
  suback_ = nullptr;
  return temp;
}
inline ::signal_rtc::SubscribeAckFrame* SignalFrame::_internal_mutable_suback() {
  _has_bits_[0] |= 0x00000010u;
  if (suback_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::SubscribeAckFrame>(GetArena());
    suback_ = p;
  }
  return suback_;
}
inline ::signal_rtc::SubscribeAckFrame* SignalFrame::mutable_suback() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.suback)
  return _internal_mutable_suback();
}
inline void SignalFrame::set_allocated_suback(::signal_rtc::SubscribeAckFrame* suback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete suback_;
  }
  if (suback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(suback);
    if (message_arena != submessage_arena) {
      suback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suback, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  suback_ = suback;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.suback)
}

// optional .signal_rtc.IndexFrame index = 8;
inline bool SignalFrame::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || index_ != nullptr);
  return value;
}
inline bool SignalFrame::has_index() const {
  return _internal_has_index();
}
inline void SignalFrame::clear_index() {
  if (index_ != nullptr) index_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::signal_rtc::IndexFrame& SignalFrame::_internal_index() const {
  const ::signal_rtc::IndexFrame* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::IndexFrame&>(
      ::signal_rtc::_IndexFrame_default_instance_);
}
inline const ::signal_rtc::IndexFrame& SignalFrame::index() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.index)
  return _internal_index();
}
inline void SignalFrame::unsafe_arena_set_allocated_index(
    ::signal_rtc::IndexFrame* index) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.index)
}
inline ::signal_rtc::IndexFrame* SignalFrame::release_index() {
  _has_bits_[0] &= ~0x00000020u;
  ::signal_rtc::IndexFrame* temp = index_;
  index_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::IndexFrame* SignalFrame::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.index)
  _has_bits_[0] &= ~0x00000020u;
  ::signal_rtc::IndexFrame* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::signal_rtc::IndexFrame* SignalFrame::_internal_mutable_index() {
  _has_bits_[0] |= 0x00000020u;
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::IndexFrame>(GetArena());
    index_ = p;
  }
  return index_;
}
inline ::signal_rtc::IndexFrame* SignalFrame::mutable_index() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.index)
  return _internal_mutable_index();
}
inline void SignalFrame::set_allocated_index(::signal_rtc::IndexFrame* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.index)
}

// optional .signal_rtc.PauseResumeFrame pause = 10;
inline bool SignalFrame::_internal_has_pause() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || pause_ != nullptr);
  return value;
}
inline bool SignalFrame::has_pause() const {
  return _internal_has_pause();
}
inline void SignalFrame::clear_pause() {
  if (pause_ != nullptr) pause_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::signal_rtc::PauseResumeFrame& SignalFrame::_internal_pause() const {
  const ::signal_rtc::PauseResumeFrame* p = pause_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::PauseResumeFrame&>(
      ::signal_rtc::_PauseResumeFrame_default_instance_);
}
inline const ::signal_rtc::PauseResumeFrame& SignalFrame::pause() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.pause)
  return _internal_pause();
}
inline void SignalFrame::unsafe_arena_set_allocated_pause(
    ::signal_rtc::PauseResumeFrame* pause) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_);
  }
  pause_ = pause;
  if (pause) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.pause)
}
inline ::signal_rtc::PauseResumeFrame* SignalFrame::release_pause() {
  _has_bits_[0] &= ~0x00000040u;
  ::signal_rtc::PauseResumeFrame* temp = pause_;
  pause_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::PauseResumeFrame* SignalFrame::unsafe_arena_release_pause() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.pause)
  _has_bits_[0] &= ~0x00000040u;
  ::signal_rtc::PauseResumeFrame* temp = pause_;
  pause_ = nullptr;
  return temp;
}
inline ::signal_rtc::PauseResumeFrame* SignalFrame::_internal_mutable_pause() {
  _has_bits_[0] |= 0x00000040u;
  if (pause_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::PauseResumeFrame>(GetArena());
    pause_ = p;
  }
  return pause_;
}
inline ::signal_rtc::PauseResumeFrame* SignalFrame::mutable_pause() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.pause)
  return _internal_mutable_pause();
}
inline void SignalFrame::set_allocated_pause(::signal_rtc::PauseResumeFrame* pause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pause_;
  }
  if (pause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pause);
    if (message_arena != submessage_arena) {
      pause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pause, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  pause_ = pause;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.pause)
}

// optional .signal_rtc.LeaveFrame leave = 11;
inline bool SignalFrame::_internal_has_leave() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || leave_ != nullptr);
  return value;
}
inline bool SignalFrame::has_leave() const {
  return _internal_has_leave();
}
inline void SignalFrame::clear_leave() {
  if (leave_ != nullptr) leave_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::signal_rtc::LeaveFrame& SignalFrame::_internal_leave() const {
  const ::signal_rtc::LeaveFrame* p = leave_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::LeaveFrame&>(
      ::signal_rtc::_LeaveFrame_default_instance_);
}
inline const ::signal_rtc::LeaveFrame& SignalFrame::leave() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.leave)
  return _internal_leave();
}
inline void SignalFrame::unsafe_arena_set_allocated_leave(
    ::signal_rtc::LeaveFrame* leave) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leave_);
  }
  leave_ = leave;
  if (leave) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.leave)
}
inline ::signal_rtc::LeaveFrame* SignalFrame::release_leave() {
  _has_bits_[0] &= ~0x00000080u;
  ::signal_rtc::LeaveFrame* temp = leave_;
  leave_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::LeaveFrame* SignalFrame::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.leave)
  _has_bits_[0] &= ~0x00000080u;
  ::signal_rtc::LeaveFrame* temp = leave_;
  leave_ = nullptr;
  return temp;
}
inline ::signal_rtc::LeaveFrame* SignalFrame::_internal_mutable_leave() {
  _has_bits_[0] |= 0x00000080u;
  if (leave_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::LeaveFrame>(GetArena());
    leave_ = p;
  }
  return leave_;
}
inline ::signal_rtc::LeaveFrame* SignalFrame::mutable_leave() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.leave)
  return _internal_mutable_leave();
}
inline void SignalFrame::set_allocated_leave(::signal_rtc::LeaveFrame* leave) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete leave_;
  }
  if (leave) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leave);
    if (message_arena != submessage_arena) {
      leave = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leave, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  leave_ = leave;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.leave)
}

// optional .signal_rtc.LeaveAckFrame leave_ack = 12;
inline bool SignalFrame::_internal_has_leave_ack() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || leave_ack_ != nullptr);
  return value;
}
inline bool SignalFrame::has_leave_ack() const {
  return _internal_has_leave_ack();
}
inline void SignalFrame::clear_leave_ack() {
  if (leave_ack_ != nullptr) leave_ack_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::signal_rtc::LeaveAckFrame& SignalFrame::_internal_leave_ack() const {
  const ::signal_rtc::LeaveAckFrame* p = leave_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::LeaveAckFrame&>(
      ::signal_rtc::_LeaveAckFrame_default_instance_);
}
inline const ::signal_rtc::LeaveAckFrame& SignalFrame::leave_ack() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.leave_ack)
  return _internal_leave_ack();
}
inline void SignalFrame::unsafe_arena_set_allocated_leave_ack(
    ::signal_rtc::LeaveAckFrame* leave_ack) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leave_ack_);
  }
  leave_ack_ = leave_ack;
  if (leave_ack) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.leave_ack)
}
inline ::signal_rtc::LeaveAckFrame* SignalFrame::release_leave_ack() {
  _has_bits_[0] &= ~0x00000100u;
  ::signal_rtc::LeaveAckFrame* temp = leave_ack_;
  leave_ack_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::LeaveAckFrame* SignalFrame::unsafe_arena_release_leave_ack() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.leave_ack)
  _has_bits_[0] &= ~0x00000100u;
  ::signal_rtc::LeaveAckFrame* temp = leave_ack_;
  leave_ack_ = nullptr;
  return temp;
}
inline ::signal_rtc::LeaveAckFrame* SignalFrame::_internal_mutable_leave_ack() {
  _has_bits_[0] |= 0x00000100u;
  if (leave_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::LeaveAckFrame>(GetArena());
    leave_ack_ = p;
  }
  return leave_ack_;
}
inline ::signal_rtc::LeaveAckFrame* SignalFrame::mutable_leave_ack() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.leave_ack)
  return _internal_mutable_leave_ack();
}
inline void SignalFrame::set_allocated_leave_ack(::signal_rtc::LeaveAckFrame* leave_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete leave_ack_;
  }
  if (leave_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leave_ack);
    if (message_arena != submessage_arena) {
      leave_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leave_ack, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  leave_ack_ = leave_ack;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.leave_ack)
}

// optional .signal_rtc.BitrateFrame bitrates = 14;
inline bool SignalFrame::_internal_has_bitrates() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || bitrates_ != nullptr);
  return value;
}
inline bool SignalFrame::has_bitrates() const {
  return _internal_has_bitrates();
}
inline void SignalFrame::clear_bitrates() {
  if (bitrates_ != nullptr) bitrates_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::signal_rtc::BitrateFrame& SignalFrame::_internal_bitrates() const {
  const ::signal_rtc::BitrateFrame* p = bitrates_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::BitrateFrame&>(
      ::signal_rtc::_BitrateFrame_default_instance_);
}
inline const ::signal_rtc::BitrateFrame& SignalFrame::bitrates() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.bitrates)
  return _internal_bitrates();
}
inline void SignalFrame::unsafe_arena_set_allocated_bitrates(
    ::signal_rtc::BitrateFrame* bitrates) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bitrates_);
  }
  bitrates_ = bitrates;
  if (bitrates) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.bitrates)
}
inline ::signal_rtc::BitrateFrame* SignalFrame::release_bitrates() {
  _has_bits_[0] &= ~0x00000200u;
  ::signal_rtc::BitrateFrame* temp = bitrates_;
  bitrates_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::BitrateFrame* SignalFrame::unsafe_arena_release_bitrates() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.bitrates)
  _has_bits_[0] &= ~0x00000200u;
  ::signal_rtc::BitrateFrame* temp = bitrates_;
  bitrates_ = nullptr;
  return temp;
}
inline ::signal_rtc::BitrateFrame* SignalFrame::_internal_mutable_bitrates() {
  _has_bits_[0] |= 0x00000200u;
  if (bitrates_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::BitrateFrame>(GetArena());
    bitrates_ = p;
  }
  return bitrates_;
}
inline ::signal_rtc::BitrateFrame* SignalFrame::mutable_bitrates() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.bitrates)
  return _internal_mutable_bitrates();
}
inline void SignalFrame::set_allocated_bitrates(::signal_rtc::BitrateFrame* bitrates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bitrates_;
  }
  if (bitrates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bitrates);
    if (message_arena != submessage_arena) {
      bitrates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bitrates, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  bitrates_ = bitrates;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.bitrates)
}

// optional .signal_rtc.AudioControlFrame audio_control = 17;
inline bool SignalFrame::_internal_has_audio_control() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || audio_control_ != nullptr);
  return value;
}
inline bool SignalFrame::has_audio_control() const {
  return _internal_has_audio_control();
}
inline void SignalFrame::clear_audio_control() {
  if (audio_control_ != nullptr) audio_control_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::signal_rtc::AudioControlFrame& SignalFrame::_internal_audio_control() const {
  const ::signal_rtc::AudioControlFrame* p = audio_control_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::AudioControlFrame&>(
      ::signal_rtc::_AudioControlFrame_default_instance_);
}
inline const ::signal_rtc::AudioControlFrame& SignalFrame::audio_control() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.audio_control)
  return _internal_audio_control();
}
inline void SignalFrame::unsafe_arena_set_allocated_audio_control(
    ::signal_rtc::AudioControlFrame* audio_control) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_control_);
  }
  audio_control_ = audio_control;
  if (audio_control) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.audio_control)
}
inline ::signal_rtc::AudioControlFrame* SignalFrame::release_audio_control() {
  _has_bits_[0] &= ~0x00000400u;
  ::signal_rtc::AudioControlFrame* temp = audio_control_;
  audio_control_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::AudioControlFrame* SignalFrame::unsafe_arena_release_audio_control() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.audio_control)
  _has_bits_[0] &= ~0x00000400u;
  ::signal_rtc::AudioControlFrame* temp = audio_control_;
  audio_control_ = nullptr;
  return temp;
}
inline ::signal_rtc::AudioControlFrame* SignalFrame::_internal_mutable_audio_control() {
  _has_bits_[0] |= 0x00000400u;
  if (audio_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::AudioControlFrame>(GetArena());
    audio_control_ = p;
  }
  return audio_control_;
}
inline ::signal_rtc::AudioControlFrame* SignalFrame::mutable_audio_control() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.audio_control)
  return _internal_mutable_audio_control();
}
inline void SignalFrame::set_allocated_audio_control(::signal_rtc::AudioControlFrame* audio_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_control_;
  }
  if (audio_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_control);
    if (message_arena != submessage_arena) {
      audio_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_control, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  audio_control_ = audio_control;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.audio_control)
}

// optional .signal_rtc.AudioMetadataFrame audio_metadata = 18;
inline bool SignalFrame::_internal_has_audio_metadata() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || audio_metadata_ != nullptr);
  return value;
}
inline bool SignalFrame::has_audio_metadata() const {
  return _internal_has_audio_metadata();
}
inline void SignalFrame::clear_audio_metadata() {
  if (audio_metadata_ != nullptr) audio_metadata_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::signal_rtc::AudioMetadataFrame& SignalFrame::_internal_audio_metadata() const {
  const ::signal_rtc::AudioMetadataFrame* p = audio_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::AudioMetadataFrame&>(
      ::signal_rtc::_AudioMetadataFrame_default_instance_);
}
inline const ::signal_rtc::AudioMetadataFrame& SignalFrame::audio_metadata() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.audio_metadata)
  return _internal_audio_metadata();
}
inline void SignalFrame::unsafe_arena_set_allocated_audio_metadata(
    ::signal_rtc::AudioMetadataFrame* audio_metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_metadata_);
  }
  audio_metadata_ = audio_metadata;
  if (audio_metadata) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.audio_metadata)
}
inline ::signal_rtc::AudioMetadataFrame* SignalFrame::release_audio_metadata() {
  _has_bits_[0] &= ~0x00000800u;
  ::signal_rtc::AudioMetadataFrame* temp = audio_metadata_;
  audio_metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::AudioMetadataFrame* SignalFrame::unsafe_arena_release_audio_metadata() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.audio_metadata)
  _has_bits_[0] &= ~0x00000800u;
  ::signal_rtc::AudioMetadataFrame* temp = audio_metadata_;
  audio_metadata_ = nullptr;
  return temp;
}
inline ::signal_rtc::AudioMetadataFrame* SignalFrame::_internal_mutable_audio_metadata() {
  _has_bits_[0] |= 0x00000800u;
  if (audio_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::AudioMetadataFrame>(GetArena());
    audio_metadata_ = p;
  }
  return audio_metadata_;
}
inline ::signal_rtc::AudioMetadataFrame* SignalFrame::mutable_audio_metadata() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.audio_metadata)
  return _internal_mutable_audio_metadata();
}
inline void SignalFrame::set_allocated_audio_metadata(::signal_rtc::AudioMetadataFrame* audio_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_metadata_;
  }
  if (audio_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_metadata);
    if (message_arena != submessage_arena) {
      audio_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  audio_metadata_ = audio_metadata;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.audio_metadata)
}

// optional .signal_rtc.AudioStreamIdInfoFrame audio_stream_id_info = 19;
inline bool SignalFrame::_internal_has_audio_stream_id_info() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || audio_stream_id_info_ != nullptr);
  return value;
}
inline bool SignalFrame::has_audio_stream_id_info() const {
  return _internal_has_audio_stream_id_info();
}
inline void SignalFrame::clear_audio_stream_id_info() {
  if (audio_stream_id_info_ != nullptr) audio_stream_id_info_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::signal_rtc::AudioStreamIdInfoFrame& SignalFrame::_internal_audio_stream_id_info() const {
  const ::signal_rtc::AudioStreamIdInfoFrame* p = audio_stream_id_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::AudioStreamIdInfoFrame&>(
      ::signal_rtc::_AudioStreamIdInfoFrame_default_instance_);
}
inline const ::signal_rtc::AudioStreamIdInfoFrame& SignalFrame::audio_stream_id_info() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.audio_stream_id_info)
  return _internal_audio_stream_id_info();
}
inline void SignalFrame::unsafe_arena_set_allocated_audio_stream_id_info(
    ::signal_rtc::AudioStreamIdInfoFrame* audio_stream_id_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_stream_id_info_);
  }
  audio_stream_id_info_ = audio_stream_id_info;
  if (audio_stream_id_info) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.audio_stream_id_info)
}
inline ::signal_rtc::AudioStreamIdInfoFrame* SignalFrame::release_audio_stream_id_info() {
  _has_bits_[0] &= ~0x00001000u;
  ::signal_rtc::AudioStreamIdInfoFrame* temp = audio_stream_id_info_;
  audio_stream_id_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::AudioStreamIdInfoFrame* SignalFrame::unsafe_arena_release_audio_stream_id_info() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.audio_stream_id_info)
  _has_bits_[0] &= ~0x00001000u;
  ::signal_rtc::AudioStreamIdInfoFrame* temp = audio_stream_id_info_;
  audio_stream_id_info_ = nullptr;
  return temp;
}
inline ::signal_rtc::AudioStreamIdInfoFrame* SignalFrame::_internal_mutable_audio_stream_id_info() {
  _has_bits_[0] |= 0x00001000u;
  if (audio_stream_id_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::AudioStreamIdInfoFrame>(GetArena());
    audio_stream_id_info_ = p;
  }
  return audio_stream_id_info_;
}
inline ::signal_rtc::AudioStreamIdInfoFrame* SignalFrame::mutable_audio_stream_id_info() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.audio_stream_id_info)
  return _internal_mutable_audio_stream_id_info();
}
inline void SignalFrame::set_allocated_audio_stream_id_info(::signal_rtc::AudioStreamIdInfoFrame* audio_stream_id_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_stream_id_info_;
  }
  if (audio_stream_id_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_stream_id_info);
    if (message_arena != submessage_arena) {
      audio_stream_id_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_stream_id_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  audio_stream_id_info_ = audio_stream_id_info;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.audio_stream_id_info)
}

// optional .signal_rtc.PingPongFrame ping_pong = 20;
inline bool SignalFrame::_internal_has_ping_pong() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || ping_pong_ != nullptr);
  return value;
}
inline bool SignalFrame::has_ping_pong() const {
  return _internal_has_ping_pong();
}
inline void SignalFrame::clear_ping_pong() {
  if (ping_pong_ != nullptr) ping_pong_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::signal_rtc::PingPongFrame& SignalFrame::_internal_ping_pong() const {
  const ::signal_rtc::PingPongFrame* p = ping_pong_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::PingPongFrame&>(
      ::signal_rtc::_PingPongFrame_default_instance_);
}
inline const ::signal_rtc::PingPongFrame& SignalFrame::ping_pong() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.ping_pong)
  return _internal_ping_pong();
}
inline void SignalFrame::unsafe_arena_set_allocated_ping_pong(
    ::signal_rtc::PingPongFrame* ping_pong) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_pong_);
  }
  ping_pong_ = ping_pong;
  if (ping_pong) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.ping_pong)
}
inline ::signal_rtc::PingPongFrame* SignalFrame::release_ping_pong() {
  _has_bits_[0] &= ~0x00002000u;
  ::signal_rtc::PingPongFrame* temp = ping_pong_;
  ping_pong_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::PingPongFrame* SignalFrame::unsafe_arena_release_ping_pong() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.ping_pong)
  _has_bits_[0] &= ~0x00002000u;
  ::signal_rtc::PingPongFrame* temp = ping_pong_;
  ping_pong_ = nullptr;
  return temp;
}
inline ::signal_rtc::PingPongFrame* SignalFrame::_internal_mutable_ping_pong() {
  _has_bits_[0] |= 0x00002000u;
  if (ping_pong_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::PingPongFrame>(GetArena());
    ping_pong_ = p;
  }
  return ping_pong_;
}
inline ::signal_rtc::PingPongFrame* SignalFrame::mutable_ping_pong() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.ping_pong)
  return _internal_mutable_ping_pong();
}
inline void SignalFrame::set_allocated_ping_pong(::signal_rtc::PingPongFrame* ping_pong) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ping_pong_;
  }
  if (ping_pong) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ping_pong);
    if (message_arena != submessage_arena) {
      ping_pong = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping_pong, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  ping_pong_ = ping_pong;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.ping_pong)
}

// optional .signal_rtc.AudioStatusFrame audio_status = 21;
inline bool SignalFrame::_internal_has_audio_status() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || audio_status_ != nullptr);
  return value;
}
inline bool SignalFrame::has_audio_status() const {
  return _internal_has_audio_status();
}
inline void SignalFrame::clear_audio_status() {
  if (audio_status_ != nullptr) audio_status_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::signal_rtc::AudioStatusFrame& SignalFrame::_internal_audio_status() const {
  const ::signal_rtc::AudioStatusFrame* p = audio_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::AudioStatusFrame&>(
      ::signal_rtc::_AudioStatusFrame_default_instance_);
}
inline const ::signal_rtc::AudioStatusFrame& SignalFrame::audio_status() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.audio_status)
  return _internal_audio_status();
}
inline void SignalFrame::unsafe_arena_set_allocated_audio_status(
    ::signal_rtc::AudioStatusFrame* audio_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_status_);
  }
  audio_status_ = audio_status;
  if (audio_status) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.audio_status)
}
inline ::signal_rtc::AudioStatusFrame* SignalFrame::release_audio_status() {
  _has_bits_[0] &= ~0x00004000u;
  ::signal_rtc::AudioStatusFrame* temp = audio_status_;
  audio_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::AudioStatusFrame* SignalFrame::unsafe_arena_release_audio_status() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.audio_status)
  _has_bits_[0] &= ~0x00004000u;
  ::signal_rtc::AudioStatusFrame* temp = audio_status_;
  audio_status_ = nullptr;
  return temp;
}
inline ::signal_rtc::AudioStatusFrame* SignalFrame::_internal_mutable_audio_status() {
  _has_bits_[0] |= 0x00004000u;
  if (audio_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::AudioStatusFrame>(GetArena());
    audio_status_ = p;
  }
  return audio_status_;
}
inline ::signal_rtc::AudioStatusFrame* SignalFrame::mutable_audio_status() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.audio_status)
  return _internal_mutable_audio_status();
}
inline void SignalFrame::set_allocated_audio_status(::signal_rtc::AudioStatusFrame* audio_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_status_;
  }
  if (audio_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_status);
    if (message_arena != submessage_arena) {
      audio_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  audio_status_ = audio_status;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.audio_status)
}

// optional .signal_rtc.ClientMetricFrame client_metric = 22;
inline bool SignalFrame::_internal_has_client_metric() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || client_metric_ != nullptr);
  return value;
}
inline bool SignalFrame::has_client_metric() const {
  return _internal_has_client_metric();
}
inline void SignalFrame::clear_client_metric() {
  if (client_metric_ != nullptr) client_metric_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::signal_rtc::ClientMetricFrame& SignalFrame::_internal_client_metric() const {
  const ::signal_rtc::ClientMetricFrame* p = client_metric_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::ClientMetricFrame&>(
      ::signal_rtc::_ClientMetricFrame_default_instance_);
}
inline const ::signal_rtc::ClientMetricFrame& SignalFrame::client_metric() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.client_metric)
  return _internal_client_metric();
}
inline void SignalFrame::unsafe_arena_set_allocated_client_metric(
    ::signal_rtc::ClientMetricFrame* client_metric) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_metric_);
  }
  client_metric_ = client_metric;
  if (client_metric) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.client_metric)
}
inline ::signal_rtc::ClientMetricFrame* SignalFrame::release_client_metric() {
  _has_bits_[0] &= ~0x00008000u;
  ::signal_rtc::ClientMetricFrame* temp = client_metric_;
  client_metric_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::ClientMetricFrame* SignalFrame::unsafe_arena_release_client_metric() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.client_metric)
  _has_bits_[0] &= ~0x00008000u;
  ::signal_rtc::ClientMetricFrame* temp = client_metric_;
  client_metric_ = nullptr;
  return temp;
}
inline ::signal_rtc::ClientMetricFrame* SignalFrame::_internal_mutable_client_metric() {
  _has_bits_[0] |= 0x00008000u;
  if (client_metric_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::ClientMetricFrame>(GetArena());
    client_metric_ = p;
  }
  return client_metric_;
}
inline ::signal_rtc::ClientMetricFrame* SignalFrame::mutable_client_metric() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.client_metric)
  return _internal_mutable_client_metric();
}
inline void SignalFrame::set_allocated_client_metric(::signal_rtc::ClientMetricFrame* client_metric) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete client_metric_;
  }
  if (client_metric) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(client_metric);
    if (message_arena != submessage_arena) {
      client_metric = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_metric, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  client_metric_ = client_metric;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.client_metric)
}

// optional .signal_rtc.DataMessageFrame data_message = 23;
inline bool SignalFrame::_internal_has_data_message() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || data_message_ != nullptr);
  return value;
}
inline bool SignalFrame::has_data_message() const {
  return _internal_has_data_message();
}
inline void SignalFrame::clear_data_message() {
  if (data_message_ != nullptr) data_message_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::signal_rtc::DataMessageFrame& SignalFrame::_internal_data_message() const {
  const ::signal_rtc::DataMessageFrame* p = data_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::DataMessageFrame&>(
      ::signal_rtc::_DataMessageFrame_default_instance_);
}
inline const ::signal_rtc::DataMessageFrame& SignalFrame::data_message() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.data_message)
  return _internal_data_message();
}
inline void SignalFrame::unsafe_arena_set_allocated_data_message(
    ::signal_rtc::DataMessageFrame* data_message) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_message_);
  }
  data_message_ = data_message;
  if (data_message) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.data_message)
}
inline ::signal_rtc::DataMessageFrame* SignalFrame::release_data_message() {
  _has_bits_[0] &= ~0x00010000u;
  ::signal_rtc::DataMessageFrame* temp = data_message_;
  data_message_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::DataMessageFrame* SignalFrame::unsafe_arena_release_data_message() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.data_message)
  _has_bits_[0] &= ~0x00010000u;
  ::signal_rtc::DataMessageFrame* temp = data_message_;
  data_message_ = nullptr;
  return temp;
}
inline ::signal_rtc::DataMessageFrame* SignalFrame::_internal_mutable_data_message() {
  _has_bits_[0] |= 0x00010000u;
  if (data_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::DataMessageFrame>(GetArena());
    data_message_ = p;
  }
  return data_message_;
}
inline ::signal_rtc::DataMessageFrame* SignalFrame::mutable_data_message() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.data_message)
  return _internal_mutable_data_message();
}
inline void SignalFrame::set_allocated_data_message(::signal_rtc::DataMessageFrame* data_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_message_;
  }
  if (data_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data_message);
    if (message_arena != submessage_arena) {
      data_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  data_message_ = data_message;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.data_message)
}

// optional .signal_rtc.AudioTranscriptFrame audio_transcript = 24;
inline bool SignalFrame::_internal_has_audio_transcript() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || audio_transcript_ != nullptr);
  return value;
}
inline bool SignalFrame::has_audio_transcript() const {
  return _internal_has_audio_transcript();
}
inline void SignalFrame::clear_audio_transcript() {
  if (audio_transcript_ != nullptr) audio_transcript_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::signal_rtc::AudioTranscriptFrame& SignalFrame::_internal_audio_transcript() const {
  const ::signal_rtc::AudioTranscriptFrame* p = audio_transcript_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::AudioTranscriptFrame&>(
      ::signal_rtc::_AudioTranscriptFrame_default_instance_);
}
inline const ::signal_rtc::AudioTranscriptFrame& SignalFrame::audio_transcript() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.audio_transcript)
  return _internal_audio_transcript();
}
inline void SignalFrame::unsafe_arena_set_allocated_audio_transcript(
    ::signal_rtc::AudioTranscriptFrame* audio_transcript) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_transcript_);
  }
  audio_transcript_ = audio_transcript;
  if (audio_transcript) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.audio_transcript)
}
inline ::signal_rtc::AudioTranscriptFrame* SignalFrame::release_audio_transcript() {
  _has_bits_[0] &= ~0x00020000u;
  ::signal_rtc::AudioTranscriptFrame* temp = audio_transcript_;
  audio_transcript_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::AudioTranscriptFrame* SignalFrame::unsafe_arena_release_audio_transcript() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.audio_transcript)
  _has_bits_[0] &= ~0x00020000u;
  ::signal_rtc::AudioTranscriptFrame* temp = audio_transcript_;
  audio_transcript_ = nullptr;
  return temp;
}
inline ::signal_rtc::AudioTranscriptFrame* SignalFrame::_internal_mutable_audio_transcript() {
  _has_bits_[0] |= 0x00020000u;
  if (audio_transcript_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::AudioTranscriptFrame>(GetArena());
    audio_transcript_ = p;
  }
  return audio_transcript_;
}
inline ::signal_rtc::AudioTranscriptFrame* SignalFrame::mutable_audio_transcript() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.audio_transcript)
  return _internal_mutable_audio_transcript();
}
inline void SignalFrame::set_allocated_audio_transcript(::signal_rtc::AudioTranscriptFrame* audio_transcript) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_transcript_;
  }
  if (audio_transcript) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_transcript);
    if (message_arena != submessage_arena) {
      audio_transcript = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_transcript, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  audio_transcript_ = audio_transcript;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.audio_transcript)
}

// optional .signal_rtc.RemoteVideoUpdateFrame remote_video_update = 25;
inline bool SignalFrame::_internal_has_remote_video_update() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || remote_video_update_ != nullptr);
  return value;
}
inline bool SignalFrame::has_remote_video_update() const {
  return _internal_has_remote_video_update();
}
inline void SignalFrame::clear_remote_video_update() {
  if (remote_video_update_ != nullptr) remote_video_update_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::signal_rtc::RemoteVideoUpdateFrame& SignalFrame::_internal_remote_video_update() const {
  const ::signal_rtc::RemoteVideoUpdateFrame* p = remote_video_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::RemoteVideoUpdateFrame&>(
      ::signal_rtc::_RemoteVideoUpdateFrame_default_instance_);
}
inline const ::signal_rtc::RemoteVideoUpdateFrame& SignalFrame::remote_video_update() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.remote_video_update)
  return _internal_remote_video_update();
}
inline void SignalFrame::unsafe_arena_set_allocated_remote_video_update(
    ::signal_rtc::RemoteVideoUpdateFrame* remote_video_update) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(remote_video_update_);
  }
  remote_video_update_ = remote_video_update;
  if (remote_video_update) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.remote_video_update)
}
inline ::signal_rtc::RemoteVideoUpdateFrame* SignalFrame::release_remote_video_update() {
  _has_bits_[0] &= ~0x00040000u;
  ::signal_rtc::RemoteVideoUpdateFrame* temp = remote_video_update_;
  remote_video_update_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::RemoteVideoUpdateFrame* SignalFrame::unsafe_arena_release_remote_video_update() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.remote_video_update)
  _has_bits_[0] &= ~0x00040000u;
  ::signal_rtc::RemoteVideoUpdateFrame* temp = remote_video_update_;
  remote_video_update_ = nullptr;
  return temp;
}
inline ::signal_rtc::RemoteVideoUpdateFrame* SignalFrame::_internal_mutable_remote_video_update() {
  _has_bits_[0] |= 0x00040000u;
  if (remote_video_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::RemoteVideoUpdateFrame>(GetArena());
    remote_video_update_ = p;
  }
  return remote_video_update_;
}
inline ::signal_rtc::RemoteVideoUpdateFrame* SignalFrame::mutable_remote_video_update() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.remote_video_update)
  return _internal_mutable_remote_video_update();
}
inline void SignalFrame::set_allocated_remote_video_update(::signal_rtc::RemoteVideoUpdateFrame* remote_video_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete remote_video_update_;
  }
  if (remote_video_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(remote_video_update);
    if (message_arena != submessage_arena) {
      remote_video_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_video_update, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  remote_video_update_ = remote_video_update;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.remote_video_update)
}

// optional .signal_rtc.PrimaryMeetingJoinFrame primary_meeting_join = 26;
inline bool SignalFrame::_internal_has_primary_meeting_join() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || primary_meeting_join_ != nullptr);
  return value;
}
inline bool SignalFrame::has_primary_meeting_join() const {
  return _internal_has_primary_meeting_join();
}
inline void SignalFrame::clear_primary_meeting_join() {
  if (primary_meeting_join_ != nullptr) primary_meeting_join_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::signal_rtc::PrimaryMeetingJoinFrame& SignalFrame::_internal_primary_meeting_join() const {
  const ::signal_rtc::PrimaryMeetingJoinFrame* p = primary_meeting_join_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::PrimaryMeetingJoinFrame&>(
      ::signal_rtc::_PrimaryMeetingJoinFrame_default_instance_);
}
inline const ::signal_rtc::PrimaryMeetingJoinFrame& SignalFrame::primary_meeting_join() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.primary_meeting_join)
  return _internal_primary_meeting_join();
}
inline void SignalFrame::unsafe_arena_set_allocated_primary_meeting_join(
    ::signal_rtc::PrimaryMeetingJoinFrame* primary_meeting_join) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_meeting_join_);
  }
  primary_meeting_join_ = primary_meeting_join;
  if (primary_meeting_join) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.primary_meeting_join)
}
inline ::signal_rtc::PrimaryMeetingJoinFrame* SignalFrame::release_primary_meeting_join() {
  _has_bits_[0] &= ~0x00080000u;
  ::signal_rtc::PrimaryMeetingJoinFrame* temp = primary_meeting_join_;
  primary_meeting_join_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::PrimaryMeetingJoinFrame* SignalFrame::unsafe_arena_release_primary_meeting_join() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.primary_meeting_join)
  _has_bits_[0] &= ~0x00080000u;
  ::signal_rtc::PrimaryMeetingJoinFrame* temp = primary_meeting_join_;
  primary_meeting_join_ = nullptr;
  return temp;
}
inline ::signal_rtc::PrimaryMeetingJoinFrame* SignalFrame::_internal_mutable_primary_meeting_join() {
  _has_bits_[0] |= 0x00080000u;
  if (primary_meeting_join_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::PrimaryMeetingJoinFrame>(GetArena());
    primary_meeting_join_ = p;
  }
  return primary_meeting_join_;
}
inline ::signal_rtc::PrimaryMeetingJoinFrame* SignalFrame::mutable_primary_meeting_join() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.primary_meeting_join)
  return _internal_mutable_primary_meeting_join();
}
inline void SignalFrame::set_allocated_primary_meeting_join(::signal_rtc::PrimaryMeetingJoinFrame* primary_meeting_join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete primary_meeting_join_;
  }
  if (primary_meeting_join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(primary_meeting_join);
    if (message_arena != submessage_arena) {
      primary_meeting_join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_meeting_join, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  primary_meeting_join_ = primary_meeting_join;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.primary_meeting_join)
}

// optional .signal_rtc.PrimaryMeetingJoinAckFrame primary_meeting_join_ack = 27;
inline bool SignalFrame::_internal_has_primary_meeting_join_ack() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || primary_meeting_join_ack_ != nullptr);
  return value;
}
inline bool SignalFrame::has_primary_meeting_join_ack() const {
  return _internal_has_primary_meeting_join_ack();
}
inline void SignalFrame::clear_primary_meeting_join_ack() {
  if (primary_meeting_join_ack_ != nullptr) primary_meeting_join_ack_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::signal_rtc::PrimaryMeetingJoinAckFrame& SignalFrame::_internal_primary_meeting_join_ack() const {
  const ::signal_rtc::PrimaryMeetingJoinAckFrame* p = primary_meeting_join_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::PrimaryMeetingJoinAckFrame&>(
      ::signal_rtc::_PrimaryMeetingJoinAckFrame_default_instance_);
}
inline const ::signal_rtc::PrimaryMeetingJoinAckFrame& SignalFrame::primary_meeting_join_ack() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.primary_meeting_join_ack)
  return _internal_primary_meeting_join_ack();
}
inline void SignalFrame::unsafe_arena_set_allocated_primary_meeting_join_ack(
    ::signal_rtc::PrimaryMeetingJoinAckFrame* primary_meeting_join_ack) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_meeting_join_ack_);
  }
  primary_meeting_join_ack_ = primary_meeting_join_ack;
  if (primary_meeting_join_ack) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.primary_meeting_join_ack)
}
inline ::signal_rtc::PrimaryMeetingJoinAckFrame* SignalFrame::release_primary_meeting_join_ack() {
  _has_bits_[0] &= ~0x00100000u;
  ::signal_rtc::PrimaryMeetingJoinAckFrame* temp = primary_meeting_join_ack_;
  primary_meeting_join_ack_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::PrimaryMeetingJoinAckFrame* SignalFrame::unsafe_arena_release_primary_meeting_join_ack() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.primary_meeting_join_ack)
  _has_bits_[0] &= ~0x00100000u;
  ::signal_rtc::PrimaryMeetingJoinAckFrame* temp = primary_meeting_join_ack_;
  primary_meeting_join_ack_ = nullptr;
  return temp;
}
inline ::signal_rtc::PrimaryMeetingJoinAckFrame* SignalFrame::_internal_mutable_primary_meeting_join_ack() {
  _has_bits_[0] |= 0x00100000u;
  if (primary_meeting_join_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::PrimaryMeetingJoinAckFrame>(GetArena());
    primary_meeting_join_ack_ = p;
  }
  return primary_meeting_join_ack_;
}
inline ::signal_rtc::PrimaryMeetingJoinAckFrame* SignalFrame::mutable_primary_meeting_join_ack() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.primary_meeting_join_ack)
  return _internal_mutable_primary_meeting_join_ack();
}
inline void SignalFrame::set_allocated_primary_meeting_join_ack(::signal_rtc::PrimaryMeetingJoinAckFrame* primary_meeting_join_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete primary_meeting_join_ack_;
  }
  if (primary_meeting_join_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(primary_meeting_join_ack);
    if (message_arena != submessage_arena) {
      primary_meeting_join_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_meeting_join_ack, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  primary_meeting_join_ack_ = primary_meeting_join_ack;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.primary_meeting_join_ack)
}

// optional .signal_rtc.PrimaryMeetingLeaveFrame primary_meeting_leave = 28;
inline bool SignalFrame::_internal_has_primary_meeting_leave() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || primary_meeting_leave_ != nullptr);
  return value;
}
inline bool SignalFrame::has_primary_meeting_leave() const {
  return _internal_has_primary_meeting_leave();
}
inline void SignalFrame::clear_primary_meeting_leave() {
  if (primary_meeting_leave_ != nullptr) primary_meeting_leave_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::signal_rtc::PrimaryMeetingLeaveFrame& SignalFrame::_internal_primary_meeting_leave() const {
  const ::signal_rtc::PrimaryMeetingLeaveFrame* p = primary_meeting_leave_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::PrimaryMeetingLeaveFrame&>(
      ::signal_rtc::_PrimaryMeetingLeaveFrame_default_instance_);
}
inline const ::signal_rtc::PrimaryMeetingLeaveFrame& SignalFrame::primary_meeting_leave() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.primary_meeting_leave)
  return _internal_primary_meeting_leave();
}
inline void SignalFrame::unsafe_arena_set_allocated_primary_meeting_leave(
    ::signal_rtc::PrimaryMeetingLeaveFrame* primary_meeting_leave) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_meeting_leave_);
  }
  primary_meeting_leave_ = primary_meeting_leave;
  if (primary_meeting_leave) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.primary_meeting_leave)
}
inline ::signal_rtc::PrimaryMeetingLeaveFrame* SignalFrame::release_primary_meeting_leave() {
  _has_bits_[0] &= ~0x00200000u;
  ::signal_rtc::PrimaryMeetingLeaveFrame* temp = primary_meeting_leave_;
  primary_meeting_leave_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::PrimaryMeetingLeaveFrame* SignalFrame::unsafe_arena_release_primary_meeting_leave() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.primary_meeting_leave)
  _has_bits_[0] &= ~0x00200000u;
  ::signal_rtc::PrimaryMeetingLeaveFrame* temp = primary_meeting_leave_;
  primary_meeting_leave_ = nullptr;
  return temp;
}
inline ::signal_rtc::PrimaryMeetingLeaveFrame* SignalFrame::_internal_mutable_primary_meeting_leave() {
  _has_bits_[0] |= 0x00200000u;
  if (primary_meeting_leave_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::PrimaryMeetingLeaveFrame>(GetArena());
    primary_meeting_leave_ = p;
  }
  return primary_meeting_leave_;
}
inline ::signal_rtc::PrimaryMeetingLeaveFrame* SignalFrame::mutable_primary_meeting_leave() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.primary_meeting_leave)
  return _internal_mutable_primary_meeting_leave();
}
inline void SignalFrame::set_allocated_primary_meeting_leave(::signal_rtc::PrimaryMeetingLeaveFrame* primary_meeting_leave) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete primary_meeting_leave_;
  }
  if (primary_meeting_leave) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(primary_meeting_leave);
    if (message_arena != submessage_arena) {
      primary_meeting_leave = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_meeting_leave, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  primary_meeting_leave_ = primary_meeting_leave;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.primary_meeting_leave)
}

// optional .signal_rtc.BridgeJoinFrame bridge_join = 29;
inline bool SignalFrame::_internal_has_bridge_join() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || bridge_join_ != nullptr);
  return value;
}
inline bool SignalFrame::has_bridge_join() const {
  return _internal_has_bridge_join();
}
inline void SignalFrame::clear_bridge_join() {
  if (bridge_join_ != nullptr) bridge_join_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::signal_rtc::BridgeJoinFrame& SignalFrame::_internal_bridge_join() const {
  const ::signal_rtc::BridgeJoinFrame* p = bridge_join_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::BridgeJoinFrame&>(
      ::signal_rtc::_BridgeJoinFrame_default_instance_);
}
inline const ::signal_rtc::BridgeJoinFrame& SignalFrame::bridge_join() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.bridge_join)
  return _internal_bridge_join();
}
inline void SignalFrame::unsafe_arena_set_allocated_bridge_join(
    ::signal_rtc::BridgeJoinFrame* bridge_join) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bridge_join_);
  }
  bridge_join_ = bridge_join;
  if (bridge_join) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.bridge_join)
}
inline ::signal_rtc::BridgeJoinFrame* SignalFrame::release_bridge_join() {
  _has_bits_[0] &= ~0x00400000u;
  ::signal_rtc::BridgeJoinFrame* temp = bridge_join_;
  bridge_join_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::BridgeJoinFrame* SignalFrame::unsafe_arena_release_bridge_join() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.bridge_join)
  _has_bits_[0] &= ~0x00400000u;
  ::signal_rtc::BridgeJoinFrame* temp = bridge_join_;
  bridge_join_ = nullptr;
  return temp;
}
inline ::signal_rtc::BridgeJoinFrame* SignalFrame::_internal_mutable_bridge_join() {
  _has_bits_[0] |= 0x00400000u;
  if (bridge_join_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::BridgeJoinFrame>(GetArena());
    bridge_join_ = p;
  }
  return bridge_join_;
}
inline ::signal_rtc::BridgeJoinFrame* SignalFrame::mutable_bridge_join() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.bridge_join)
  return _internal_mutable_bridge_join();
}
inline void SignalFrame::set_allocated_bridge_join(::signal_rtc::BridgeJoinFrame* bridge_join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bridge_join_;
  }
  if (bridge_join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bridge_join);
    if (message_arena != submessage_arena) {
      bridge_join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bridge_join, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  bridge_join_ = bridge_join;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.bridge_join)
}

// optional .signal_rtc.BridgeJoinAckFrame bridge_join_ack = 30;
inline bool SignalFrame::_internal_has_bridge_join_ack() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || bridge_join_ack_ != nullptr);
  return value;
}
inline bool SignalFrame::has_bridge_join_ack() const {
  return _internal_has_bridge_join_ack();
}
inline void SignalFrame::clear_bridge_join_ack() {
  if (bridge_join_ack_ != nullptr) bridge_join_ack_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::signal_rtc::BridgeJoinAckFrame& SignalFrame::_internal_bridge_join_ack() const {
  const ::signal_rtc::BridgeJoinAckFrame* p = bridge_join_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::BridgeJoinAckFrame&>(
      ::signal_rtc::_BridgeJoinAckFrame_default_instance_);
}
inline const ::signal_rtc::BridgeJoinAckFrame& SignalFrame::bridge_join_ack() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.bridge_join_ack)
  return _internal_bridge_join_ack();
}
inline void SignalFrame::unsafe_arena_set_allocated_bridge_join_ack(
    ::signal_rtc::BridgeJoinAckFrame* bridge_join_ack) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bridge_join_ack_);
  }
  bridge_join_ack_ = bridge_join_ack;
  if (bridge_join_ack) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.bridge_join_ack)
}
inline ::signal_rtc::BridgeJoinAckFrame* SignalFrame::release_bridge_join_ack() {
  _has_bits_[0] &= ~0x00800000u;
  ::signal_rtc::BridgeJoinAckFrame* temp = bridge_join_ack_;
  bridge_join_ack_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::BridgeJoinAckFrame* SignalFrame::unsafe_arena_release_bridge_join_ack() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.bridge_join_ack)
  _has_bits_[0] &= ~0x00800000u;
  ::signal_rtc::BridgeJoinAckFrame* temp = bridge_join_ack_;
  bridge_join_ack_ = nullptr;
  return temp;
}
inline ::signal_rtc::BridgeJoinAckFrame* SignalFrame::_internal_mutable_bridge_join_ack() {
  _has_bits_[0] |= 0x00800000u;
  if (bridge_join_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::BridgeJoinAckFrame>(GetArena());
    bridge_join_ack_ = p;
  }
  return bridge_join_ack_;
}
inline ::signal_rtc::BridgeJoinAckFrame* SignalFrame::mutable_bridge_join_ack() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.bridge_join_ack)
  return _internal_mutable_bridge_join_ack();
}
inline void SignalFrame::set_allocated_bridge_join_ack(::signal_rtc::BridgeJoinAckFrame* bridge_join_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bridge_join_ack_;
  }
  if (bridge_join_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bridge_join_ack);
    if (message_arena != submessage_arena) {
      bridge_join_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bridge_join_ack, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  bridge_join_ack_ = bridge_join_ack;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.bridge_join_ack)
}

// optional .signal_rtc.BridgeReserveFrame bridge_reserve = 31;
inline bool SignalFrame::_internal_has_bridge_reserve() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || bridge_reserve_ != nullptr);
  return value;
}
inline bool SignalFrame::has_bridge_reserve() const {
  return _internal_has_bridge_reserve();
}
inline void SignalFrame::clear_bridge_reserve() {
  if (bridge_reserve_ != nullptr) bridge_reserve_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::signal_rtc::BridgeReserveFrame& SignalFrame::_internal_bridge_reserve() const {
  const ::signal_rtc::BridgeReserveFrame* p = bridge_reserve_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::BridgeReserveFrame&>(
      ::signal_rtc::_BridgeReserveFrame_default_instance_);
}
inline const ::signal_rtc::BridgeReserveFrame& SignalFrame::bridge_reserve() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.bridge_reserve)
  return _internal_bridge_reserve();
}
inline void SignalFrame::unsafe_arena_set_allocated_bridge_reserve(
    ::signal_rtc::BridgeReserveFrame* bridge_reserve) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bridge_reserve_);
  }
  bridge_reserve_ = bridge_reserve;
  if (bridge_reserve) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.bridge_reserve)
}
inline ::signal_rtc::BridgeReserveFrame* SignalFrame::release_bridge_reserve() {
  _has_bits_[0] &= ~0x01000000u;
  ::signal_rtc::BridgeReserveFrame* temp = bridge_reserve_;
  bridge_reserve_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::BridgeReserveFrame* SignalFrame::unsafe_arena_release_bridge_reserve() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.bridge_reserve)
  _has_bits_[0] &= ~0x01000000u;
  ::signal_rtc::BridgeReserveFrame* temp = bridge_reserve_;
  bridge_reserve_ = nullptr;
  return temp;
}
inline ::signal_rtc::BridgeReserveFrame* SignalFrame::_internal_mutable_bridge_reserve() {
  _has_bits_[0] |= 0x01000000u;
  if (bridge_reserve_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::BridgeReserveFrame>(GetArena());
    bridge_reserve_ = p;
  }
  return bridge_reserve_;
}
inline ::signal_rtc::BridgeReserveFrame* SignalFrame::mutable_bridge_reserve() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.bridge_reserve)
  return _internal_mutable_bridge_reserve();
}
inline void SignalFrame::set_allocated_bridge_reserve(::signal_rtc::BridgeReserveFrame* bridge_reserve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bridge_reserve_;
  }
  if (bridge_reserve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bridge_reserve);
    if (message_arena != submessage_arena) {
      bridge_reserve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bridge_reserve, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  bridge_reserve_ = bridge_reserve;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.bridge_reserve)
}

// optional .signal_rtc.BridgeReserveAckFrame bridge_reserve_ack = 32;
inline bool SignalFrame::_internal_has_bridge_reserve_ack() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || bridge_reserve_ack_ != nullptr);
  return value;
}
inline bool SignalFrame::has_bridge_reserve_ack() const {
  return _internal_has_bridge_reserve_ack();
}
inline void SignalFrame::clear_bridge_reserve_ack() {
  if (bridge_reserve_ack_ != nullptr) bridge_reserve_ack_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::signal_rtc::BridgeReserveAckFrame& SignalFrame::_internal_bridge_reserve_ack() const {
  const ::signal_rtc::BridgeReserveAckFrame* p = bridge_reserve_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::BridgeReserveAckFrame&>(
      ::signal_rtc::_BridgeReserveAckFrame_default_instance_);
}
inline const ::signal_rtc::BridgeReserveAckFrame& SignalFrame::bridge_reserve_ack() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SignalFrame.bridge_reserve_ack)
  return _internal_bridge_reserve_ack();
}
inline void SignalFrame::unsafe_arena_set_allocated_bridge_reserve_ack(
    ::signal_rtc::BridgeReserveAckFrame* bridge_reserve_ack) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bridge_reserve_ack_);
  }
  bridge_reserve_ack_ = bridge_reserve_ack;
  if (bridge_reserve_ack) {
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.SignalFrame.bridge_reserve_ack)
}
inline ::signal_rtc::BridgeReserveAckFrame* SignalFrame::release_bridge_reserve_ack() {
  _has_bits_[0] &= ~0x02000000u;
  ::signal_rtc::BridgeReserveAckFrame* temp = bridge_reserve_ack_;
  bridge_reserve_ack_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::BridgeReserveAckFrame* SignalFrame::unsafe_arena_release_bridge_reserve_ack() {
  // @@protoc_insertion_point(field_release:signal_rtc.SignalFrame.bridge_reserve_ack)
  _has_bits_[0] &= ~0x02000000u;
  ::signal_rtc::BridgeReserveAckFrame* temp = bridge_reserve_ack_;
  bridge_reserve_ack_ = nullptr;
  return temp;
}
inline ::signal_rtc::BridgeReserveAckFrame* SignalFrame::_internal_mutable_bridge_reserve_ack() {
  _has_bits_[0] |= 0x02000000u;
  if (bridge_reserve_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::BridgeReserveAckFrame>(GetArena());
    bridge_reserve_ack_ = p;
  }
  return bridge_reserve_ack_;
}
inline ::signal_rtc::BridgeReserveAckFrame* SignalFrame::mutable_bridge_reserve_ack() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SignalFrame.bridge_reserve_ack)
  return _internal_mutable_bridge_reserve_ack();
}
inline void SignalFrame::set_allocated_bridge_reserve_ack(::signal_rtc::BridgeReserveAckFrame* bridge_reserve_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bridge_reserve_ack_;
  }
  if (bridge_reserve_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bridge_reserve_ack);
    if (message_arena != submessage_arena) {
      bridge_reserve_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bridge_reserve_ack, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  bridge_reserve_ack_ = bridge_reserve_ack;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SignalFrame.bridge_reserve_ack)
}

// -------------------------------------------------------------------

// ErrorFrame

// optional uint32 status = 1;
inline bool ErrorFrame::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ErrorFrame::has_status() const {
  return _internal_has_status();
}
inline void ErrorFrame::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ErrorFrame::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ErrorFrame::status() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ErrorFrame.status)
  return _internal_status();
}
inline void ErrorFrame::_internal_set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void ErrorFrame::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ErrorFrame.status)
}

// optional string description = 2;
inline bool ErrorFrame::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorFrame::has_description() const {
  return _internal_has_description();
}
inline void ErrorFrame::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorFrame::description() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ErrorFrame.description)
  return _internal_description();
}
inline void ErrorFrame::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ErrorFrame.description)
}
inline std::string* ErrorFrame::mutable_description() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ErrorFrame.description)
  return _internal_mutable_description();
}
inline const std::string& ErrorFrame::_internal_description() const {
  return description_.Get();
}
inline void ErrorFrame::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorFrame::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ErrorFrame.description)
}
inline void ErrorFrame::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ErrorFrame.description)
}
inline void ErrorFrame::set_description(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ErrorFrame.description)
}
inline std::string* ErrorFrame::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorFrame::release_description() {
  // @@protoc_insertion_point(field_release:signal_rtc.ErrorFrame.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorFrame::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ErrorFrame.description)
}

// -------------------------------------------------------------------

// ClientDetails

// optional string app_name = 1;
inline bool ClientDetails::_internal_has_app_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientDetails::has_app_name() const {
  return _internal_has_app_name();
}
inline void ClientDetails::clear_app_name() {
  app_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientDetails::app_name() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.app_name)
  return _internal_app_name();
}
inline void ClientDetails::set_app_name(const std::string& value) {
  _internal_set_app_name(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.app_name)
}
inline std::string* ClientDetails::mutable_app_name() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.app_name)
  return _internal_mutable_app_name();
}
inline const std::string& ClientDetails::_internal_app_name() const {
  return app_name_.Get();
}
inline void ClientDetails::_internal_set_app_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  app_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_app_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  app_name_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.app_name)
}
inline void ClientDetails::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  app_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.app_name)
}
inline void ClientDetails::set_app_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  app_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.app_name)
}
inline std::string* ClientDetails::_internal_mutable_app_name() {
  _has_bits_[0] |= 0x00000001u;
  return app_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_app_name() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return app_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  app_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.app_name)
}

// optional string app_version = 2;
inline bool ClientDetails::_internal_has_app_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientDetails::has_app_version() const {
  return _internal_has_app_version();
}
inline void ClientDetails::clear_app_version() {
  app_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientDetails::app_version() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.app_version)
  return _internal_app_version();
}
inline void ClientDetails::set_app_version(const std::string& value) {
  _internal_set_app_version(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.app_version)
}
inline std::string* ClientDetails::mutable_app_version() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.app_version)
  return _internal_mutable_app_version();
}
inline const std::string& ClientDetails::_internal_app_version() const {
  return app_version_.Get();
}
inline void ClientDetails::_internal_set_app_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  app_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_app_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  app_version_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.app_version)
}
inline void ClientDetails::set_app_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  app_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.app_version)
}
inline void ClientDetails::set_app_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  app_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.app_version)
}
inline std::string* ClientDetails::_internal_mutable_app_version() {
  _has_bits_[0] |= 0x00000002u;
  return app_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_app_version() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.app_version)
  if (!_internal_has_app_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return app_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_app_version(std::string* app_version) {
  if (app_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  app_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.app_version)
}

// optional string device_model = 3;
inline bool ClientDetails::_internal_has_device_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientDetails::has_device_model() const {
  return _internal_has_device_model();
}
inline void ClientDetails::clear_device_model() {
  device_model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientDetails::device_model() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.device_model)
  return _internal_device_model();
}
inline void ClientDetails::set_device_model(const std::string& value) {
  _internal_set_device_model(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.device_model)
}
inline std::string* ClientDetails::mutable_device_model() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.device_model)
  return _internal_mutable_device_model();
}
inline const std::string& ClientDetails::_internal_device_model() const {
  return device_model_.Get();
}
inline void ClientDetails::_internal_set_device_model(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_model_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_device_model(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  device_model_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.device_model)
}
inline void ClientDetails::set_device_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  device_model_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.device_model)
}
inline void ClientDetails::set_device_model(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  device_model_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.device_model)
}
inline std::string* ClientDetails::_internal_mutable_device_model() {
  _has_bits_[0] |= 0x00000004u;
  return device_model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_device_model() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.device_model)
  if (!_internal_has_device_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return device_model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.device_model)
}

// optional string device_make = 4;
inline bool ClientDetails::_internal_has_device_make() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientDetails::has_device_make() const {
  return _internal_has_device_make();
}
inline void ClientDetails::clear_device_make() {
  device_make_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientDetails::device_make() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.device_make)
  return _internal_device_make();
}
inline void ClientDetails::set_device_make(const std::string& value) {
  _internal_set_device_make(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.device_make)
}
inline std::string* ClientDetails::mutable_device_make() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.device_make)
  return _internal_mutable_device_make();
}
inline const std::string& ClientDetails::_internal_device_make() const {
  return device_make_.Get();
}
inline void ClientDetails::_internal_set_device_make(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_make_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_device_make(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  device_make_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.device_make)
}
inline void ClientDetails::set_device_make(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  device_make_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.device_make)
}
inline void ClientDetails::set_device_make(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  device_make_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.device_make)
}
inline std::string* ClientDetails::_internal_mutable_device_make() {
  _has_bits_[0] |= 0x00000008u;
  return device_make_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_device_make() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.device_make)
  if (!_internal_has_device_make()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return device_make_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_device_make(std::string* device_make) {
  if (device_make != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_make_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_make,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.device_make)
}

// optional string platform_name = 5;
inline bool ClientDetails::_internal_has_platform_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClientDetails::has_platform_name() const {
  return _internal_has_platform_name();
}
inline void ClientDetails::clear_platform_name() {
  platform_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClientDetails::platform_name() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.platform_name)
  return _internal_platform_name();
}
inline void ClientDetails::set_platform_name(const std::string& value) {
  _internal_set_platform_name(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.platform_name)
}
inline std::string* ClientDetails::mutable_platform_name() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.platform_name)
  return _internal_mutable_platform_name();
}
inline const std::string& ClientDetails::_internal_platform_name() const {
  return platform_name_.Get();
}
inline void ClientDetails::_internal_set_platform_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  platform_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_platform_name(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  platform_name_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.platform_name)
}
inline void ClientDetails::set_platform_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  platform_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.platform_name)
}
inline void ClientDetails::set_platform_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  platform_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.platform_name)
}
inline std::string* ClientDetails::_internal_mutable_platform_name() {
  _has_bits_[0] |= 0x00000010u;
  return platform_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_platform_name() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.platform_name)
  if (!_internal_has_platform_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return platform_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_platform_name(std::string* platform_name) {
  if (platform_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  platform_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.platform_name)
}

// optional string platform_version = 6;
inline bool ClientDetails::_internal_has_platform_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClientDetails::has_platform_version() const {
  return _internal_has_platform_version();
}
inline void ClientDetails::clear_platform_version() {
  platform_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ClientDetails::platform_version() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.platform_version)
  return _internal_platform_version();
}
inline void ClientDetails::set_platform_version(const std::string& value) {
  _internal_set_platform_version(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.platform_version)
}
inline std::string* ClientDetails::mutable_platform_version() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.platform_version)
  return _internal_mutable_platform_version();
}
inline const std::string& ClientDetails::_internal_platform_version() const {
  return platform_version_.Get();
}
inline void ClientDetails::_internal_set_platform_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  platform_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_platform_version(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  platform_version_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.platform_version)
}
inline void ClientDetails::set_platform_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  platform_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.platform_version)
}
inline void ClientDetails::set_platform_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  platform_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.platform_version)
}
inline std::string* ClientDetails::_internal_mutable_platform_version() {
  _has_bits_[0] |= 0x00000020u;
  return platform_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_platform_version() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.platform_version)
  if (!_internal_has_platform_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return platform_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_platform_version(std::string* platform_version) {
  if (platform_version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  platform_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.platform_version)
}

// optional string client_source = 7;
inline bool ClientDetails::_internal_has_client_source() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientDetails::has_client_source() const {
  return _internal_has_client_source();
}
inline void ClientDetails::clear_client_source() {
  client_source_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ClientDetails::client_source() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.client_source)
  return _internal_client_source();
}
inline void ClientDetails::set_client_source(const std::string& value) {
  _internal_set_client_source(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.client_source)
}
inline std::string* ClientDetails::mutable_client_source() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.client_source)
  return _internal_mutable_client_source();
}
inline const std::string& ClientDetails::_internal_client_source() const {
  return client_source_.Get();
}
inline void ClientDetails::_internal_set_client_source(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  client_source_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_client_source(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  client_source_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.client_source)
}
inline void ClientDetails::set_client_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  client_source_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.client_source)
}
inline void ClientDetails::set_client_source(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  client_source_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.client_source)
}
inline std::string* ClientDetails::_internal_mutable_client_source() {
  _has_bits_[0] |= 0x00000040u;
  return client_source_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_client_source() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.client_source)
  if (!_internal_has_client_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return client_source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_client_source(std::string* client_source) {
  if (client_source != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  client_source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.client_source)
}

// optional string chime_sdk_version = 8;
inline bool ClientDetails::_internal_has_chime_sdk_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientDetails::has_chime_sdk_version() const {
  return _internal_has_chime_sdk_version();
}
inline void ClientDetails::clear_chime_sdk_version() {
  chime_sdk_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ClientDetails::chime_sdk_version() const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientDetails.chime_sdk_version)
  return _internal_chime_sdk_version();
}
inline void ClientDetails::set_chime_sdk_version(const std::string& value) {
  _internal_set_chime_sdk_version(value);
  // @@protoc_insertion_point(field_set:signal_rtc.ClientDetails.chime_sdk_version)
}
inline std::string* ClientDetails::mutable_chime_sdk_version() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientDetails.chime_sdk_version)
  return _internal_mutable_chime_sdk_version();
}
inline const std::string& ClientDetails::_internal_chime_sdk_version() const {
  return chime_sdk_version_.Get();
}
inline void ClientDetails::_internal_set_chime_sdk_version(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  chime_sdk_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientDetails::set_chime_sdk_version(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  chime_sdk_version_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.ClientDetails.chime_sdk_version)
}
inline void ClientDetails::set_chime_sdk_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  chime_sdk_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.ClientDetails.chime_sdk_version)
}
inline void ClientDetails::set_chime_sdk_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  chime_sdk_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.ClientDetails.chime_sdk_version)
}
inline std::string* ClientDetails::_internal_mutable_chime_sdk_version() {
  _has_bits_[0] |= 0x00000080u;
  return chime_sdk_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientDetails::release_chime_sdk_version() {
  // @@protoc_insertion_point(field_release:signal_rtc.ClientDetails.chime_sdk_version)
  if (!_internal_has_chime_sdk_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return chime_sdk_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientDetails::set_allocated_chime_sdk_version(std::string* chime_sdk_version) {
  if (chime_sdk_version != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  chime_sdk_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chime_sdk_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.ClientDetails.chime_sdk_version)
}

// -------------------------------------------------------------------

// JoinFrame

// optional uint32 protocol_version = 1 [default = 2];
inline bool JoinFrame::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JoinFrame::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void JoinFrame::clear_protocol_version() {
  protocol_version_ = 2u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::protocol_version() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.protocol_version)
  return _internal_protocol_version();
}
inline void JoinFrame::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  protocol_version_ = value;
}
inline void JoinFrame::set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.protocol_version)
}

// optional uint32 max_num_of_videos = 2 [default = 8];
inline bool JoinFrame::_internal_has_max_num_of_videos() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool JoinFrame::has_max_num_of_videos() const {
  return _internal_has_max_num_of_videos();
}
inline void JoinFrame::clear_max_num_of_videos() {
  max_num_of_videos_ = 8u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::_internal_max_num_of_videos() const {
  return max_num_of_videos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::max_num_of_videos() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.max_num_of_videos)
  return _internal_max_num_of_videos();
}
inline void JoinFrame::_internal_set_max_num_of_videos(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  max_num_of_videos_ = value;
}
inline void JoinFrame::set_max_num_of_videos(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_num_of_videos(value);
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.max_num_of_videos)
}

// optional uint32 flags = 3;
inline bool JoinFrame::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinFrame::has_flags() const {
  return _internal_has_flags();
}
inline void JoinFrame::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinFrame::flags() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.flags)
  return _internal_flags();
}
inline void JoinFrame::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
}
inline void JoinFrame::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.flags)
}

// optional .signal_rtc.ClientDetails client_details = 4;
inline bool JoinFrame::_internal_has_client_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_details_ != nullptr);
  return value;
}
inline bool JoinFrame::has_client_details() const {
  return _internal_has_client_details();
}
inline void JoinFrame::clear_client_details() {
  if (client_details_ != nullptr) client_details_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::signal_rtc::ClientDetails& JoinFrame::_internal_client_details() const {
  const ::signal_rtc::ClientDetails* p = client_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::ClientDetails&>(
      ::signal_rtc::_ClientDetails_default_instance_);
}
inline const ::signal_rtc::ClientDetails& JoinFrame::client_details() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.client_details)
  return _internal_client_details();
}
inline void JoinFrame::unsafe_arena_set_allocated_client_details(
    ::signal_rtc::ClientDetails* client_details) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_details_);
  }
  client_details_ = client_details;
  if (client_details) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.JoinFrame.client_details)
}
inline ::signal_rtc::ClientDetails* JoinFrame::release_client_details() {
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::ClientDetails* temp = client_details_;
  client_details_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::ClientDetails* JoinFrame::unsafe_arena_release_client_details() {
  // @@protoc_insertion_point(field_release:signal_rtc.JoinFrame.client_details)
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::ClientDetails* temp = client_details_;
  client_details_ = nullptr;
  return temp;
}
inline ::signal_rtc::ClientDetails* JoinFrame::_internal_mutable_client_details() {
  _has_bits_[0] |= 0x00000001u;
  if (client_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::ClientDetails>(GetArena());
    client_details_ = p;
  }
  return client_details_;
}
inline ::signal_rtc::ClientDetails* JoinFrame::mutable_client_details() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.JoinFrame.client_details)
  return _internal_mutable_client_details();
}
inline void JoinFrame::set_allocated_client_details(::signal_rtc::ClientDetails* client_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete client_details_;
  }
  if (client_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(client_details);
    if (message_arena != submessage_arena) {
      client_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_details_ = client_details;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.JoinFrame.client_details)
}

// repeated string enabled_experiments = 5;
inline int JoinFrame::_internal_enabled_experiments_size() const {
  return enabled_experiments_.size();
}
inline int JoinFrame::enabled_experiments_size() const {
  return _internal_enabled_experiments_size();
}
inline void JoinFrame::clear_enabled_experiments() {
  enabled_experiments_.Clear();
}
inline std::string* JoinFrame::add_enabled_experiments() {
  // @@protoc_insertion_point(field_add_mutable:signal_rtc.JoinFrame.enabled_experiments)
  return _internal_add_enabled_experiments();
}
inline const std::string& JoinFrame::_internal_enabled_experiments(int index) const {
  return enabled_experiments_.Get(index);
}
inline const std::string& JoinFrame::enabled_experiments(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.enabled_experiments)
  return _internal_enabled_experiments(index);
}
inline std::string* JoinFrame::mutable_enabled_experiments(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.JoinFrame.enabled_experiments)
  return enabled_experiments_.Mutable(index);
}
inline void JoinFrame::set_enabled_experiments(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.enabled_experiments)
  enabled_experiments_.Mutable(index)->assign(value);
}
inline void JoinFrame::set_enabled_experiments(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.enabled_experiments)
  enabled_experiments_.Mutable(index)->assign(std::move(value));
}
inline void JoinFrame::set_enabled_experiments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enabled_experiments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:signal_rtc.JoinFrame.enabled_experiments)
}
inline void JoinFrame::set_enabled_experiments(int index, const char* value, size_t size) {
  enabled_experiments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.JoinFrame.enabled_experiments)
}
inline std::string* JoinFrame::_internal_add_enabled_experiments() {
  return enabled_experiments_.Add();
}
inline void JoinFrame::add_enabled_experiments(const std::string& value) {
  enabled_experiments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:signal_rtc.JoinFrame.enabled_experiments)
}
inline void JoinFrame::add_enabled_experiments(std::string&& value) {
  enabled_experiments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:signal_rtc.JoinFrame.enabled_experiments)
}
inline void JoinFrame::add_enabled_experiments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enabled_experiments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:signal_rtc.JoinFrame.enabled_experiments)
}
inline void JoinFrame::add_enabled_experiments(const char* value, size_t size) {
  enabled_experiments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:signal_rtc.JoinFrame.enabled_experiments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JoinFrame::enabled_experiments() const {
  // @@protoc_insertion_point(field_list:signal_rtc.JoinFrame.enabled_experiments)
  return enabled_experiments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JoinFrame::mutable_enabled_experiments() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.JoinFrame.enabled_experiments)
  return &enabled_experiments_;
}

// optional uint64 audio_session_id = 6;
inline bool JoinFrame::_internal_has_audio_session_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinFrame::has_audio_session_id() const {
  return _internal_has_audio_session_id();
}
inline void JoinFrame::clear_audio_session_id() {
  audio_session_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JoinFrame::_internal_audio_session_id() const {
  return audio_session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JoinFrame::audio_session_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinFrame.audio_session_id)
  return _internal_audio_session_id();
}
inline void JoinFrame::_internal_set_audio_session_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  audio_session_id_ = value;
}
inline void JoinFrame::set_audio_session_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_audio_session_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.JoinFrame.audio_session_id)
}

// -------------------------------------------------------------------

// JoinAckFrame

// optional .signal_rtc.TurnCredentials turn_credentials = 1;
inline bool JoinAckFrame::_internal_has_turn_credentials() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || turn_credentials_ != nullptr);
  return value;
}
inline bool JoinAckFrame::has_turn_credentials() const {
  return _internal_has_turn_credentials();
}
inline void JoinAckFrame::clear_turn_credentials() {
  if (turn_credentials_ != nullptr) turn_credentials_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::signal_rtc::TurnCredentials& JoinAckFrame::_internal_turn_credentials() const {
  const ::signal_rtc::TurnCredentials* p = turn_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::TurnCredentials&>(
      ::signal_rtc::_TurnCredentials_default_instance_);
}
inline const ::signal_rtc::TurnCredentials& JoinAckFrame::turn_credentials() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinAckFrame.turn_credentials)
  return _internal_turn_credentials();
}
inline void JoinAckFrame::unsafe_arena_set_allocated_turn_credentials(
    ::signal_rtc::TurnCredentials* turn_credentials) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_credentials_);
  }
  turn_credentials_ = turn_credentials;
  if (turn_credentials) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.JoinAckFrame.turn_credentials)
}
inline ::signal_rtc::TurnCredentials* JoinAckFrame::release_turn_credentials() {
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::TurnCredentials* temp = turn_credentials_;
  turn_credentials_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::TurnCredentials* JoinAckFrame::unsafe_arena_release_turn_credentials() {
  // @@protoc_insertion_point(field_release:signal_rtc.JoinAckFrame.turn_credentials)
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::TurnCredentials* temp = turn_credentials_;
  turn_credentials_ = nullptr;
  return temp;
}
inline ::signal_rtc::TurnCredentials* JoinAckFrame::_internal_mutable_turn_credentials() {
  _has_bits_[0] |= 0x00000001u;
  if (turn_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::TurnCredentials>(GetArena());
    turn_credentials_ = p;
  }
  return turn_credentials_;
}
inline ::signal_rtc::TurnCredentials* JoinAckFrame::mutable_turn_credentials() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.JoinAckFrame.turn_credentials)
  return _internal_mutable_turn_credentials();
}
inline void JoinAckFrame::set_allocated_turn_credentials(::signal_rtc::TurnCredentials* turn_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete turn_credentials_;
  }
  if (turn_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(turn_credentials);
    if (message_arena != submessage_arena) {
      turn_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  turn_credentials_ = turn_credentials;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.JoinAckFrame.turn_credentials)
}

// optional uint32 video_subscription_limit = 2;
inline bool JoinAckFrame::_internal_has_video_subscription_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinAckFrame::has_video_subscription_limit() const {
  return _internal_has_video_subscription_limit();
}
inline void JoinAckFrame::clear_video_subscription_limit() {
  video_subscription_limit_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinAckFrame::_internal_video_subscription_limit() const {
  return video_subscription_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinAckFrame::video_subscription_limit() const {
  // @@protoc_insertion_point(field_get:signal_rtc.JoinAckFrame.video_subscription_limit)
  return _internal_video_subscription_limit();
}
inline void JoinAckFrame::_internal_set_video_subscription_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  video_subscription_limit_ = value;
}
inline void JoinAckFrame::set_video_subscription_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_video_subscription_limit(value);
  // @@protoc_insertion_point(field_set:signal_rtc.JoinAckFrame.video_subscription_limit)
}

// -------------------------------------------------------------------

// BridgeJoinFrame

// optional uint32 protocol_version = 1 [default = 1];
inline bool BridgeJoinFrame::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BridgeJoinFrame::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void BridgeJoinFrame::clear_protocol_version() {
  protocol_version_ = 1u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BridgeJoinFrame::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BridgeJoinFrame::protocol_version() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeJoinFrame.protocol_version)
  return _internal_protocol_version();
}
inline void BridgeJoinFrame::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  protocol_version_ = value;
}
inline void BridgeJoinFrame::set_protocol_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeJoinFrame.protocol_version)
}

// optional string dtls_fingerprint = 2;
inline bool BridgeJoinFrame::_internal_has_dtls_fingerprint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BridgeJoinFrame::has_dtls_fingerprint() const {
  return _internal_has_dtls_fingerprint();
}
inline void BridgeJoinFrame::clear_dtls_fingerprint() {
  dtls_fingerprint_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BridgeJoinFrame::dtls_fingerprint() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
  return _internal_dtls_fingerprint();
}
inline void BridgeJoinFrame::set_dtls_fingerprint(const std::string& value) {
  _internal_set_dtls_fingerprint(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
}
inline std::string* BridgeJoinFrame::mutable_dtls_fingerprint() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
  return _internal_mutable_dtls_fingerprint();
}
inline const std::string& BridgeJoinFrame::_internal_dtls_fingerprint() const {
  return dtls_fingerprint_.Get();
}
inline void BridgeJoinFrame::_internal_set_dtls_fingerprint(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dtls_fingerprint_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BridgeJoinFrame::set_dtls_fingerprint(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  dtls_fingerprint_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
}
inline void BridgeJoinFrame::set_dtls_fingerprint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  dtls_fingerprint_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
}
inline void BridgeJoinFrame::set_dtls_fingerprint(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  dtls_fingerprint_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
}
inline std::string* BridgeJoinFrame::_internal_mutable_dtls_fingerprint() {
  _has_bits_[0] |= 0x00000001u;
  return dtls_fingerprint_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BridgeJoinFrame::release_dtls_fingerprint() {
  // @@protoc_insertion_point(field_release:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
  if (!_internal_has_dtls_fingerprint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return dtls_fingerprint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeJoinFrame::set_allocated_dtls_fingerprint(std::string* dtls_fingerprint) {
  if (dtls_fingerprint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dtls_fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dtls_fingerprint,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.BridgeJoinFrame.dtls_fingerprint)
}

// -------------------------------------------------------------------

// BridgeJoinAckFrame

// optional .signal_rtc.TurnCredentials turn_credentials = 1;
inline bool BridgeJoinAckFrame::_internal_has_turn_credentials() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || turn_credentials_ != nullptr);
  return value;
}
inline bool BridgeJoinAckFrame::has_turn_credentials() const {
  return _internal_has_turn_credentials();
}
inline void BridgeJoinAckFrame::clear_turn_credentials() {
  if (turn_credentials_ != nullptr) turn_credentials_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::signal_rtc::TurnCredentials& BridgeJoinAckFrame::_internal_turn_credentials() const {
  const ::signal_rtc::TurnCredentials* p = turn_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::TurnCredentials&>(
      ::signal_rtc::_TurnCredentials_default_instance_);
}
inline const ::signal_rtc::TurnCredentials& BridgeJoinAckFrame::turn_credentials() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeJoinAckFrame.turn_credentials)
  return _internal_turn_credentials();
}
inline void BridgeJoinAckFrame::unsafe_arena_set_allocated_turn_credentials(
    ::signal_rtc::TurnCredentials* turn_credentials) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_credentials_);
  }
  turn_credentials_ = turn_credentials;
  if (turn_credentials) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.BridgeJoinAckFrame.turn_credentials)
}
inline ::signal_rtc::TurnCredentials* BridgeJoinAckFrame::release_turn_credentials() {
  _has_bits_[0] &= ~0x00000002u;
  ::signal_rtc::TurnCredentials* temp = turn_credentials_;
  turn_credentials_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::TurnCredentials* BridgeJoinAckFrame::unsafe_arena_release_turn_credentials() {
  // @@protoc_insertion_point(field_release:signal_rtc.BridgeJoinAckFrame.turn_credentials)
  _has_bits_[0] &= ~0x00000002u;
  ::signal_rtc::TurnCredentials* temp = turn_credentials_;
  turn_credentials_ = nullptr;
  return temp;
}
inline ::signal_rtc::TurnCredentials* BridgeJoinAckFrame::_internal_mutable_turn_credentials() {
  _has_bits_[0] |= 0x00000002u;
  if (turn_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::TurnCredentials>(GetArena());
    turn_credentials_ = p;
  }
  return turn_credentials_;
}
inline ::signal_rtc::TurnCredentials* BridgeJoinAckFrame::mutable_turn_credentials() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BridgeJoinAckFrame.turn_credentials)
  return _internal_mutable_turn_credentials();
}
inline void BridgeJoinAckFrame::set_allocated_turn_credentials(::signal_rtc::TurnCredentials* turn_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete turn_credentials_;
  }
  if (turn_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(turn_credentials);
    if (message_arena != submessage_arena) {
      turn_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  turn_credentials_ = turn_credentials;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.BridgeJoinAckFrame.turn_credentials)
}

// optional string listener_ip_port = 2;
inline bool BridgeJoinAckFrame::_internal_has_listener_ip_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BridgeJoinAckFrame::has_listener_ip_port() const {
  return _internal_has_listener_ip_port();
}
inline void BridgeJoinAckFrame::clear_listener_ip_port() {
  listener_ip_port_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BridgeJoinAckFrame::listener_ip_port() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
  return _internal_listener_ip_port();
}
inline void BridgeJoinAckFrame::set_listener_ip_port(const std::string& value) {
  _internal_set_listener_ip_port(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
}
inline std::string* BridgeJoinAckFrame::mutable_listener_ip_port() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
  return _internal_mutable_listener_ip_port();
}
inline const std::string& BridgeJoinAckFrame::_internal_listener_ip_port() const {
  return listener_ip_port_.Get();
}
inline void BridgeJoinAckFrame::_internal_set_listener_ip_port(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  listener_ip_port_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BridgeJoinAckFrame::set_listener_ip_port(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  listener_ip_port_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
}
inline void BridgeJoinAckFrame::set_listener_ip_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  listener_ip_port_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
}
inline void BridgeJoinAckFrame::set_listener_ip_port(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  listener_ip_port_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
}
inline std::string* BridgeJoinAckFrame::_internal_mutable_listener_ip_port() {
  _has_bits_[0] |= 0x00000001u;
  return listener_ip_port_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BridgeJoinAckFrame::release_listener_ip_port() {
  // @@protoc_insertion_point(field_release:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
  if (!_internal_has_listener_ip_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return listener_ip_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeJoinAckFrame::set_allocated_listener_ip_port(std::string* listener_ip_port) {
  if (listener_ip_port != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  listener_ip_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), listener_ip_port,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.BridgeJoinAckFrame.listener_ip_port)
}

// -------------------------------------------------------------------

// LeaveFrame

// -------------------------------------------------------------------

// LeaveAckFrame

// -------------------------------------------------------------------

// SubscribeFrame

// optional .signal_rtc.StreamServiceType duplex = 1 [default = RX];
inline bool SubscribeFrame::_internal_has_duplex() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SubscribeFrame::has_duplex() const {
  return _internal_has_duplex();
}
inline void SubscribeFrame::clear_duplex() {
  duplex_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::signal_rtc::StreamServiceType SubscribeFrame::_internal_duplex() const {
  return static_cast< ::signal_rtc::StreamServiceType >(duplex_);
}
inline ::signal_rtc::StreamServiceType SubscribeFrame::duplex() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.duplex)
  return _internal_duplex();
}
inline void SubscribeFrame::_internal_set_duplex(::signal_rtc::StreamServiceType value) {
  assert(::signal_rtc::StreamServiceType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  duplex_ = value;
}
inline void SubscribeFrame::set_duplex(::signal_rtc::StreamServiceType value) {
  _internal_set_duplex(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.duplex)
}

// repeated .signal_rtc.StreamDescriptor send_streams = 2;
inline int SubscribeFrame::_internal_send_streams_size() const {
  return send_streams_.size();
}
inline int SubscribeFrame::send_streams_size() const {
  return _internal_send_streams_size();
}
inline void SubscribeFrame::clear_send_streams() {
  send_streams_.Clear();
}
inline ::signal_rtc::StreamDescriptor* SubscribeFrame::mutable_send_streams(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeFrame.send_streams)
  return send_streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >*
SubscribeFrame::mutable_send_streams() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.SubscribeFrame.send_streams)
  return &send_streams_;
}
inline const ::signal_rtc::StreamDescriptor& SubscribeFrame::_internal_send_streams(int index) const {
  return send_streams_.Get(index);
}
inline const ::signal_rtc::StreamDescriptor& SubscribeFrame::send_streams(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.send_streams)
  return _internal_send_streams(index);
}
inline ::signal_rtc::StreamDescriptor* SubscribeFrame::_internal_add_send_streams() {
  return send_streams_.Add();
}
inline ::signal_rtc::StreamDescriptor* SubscribeFrame::add_send_streams() {
  // @@protoc_insertion_point(field_add:signal_rtc.SubscribeFrame.send_streams)
  return _internal_add_send_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >&
SubscribeFrame::send_streams() const {
  // @@protoc_insertion_point(field_list:signal_rtc.SubscribeFrame.send_streams)
  return send_streams_;
}

// repeated uint32 receive_stream_ids = 3;
inline int SubscribeFrame::_internal_receive_stream_ids_size() const {
  return receive_stream_ids_.size();
}
inline int SubscribeFrame::receive_stream_ids_size() const {
  return _internal_receive_stream_ids_size();
}
inline void SubscribeFrame::clear_receive_stream_ids() {
  receive_stream_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SubscribeFrame::_internal_receive_stream_ids(int index) const {
  return receive_stream_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SubscribeFrame::receive_stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.receive_stream_ids)
  return _internal_receive_stream_ids(index);
}
inline void SubscribeFrame::set_receive_stream_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  receive_stream_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.receive_stream_ids)
}
inline void SubscribeFrame::_internal_add_receive_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  receive_stream_ids_.Add(value);
}
inline void SubscribeFrame::add_receive_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_receive_stream_ids(value);
  // @@protoc_insertion_point(field_add:signal_rtc.SubscribeFrame.receive_stream_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
SubscribeFrame::_internal_receive_stream_ids() const {
  return receive_stream_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
SubscribeFrame::receive_stream_ids() const {
  // @@protoc_insertion_point(field_list:signal_rtc.SubscribeFrame.receive_stream_ids)
  return _internal_receive_stream_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
SubscribeFrame::_internal_mutable_receive_stream_ids() {
  return &receive_stream_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
SubscribeFrame::mutable_receive_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.SubscribeFrame.receive_stream_ids)
  return _internal_mutable_receive_stream_ids();
}

// optional string sdp_offer = 4;
inline bool SubscribeFrame::_internal_has_sdp_offer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeFrame::has_sdp_offer() const {
  return _internal_has_sdp_offer();
}
inline void SubscribeFrame::clear_sdp_offer() {
  sdp_offer_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeFrame::sdp_offer() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.sdp_offer)
  return _internal_sdp_offer();
}
inline void SubscribeFrame::set_sdp_offer(const std::string& value) {
  _internal_set_sdp_offer(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.sdp_offer)
}
inline std::string* SubscribeFrame::mutable_sdp_offer() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeFrame.sdp_offer)
  return _internal_mutable_sdp_offer();
}
inline const std::string& SubscribeFrame::_internal_sdp_offer() const {
  return sdp_offer_.Get();
}
inline void SubscribeFrame::_internal_set_sdp_offer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_offer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeFrame::set_sdp_offer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_offer_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.SubscribeFrame.sdp_offer)
}
inline void SubscribeFrame::set_sdp_offer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sdp_offer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.SubscribeFrame.sdp_offer)
}
inline void SubscribeFrame::set_sdp_offer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sdp_offer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.SubscribeFrame.sdp_offer)
}
inline std::string* SubscribeFrame::_internal_mutable_sdp_offer() {
  _has_bits_[0] |= 0x00000001u;
  return sdp_offer_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeFrame::release_sdp_offer() {
  // @@protoc_insertion_point(field_release:signal_rtc.SubscribeFrame.sdp_offer)
  if (!_internal_has_sdp_offer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sdp_offer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeFrame::set_allocated_sdp_offer(std::string* sdp_offer) {
  if (sdp_offer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sdp_offer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp_offer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SubscribeFrame.sdp_offer)
}

// optional string xrp_host = 5;
inline bool SubscribeFrame::_internal_has_xrp_host() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubscribeFrame::has_xrp_host() const {
  return _internal_has_xrp_host();
}
inline void SubscribeFrame::clear_xrp_host() {
  xrp_host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubscribeFrame::xrp_host() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.xrp_host)
  return _internal_xrp_host();
}
inline void SubscribeFrame::set_xrp_host(const std::string& value) {
  _internal_set_xrp_host(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.xrp_host)
}
inline std::string* SubscribeFrame::mutable_xrp_host() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeFrame.xrp_host)
  return _internal_mutable_xrp_host();
}
inline const std::string& SubscribeFrame::_internal_xrp_host() const {
  return xrp_host_.Get();
}
inline void SubscribeFrame::_internal_set_xrp_host(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  xrp_host_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeFrame::set_xrp_host(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  xrp_host_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.SubscribeFrame.xrp_host)
}
inline void SubscribeFrame::set_xrp_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  xrp_host_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.SubscribeFrame.xrp_host)
}
inline void SubscribeFrame::set_xrp_host(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  xrp_host_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.SubscribeFrame.xrp_host)
}
inline std::string* SubscribeFrame::_internal_mutable_xrp_host() {
  _has_bits_[0] |= 0x00000002u;
  return xrp_host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeFrame::release_xrp_host() {
  // @@protoc_insertion_point(field_release:signal_rtc.SubscribeFrame.xrp_host)
  if (!_internal_has_xrp_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return xrp_host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeFrame::set_allocated_xrp_host(std::string* xrp_host) {
  if (xrp_host != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  xrp_host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xrp_host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SubscribeFrame.xrp_host)
}

// optional bool xrp_checkin = 6;
inline bool SubscribeFrame::_internal_has_xrp_checkin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubscribeFrame::has_xrp_checkin() const {
  return _internal_has_xrp_checkin();
}
inline void SubscribeFrame::clear_xrp_checkin() {
  xrp_checkin_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SubscribeFrame::_internal_xrp_checkin() const {
  return xrp_checkin_;
}
inline bool SubscribeFrame::xrp_checkin() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.xrp_checkin)
  return _internal_xrp_checkin();
}
inline void SubscribeFrame::_internal_set_xrp_checkin(bool value) {
  _has_bits_[0] |= 0x00000004u;
  xrp_checkin_ = value;
}
inline void SubscribeFrame::set_xrp_checkin(bool value) {
  _internal_set_xrp_checkin(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.xrp_checkin)
}

// optional bool xrp_muted = 7;
inline bool SubscribeFrame::_internal_has_xrp_muted() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubscribeFrame::has_xrp_muted() const {
  return _internal_has_xrp_muted();
}
inline void SubscribeFrame::clear_xrp_muted() {
  xrp_muted_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SubscribeFrame::_internal_xrp_muted() const {
  return xrp_muted_;
}
inline bool SubscribeFrame::xrp_muted() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeFrame.xrp_muted)
  return _internal_xrp_muted();
}
inline void SubscribeFrame::_internal_set_xrp_muted(bool value) {
  _has_bits_[0] |= 0x00000008u;
  xrp_muted_ = value;
}
inline void SubscribeFrame::set_xrp_muted(bool value) {
  _internal_set_xrp_muted(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeFrame.xrp_muted)
}

// -------------------------------------------------------------------

// SubscribeAckFrame

// optional .signal_rtc.StreamServiceType duplex = 1;
inline bool SubscribeAckFrame::_internal_has_duplex() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubscribeAckFrame::has_duplex() const {
  return _internal_has_duplex();
}
inline void SubscribeAckFrame::clear_duplex() {
  duplex_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::signal_rtc::StreamServiceType SubscribeAckFrame::_internal_duplex() const {
  return static_cast< ::signal_rtc::StreamServiceType >(duplex_);
}
inline ::signal_rtc::StreamServiceType SubscribeAckFrame::duplex() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeAckFrame.duplex)
  return _internal_duplex();
}
inline void SubscribeAckFrame::_internal_set_duplex(::signal_rtc::StreamServiceType value) {
  assert(::signal_rtc::StreamServiceType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  duplex_ = value;
}
inline void SubscribeAckFrame::set_duplex(::signal_rtc::StreamServiceType value) {
  _internal_set_duplex(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeAckFrame.duplex)
}

// repeated .signal_rtc.StreamAllocation allocations = 2;
inline int SubscribeAckFrame::_internal_allocations_size() const {
  return allocations_.size();
}
inline int SubscribeAckFrame::allocations_size() const {
  return _internal_allocations_size();
}
inline void SubscribeAckFrame::clear_allocations() {
  allocations_.Clear();
}
inline ::signal_rtc::StreamAllocation* SubscribeAckFrame::mutable_allocations(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeAckFrame.allocations)
  return allocations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamAllocation >*
SubscribeAckFrame::mutable_allocations() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.SubscribeAckFrame.allocations)
  return &allocations_;
}
inline const ::signal_rtc::StreamAllocation& SubscribeAckFrame::_internal_allocations(int index) const {
  return allocations_.Get(index);
}
inline const ::signal_rtc::StreamAllocation& SubscribeAckFrame::allocations(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeAckFrame.allocations)
  return _internal_allocations(index);
}
inline ::signal_rtc::StreamAllocation* SubscribeAckFrame::_internal_add_allocations() {
  return allocations_.Add();
}
inline ::signal_rtc::StreamAllocation* SubscribeAckFrame::add_allocations() {
  // @@protoc_insertion_point(field_add:signal_rtc.SubscribeAckFrame.allocations)
  return _internal_add_allocations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamAllocation >&
SubscribeAckFrame::allocations() const {
  // @@protoc_insertion_point(field_list:signal_rtc.SubscribeAckFrame.allocations)
  return allocations_;
}

// optional string sdp_answer = 3;
inline bool SubscribeAckFrame::_internal_has_sdp_answer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeAckFrame::has_sdp_answer() const {
  return _internal_has_sdp_answer();
}
inline void SubscribeAckFrame::clear_sdp_answer() {
  sdp_answer_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeAckFrame::sdp_answer() const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeAckFrame.sdp_answer)
  return _internal_sdp_answer();
}
inline void SubscribeAckFrame::set_sdp_answer(const std::string& value) {
  _internal_set_sdp_answer(value);
  // @@protoc_insertion_point(field_set:signal_rtc.SubscribeAckFrame.sdp_answer)
}
inline std::string* SubscribeAckFrame::mutable_sdp_answer() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeAckFrame.sdp_answer)
  return _internal_mutable_sdp_answer();
}
inline const std::string& SubscribeAckFrame::_internal_sdp_answer() const {
  return sdp_answer_.Get();
}
inline void SubscribeAckFrame::_internal_set_sdp_answer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_answer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeAckFrame::set_sdp_answer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_answer_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.SubscribeAckFrame.sdp_answer)
}
inline void SubscribeAckFrame::set_sdp_answer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sdp_answer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.SubscribeAckFrame.sdp_answer)
}
inline void SubscribeAckFrame::set_sdp_answer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sdp_answer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.SubscribeAckFrame.sdp_answer)
}
inline std::string* SubscribeAckFrame::_internal_mutable_sdp_answer() {
  _has_bits_[0] |= 0x00000001u;
  return sdp_answer_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeAckFrame::release_sdp_answer() {
  // @@protoc_insertion_point(field_release:signal_rtc.SubscribeAckFrame.sdp_answer)
  if (!_internal_has_sdp_answer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sdp_answer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeAckFrame::set_allocated_sdp_answer(std::string* sdp_answer) {
  if (sdp_answer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sdp_answer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp_answer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.SubscribeAckFrame.sdp_answer)
}

// repeated .signal_rtc.TrackMapping tracks = 4;
inline int SubscribeAckFrame::_internal_tracks_size() const {
  return tracks_.size();
}
inline int SubscribeAckFrame::tracks_size() const {
  return _internal_tracks_size();
}
inline void SubscribeAckFrame::clear_tracks() {
  tracks_.Clear();
}
inline ::signal_rtc::TrackMapping* SubscribeAckFrame::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.SubscribeAckFrame.tracks)
  return tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::TrackMapping >*
SubscribeAckFrame::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.SubscribeAckFrame.tracks)
  return &tracks_;
}
inline const ::signal_rtc::TrackMapping& SubscribeAckFrame::_internal_tracks(int index) const {
  return tracks_.Get(index);
}
inline const ::signal_rtc::TrackMapping& SubscribeAckFrame::tracks(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.SubscribeAckFrame.tracks)
  return _internal_tracks(index);
}
inline ::signal_rtc::TrackMapping* SubscribeAckFrame::_internal_add_tracks() {
  return tracks_.Add();
}
inline ::signal_rtc::TrackMapping* SubscribeAckFrame::add_tracks() {
  // @@protoc_insertion_point(field_add:signal_rtc.SubscribeAckFrame.tracks)
  return _internal_add_tracks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::TrackMapping >&
SubscribeAckFrame::tracks() const {
  // @@protoc_insertion_point(field_list:signal_rtc.SubscribeAckFrame.tracks)
  return tracks_;
}

// -------------------------------------------------------------------

// IndexFrame

// optional bool at_capacity = 1;
inline bool IndexFrame::_internal_has_at_capacity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndexFrame::has_at_capacity() const {
  return _internal_has_at_capacity();
}
inline void IndexFrame::clear_at_capacity() {
  at_capacity_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool IndexFrame::_internal_at_capacity() const {
  return at_capacity_;
}
inline bool IndexFrame::at_capacity() const {
  // @@protoc_insertion_point(field_get:signal_rtc.IndexFrame.at_capacity)
  return _internal_at_capacity();
}
inline void IndexFrame::_internal_set_at_capacity(bool value) {
  _has_bits_[0] |= 0x00000001u;
  at_capacity_ = value;
}
inline void IndexFrame::set_at_capacity(bool value) {
  _internal_set_at_capacity(value);
  // @@protoc_insertion_point(field_set:signal_rtc.IndexFrame.at_capacity)
}

// repeated .signal_rtc.StreamDescriptor sources = 2;
inline int IndexFrame::_internal_sources_size() const {
  return sources_.size();
}
inline int IndexFrame::sources_size() const {
  return _internal_sources_size();
}
inline void IndexFrame::clear_sources() {
  sources_.Clear();
}
inline ::signal_rtc::StreamDescriptor* IndexFrame::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.IndexFrame.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >*
IndexFrame::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.IndexFrame.sources)
  return &sources_;
}
inline const ::signal_rtc::StreamDescriptor& IndexFrame::_internal_sources(int index) const {
  return sources_.Get(index);
}
inline const ::signal_rtc::StreamDescriptor& IndexFrame::sources(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.IndexFrame.sources)
  return _internal_sources(index);
}
inline ::signal_rtc::StreamDescriptor* IndexFrame::_internal_add_sources() {
  return sources_.Add();
}
inline ::signal_rtc::StreamDescriptor* IndexFrame::add_sources() {
  // @@protoc_insertion_point(field_add:signal_rtc.IndexFrame.sources)
  return _internal_add_sources();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamDescriptor >&
IndexFrame::sources() const {
  // @@protoc_insertion_point(field_list:signal_rtc.IndexFrame.sources)
  return sources_;
}

// repeated uint32 paused_at_source_ids = 3;
inline int IndexFrame::_internal_paused_at_source_ids_size() const {
  return paused_at_source_ids_.size();
}
inline int IndexFrame::paused_at_source_ids_size() const {
  return _internal_paused_at_source_ids_size();
}
inline void IndexFrame::clear_paused_at_source_ids() {
  paused_at_source_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexFrame::_internal_paused_at_source_ids(int index) const {
  return paused_at_source_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexFrame::paused_at_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.IndexFrame.paused_at_source_ids)
  return _internal_paused_at_source_ids(index);
}
inline void IndexFrame::set_paused_at_source_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  paused_at_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:signal_rtc.IndexFrame.paused_at_source_ids)
}
inline void IndexFrame::_internal_add_paused_at_source_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  paused_at_source_ids_.Add(value);
}
inline void IndexFrame::add_paused_at_source_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_paused_at_source_ids(value);
  // @@protoc_insertion_point(field_add:signal_rtc.IndexFrame.paused_at_source_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
IndexFrame::_internal_paused_at_source_ids() const {
  return paused_at_source_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
IndexFrame::paused_at_source_ids() const {
  // @@protoc_insertion_point(field_list:signal_rtc.IndexFrame.paused_at_source_ids)
  return _internal_paused_at_source_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
IndexFrame::_internal_mutable_paused_at_source_ids() {
  return &paused_at_source_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
IndexFrame::mutable_paused_at_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.IndexFrame.paused_at_source_ids)
  return _internal_mutable_paused_at_source_ids();
}

// optional uint32 num_participants = 4;
inline bool IndexFrame::_internal_has_num_participants() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexFrame::has_num_participants() const {
  return _internal_has_num_participants();
}
inline void IndexFrame::clear_num_participants() {
  num_participants_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexFrame::_internal_num_participants() const {
  return num_participants_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexFrame::num_participants() const {
  // @@protoc_insertion_point(field_get:signal_rtc.IndexFrame.num_participants)
  return _internal_num_participants();
}
inline void IndexFrame::_internal_set_num_participants(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_participants_ = value;
}
inline void IndexFrame::set_num_participants(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_participants(value);
  // @@protoc_insertion_point(field_set:signal_rtc.IndexFrame.num_participants)
}

// -------------------------------------------------------------------

// PauseResumeFrame

// repeated uint32 stream_ids = 1;
inline int PauseResumeFrame::_internal_stream_ids_size() const {
  return stream_ids_.size();
}
inline int PauseResumeFrame::stream_ids_size() const {
  return _internal_stream_ids_size();
}
inline void PauseResumeFrame::clear_stream_ids() {
  stream_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PauseResumeFrame::_internal_stream_ids(int index) const {
  return stream_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PauseResumeFrame::stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.PauseResumeFrame.stream_ids)
  return _internal_stream_ids(index);
}
inline void PauseResumeFrame::set_stream_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  stream_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:signal_rtc.PauseResumeFrame.stream_ids)
}
inline void PauseResumeFrame::_internal_add_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  stream_ids_.Add(value);
}
inline void PauseResumeFrame::add_stream_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_stream_ids(value);
  // @@protoc_insertion_point(field_add:signal_rtc.PauseResumeFrame.stream_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PauseResumeFrame::_internal_stream_ids() const {
  return stream_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
PauseResumeFrame::stream_ids() const {
  // @@protoc_insertion_point(field_list:signal_rtc.PauseResumeFrame.stream_ids)
  return _internal_stream_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PauseResumeFrame::_internal_mutable_stream_ids() {
  return &stream_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
PauseResumeFrame::mutable_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.PauseResumeFrame.stream_ids)
  return _internal_mutable_stream_ids();
}

// -------------------------------------------------------------------

// BitrateFrame

// repeated .signal_rtc.Bitrate bitrates = 1;
inline int BitrateFrame::_internal_bitrates_size() const {
  return bitrates_.size();
}
inline int BitrateFrame::bitrates_size() const {
  return _internal_bitrates_size();
}
inline void BitrateFrame::clear_bitrates() {
  bitrates_.Clear();
}
inline ::signal_rtc::Bitrate* BitrateFrame::mutable_bitrates(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BitrateFrame.bitrates)
  return bitrates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Bitrate >*
BitrateFrame::mutable_bitrates() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.BitrateFrame.bitrates)
  return &bitrates_;
}
inline const ::signal_rtc::Bitrate& BitrateFrame::_internal_bitrates(int index) const {
  return bitrates_.Get(index);
}
inline const ::signal_rtc::Bitrate& BitrateFrame::bitrates(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.BitrateFrame.bitrates)
  return _internal_bitrates(index);
}
inline ::signal_rtc::Bitrate* BitrateFrame::_internal_add_bitrates() {
  return bitrates_.Add();
}
inline ::signal_rtc::Bitrate* BitrateFrame::add_bitrates() {
  // @@protoc_insertion_point(field_add:signal_rtc.BitrateFrame.bitrates)
  return _internal_add_bitrates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Bitrate >&
BitrateFrame::bitrates() const {
  // @@protoc_insertion_point(field_list:signal_rtc.BitrateFrame.bitrates)
  return bitrates_;
}

// -------------------------------------------------------------------

// StreamDescriptor

// optional uint32 stream_id = 1;
inline bool StreamDescriptor::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StreamDescriptor::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void StreamDescriptor::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.stream_id)
  return _internal_stream_id();
}
inline void StreamDescriptor::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  stream_id_ = value;
}
inline void StreamDescriptor::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.stream_id)
}

// optional uint32 framerate = 2;
inline bool StreamDescriptor::_internal_has_framerate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StreamDescriptor::has_framerate() const {
  return _internal_has_framerate();
}
inline void StreamDescriptor::clear_framerate() {
  framerate_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_framerate() const {
  return framerate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::framerate() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.framerate)
  return _internal_framerate();
}
inline void StreamDescriptor::_internal_set_framerate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  framerate_ = value;
}
inline void StreamDescriptor::set_framerate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.framerate)
}

// optional uint32 max_bitrate_kbps = 3;
inline bool StreamDescriptor::_internal_has_max_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StreamDescriptor::has_max_bitrate_kbps() const {
  return _internal_has_max_bitrate_kbps();
}
inline void StreamDescriptor::clear_max_bitrate_kbps() {
  max_bitrate_kbps_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_max_bitrate_kbps() const {
  return max_bitrate_kbps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::max_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.max_bitrate_kbps)
  return _internal_max_bitrate_kbps();
}
inline void StreamDescriptor::_internal_set_max_bitrate_kbps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_bitrate_kbps_ = value;
}
inline void StreamDescriptor::set_max_bitrate_kbps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.max_bitrate_kbps)
}

// optional string track_label = 4;
inline bool StreamDescriptor::_internal_has_track_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamDescriptor::has_track_label() const {
  return _internal_has_track_label();
}
inline void StreamDescriptor::clear_track_label() {
  track_label_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamDescriptor::track_label() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.track_label)
  return _internal_track_label();
}
inline void StreamDescriptor::set_track_label(const std::string& value) {
  _internal_set_track_label(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.track_label)
}
inline std::string* StreamDescriptor::mutable_track_label() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.StreamDescriptor.track_label)
  return _internal_mutable_track_label();
}
inline const std::string& StreamDescriptor::_internal_track_label() const {
  return track_label_.Get();
}
inline void StreamDescriptor::_internal_set_track_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StreamDescriptor::set_track_label(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.StreamDescriptor.track_label)
}
inline void StreamDescriptor::set_track_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.StreamDescriptor.track_label)
}
inline void StreamDescriptor::set_track_label(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.StreamDescriptor.track_label)
}
inline std::string* StreamDescriptor::_internal_mutable_track_label() {
  _has_bits_[0] |= 0x00000001u;
  return track_label_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StreamDescriptor::release_track_label() {
  // @@protoc_insertion_point(field_release:signal_rtc.StreamDescriptor.track_label)
  if (!_internal_has_track_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return track_label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamDescriptor::set_allocated_track_label(std::string* track_label) {
  if (track_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  track_label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.StreamDescriptor.track_label)
}

// optional uint32 profile_id = 5;
inline bool StreamDescriptor::_internal_has_profile_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StreamDescriptor::has_profile_id() const {
  return _internal_has_profile_id();
}
inline void StreamDescriptor::clear_profile_id() {
  profile_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_profile_id() const {
  return profile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::profile_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.profile_id)
  return _internal_profile_id();
}
inline void StreamDescriptor::_internal_set_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  profile_id_ = value;
}
inline void StreamDescriptor::set_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_profile_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.profile_id)
}

// optional uint32 group_id = 6;
inline bool StreamDescriptor::_internal_has_group_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StreamDescriptor::has_group_id() const {
  return _internal_has_group_id();
}
inline void StreamDescriptor::clear_group_id() {
  group_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::group_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.group_id)
  return _internal_group_id();
}
inline void StreamDescriptor::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  group_id_ = value;
}
inline void StreamDescriptor::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.group_id)
}

// optional uint32 avg_bitrate_bps = 7;
inline bool StreamDescriptor::_internal_has_avg_bitrate_bps() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StreamDescriptor::has_avg_bitrate_bps() const {
  return _internal_has_avg_bitrate_bps();
}
inline void StreamDescriptor::clear_avg_bitrate_bps() {
  avg_bitrate_bps_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::_internal_avg_bitrate_bps() const {
  return avg_bitrate_bps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDescriptor::avg_bitrate_bps() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.avg_bitrate_bps)
  return _internal_avg_bitrate_bps();
}
inline void StreamDescriptor::_internal_set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  avg_bitrate_bps_ = value;
}
inline void StreamDescriptor::set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_avg_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.avg_bitrate_bps)
}

// optional string profile_uuid = 8;
inline bool StreamDescriptor::_internal_has_profile_uuid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamDescriptor::has_profile_uuid() const {
  return _internal_has_profile_uuid();
}
inline void StreamDescriptor::clear_profile_uuid() {
  profile_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamDescriptor::profile_uuid() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.profile_uuid)
  return _internal_profile_uuid();
}
inline void StreamDescriptor::set_profile_uuid(const std::string& value) {
  _internal_set_profile_uuid(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.profile_uuid)
}
inline std::string* StreamDescriptor::mutable_profile_uuid() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.StreamDescriptor.profile_uuid)
  return _internal_mutable_profile_uuid();
}
inline const std::string& StreamDescriptor::_internal_profile_uuid() const {
  return profile_uuid_.Get();
}
inline void StreamDescriptor::_internal_set_profile_uuid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  profile_uuid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StreamDescriptor::set_profile_uuid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  profile_uuid_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.StreamDescriptor.profile_uuid)
}
inline void StreamDescriptor::set_profile_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  profile_uuid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.StreamDescriptor.profile_uuid)
}
inline void StreamDescriptor::set_profile_uuid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  profile_uuid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.StreamDescriptor.profile_uuid)
}
inline std::string* StreamDescriptor::_internal_mutable_profile_uuid() {
  _has_bits_[0] |= 0x00000002u;
  return profile_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StreamDescriptor::release_profile_uuid() {
  // @@protoc_insertion_point(field_release:signal_rtc.StreamDescriptor.profile_uuid)
  if (!_internal_has_profile_uuid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return profile_uuid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamDescriptor::set_allocated_profile_uuid(std::string* profile_uuid) {
  if (profile_uuid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  profile_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), profile_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.StreamDescriptor.profile_uuid)
}

// optional .signal_rtc.StreamMediaType media_type = 9;
inline bool StreamDescriptor::_internal_has_media_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StreamDescriptor::has_media_type() const {
  return _internal_has_media_type();
}
inline void StreamDescriptor::clear_media_type() {
  media_type_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::signal_rtc::StreamMediaType StreamDescriptor::_internal_media_type() const {
  return static_cast< ::signal_rtc::StreamMediaType >(media_type_);
}
inline ::signal_rtc::StreamMediaType StreamDescriptor::media_type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.media_type)
  return _internal_media_type();
}
inline void StreamDescriptor::_internal_set_media_type(::signal_rtc::StreamMediaType value) {
  assert(::signal_rtc::StreamMediaType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  media_type_ = value;
}
inline void StreamDescriptor::set_media_type(::signal_rtc::StreamMediaType value) {
  _internal_set_media_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.media_type)
}

// optional string external_user_id = 10;
inline bool StreamDescriptor::_internal_has_external_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StreamDescriptor::has_external_user_id() const {
  return _internal_has_external_user_id();
}
inline void StreamDescriptor::clear_external_user_id() {
  external_user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StreamDescriptor::external_user_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamDescriptor.external_user_id)
  return _internal_external_user_id();
}
inline void StreamDescriptor::set_external_user_id(const std::string& value) {
  _internal_set_external_user_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamDescriptor.external_user_id)
}
inline std::string* StreamDescriptor::mutable_external_user_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.StreamDescriptor.external_user_id)
  return _internal_mutable_external_user_id();
}
inline const std::string& StreamDescriptor::_internal_external_user_id() const {
  return external_user_id_.Get();
}
inline void StreamDescriptor::_internal_set_external_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StreamDescriptor::set_external_user_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  external_user_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.StreamDescriptor.external_user_id)
}
inline void StreamDescriptor::set_external_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.StreamDescriptor.external_user_id)
}
inline void StreamDescriptor::set_external_user_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.StreamDescriptor.external_user_id)
}
inline std::string* StreamDescriptor::_internal_mutable_external_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return external_user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StreamDescriptor::release_external_user_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.StreamDescriptor.external_user_id)
  if (!_internal_has_external_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return external_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamDescriptor::set_allocated_external_user_id(std::string* external_user_id) {
  if (external_user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  external_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.StreamDescriptor.external_user_id)
}

// -------------------------------------------------------------------

// StreamAllocation

// optional string track_label = 1;
inline bool StreamAllocation::_internal_has_track_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamAllocation::has_track_label() const {
  return _internal_has_track_label();
}
inline void StreamAllocation::clear_track_label() {
  track_label_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamAllocation::track_label() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamAllocation.track_label)
  return _internal_track_label();
}
inline void StreamAllocation::set_track_label(const std::string& value) {
  _internal_set_track_label(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamAllocation.track_label)
}
inline std::string* StreamAllocation::mutable_track_label() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.StreamAllocation.track_label)
  return _internal_mutable_track_label();
}
inline const std::string& StreamAllocation::_internal_track_label() const {
  return track_label_.Get();
}
inline void StreamAllocation::_internal_set_track_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StreamAllocation::set_track_label(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.StreamAllocation.track_label)
}
inline void StreamAllocation::set_track_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.StreamAllocation.track_label)
}
inline void StreamAllocation::set_track_label(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.StreamAllocation.track_label)
}
inline std::string* StreamAllocation::_internal_mutable_track_label() {
  _has_bits_[0] |= 0x00000001u;
  return track_label_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StreamAllocation::release_track_label() {
  // @@protoc_insertion_point(field_release:signal_rtc.StreamAllocation.track_label)
  if (!_internal_has_track_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return track_label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamAllocation::set_allocated_track_label(std::string* track_label) {
  if (track_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  track_label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.StreamAllocation.track_label)
}

// optional uint32 stream_id = 2;
inline bool StreamAllocation::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamAllocation::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void StreamAllocation::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamAllocation::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamAllocation::stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamAllocation.stream_id)
  return _internal_stream_id();
}
inline void StreamAllocation::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_ = value;
}
inline void StreamAllocation::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamAllocation.stream_id)
}

// optional uint32 group_id = 3;
inline bool StreamAllocation::_internal_has_group_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StreamAllocation::has_group_id() const {
  return _internal_has_group_id();
}
inline void StreamAllocation::clear_group_id() {
  group_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamAllocation::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamAllocation::group_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamAllocation.group_id)
  return _internal_group_id();
}
inline void StreamAllocation::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  group_id_ = value;
}
inline void StreamAllocation::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamAllocation.group_id)
}

// -------------------------------------------------------------------

// TrackMapping

// optional uint32 stream_id = 1;
inline bool TrackMapping::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackMapping::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void TrackMapping::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrackMapping::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrackMapping::stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TrackMapping.stream_id)
  return _internal_stream_id();
}
inline void TrackMapping::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_ = value;
}
inline void TrackMapping::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TrackMapping.stream_id)
}

// optional uint32 ssrc = 2;
inline bool TrackMapping::_internal_has_ssrc() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackMapping::has_ssrc() const {
  return _internal_has_ssrc();
}
inline void TrackMapping::clear_ssrc() {
  ssrc_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrackMapping::_internal_ssrc() const {
  return ssrc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrackMapping::ssrc() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TrackMapping.ssrc)
  return _internal_ssrc();
}
inline void TrackMapping::_internal_set_ssrc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ssrc_ = value;
}
inline void TrackMapping::set_ssrc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TrackMapping.ssrc)
}

// optional string track_label = 3;
inline bool TrackMapping::_internal_has_track_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackMapping::has_track_label() const {
  return _internal_has_track_label();
}
inline void TrackMapping::clear_track_label() {
  track_label_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackMapping::track_label() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TrackMapping.track_label)
  return _internal_track_label();
}
inline void TrackMapping::set_track_label(const std::string& value) {
  _internal_set_track_label(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TrackMapping.track_label)
}
inline std::string* TrackMapping::mutable_track_label() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.TrackMapping.track_label)
  return _internal_mutable_track_label();
}
inline const std::string& TrackMapping::_internal_track_label() const {
  return track_label_.Get();
}
inline void TrackMapping::_internal_set_track_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TrackMapping::set_track_label(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.TrackMapping.track_label)
}
inline void TrackMapping::set_track_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.TrackMapping.track_label)
}
inline void TrackMapping::set_track_label(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.TrackMapping.track_label)
}
inline std::string* TrackMapping::_internal_mutable_track_label() {
  _has_bits_[0] |= 0x00000001u;
  return track_label_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TrackMapping::release_track_label() {
  // @@protoc_insertion_point(field_release:signal_rtc.TrackMapping.track_label)
  if (!_internal_has_track_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return track_label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TrackMapping::set_allocated_track_label(std::string* track_label) {
  if (track_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  track_label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), track_label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.TrackMapping.track_label)
}

// -------------------------------------------------------------------

// Bitrate

// optional uint32 source_stream_id = 1;
inline bool Bitrate::_internal_has_source_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bitrate::has_source_stream_id() const {
  return _internal_has_source_stream_id();
}
inline void Bitrate::clear_source_stream_id() {
  source_stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitrate::_internal_source_stream_id() const {
  return source_stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitrate::source_stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.Bitrate.source_stream_id)
  return _internal_source_stream_id();
}
inline void Bitrate::_internal_set_source_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  source_stream_id_ = value;
}
inline void Bitrate::set_source_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_source_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.Bitrate.source_stream_id)
}

// optional uint32 avg_bitrate_bps = 2;
inline bool Bitrate::_internal_has_avg_bitrate_bps() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Bitrate::has_avg_bitrate_bps() const {
  return _internal_has_avg_bitrate_bps();
}
inline void Bitrate::clear_avg_bitrate_bps() {
  avg_bitrate_bps_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitrate::_internal_avg_bitrate_bps() const {
  return avg_bitrate_bps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitrate::avg_bitrate_bps() const {
  // @@protoc_insertion_point(field_get:signal_rtc.Bitrate.avg_bitrate_bps)
  return _internal_avg_bitrate_bps();
}
inline void Bitrate::_internal_set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  avg_bitrate_bps_ = value;
}
inline void Bitrate::set_avg_bitrate_bps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_avg_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:signal_rtc.Bitrate.avg_bitrate_bps)
}

// -------------------------------------------------------------------

// AudioControlFrame

// optional bool muted = 1;
inline bool AudioControlFrame::_internal_has_muted() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioControlFrame::has_muted() const {
  return _internal_has_muted();
}
inline void AudioControlFrame::clear_muted() {
  muted_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AudioControlFrame::_internal_muted() const {
  return muted_;
}
inline bool AudioControlFrame::muted() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioControlFrame.muted)
  return _internal_muted();
}
inline void AudioControlFrame::_internal_set_muted(bool value) {
  _has_bits_[0] |= 0x00000001u;
  muted_ = value;
}
inline void AudioControlFrame::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioControlFrame.muted)
}

// -------------------------------------------------------------------

// AudioMetadataFrame

// repeated .signal_rtc.AudioProfileState profile_states = 1;
inline int AudioMetadataFrame::_internal_profile_states_size() const {
  return profile_states_.size();
}
inline int AudioMetadataFrame::profile_states_size() const {
  return _internal_profile_states_size();
}
inline void AudioMetadataFrame::clear_profile_states() {
  profile_states_.Clear();
}
inline ::signal_rtc::AudioProfileState* AudioMetadataFrame::mutable_profile_states(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioMetadataFrame.profile_states)
  return profile_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioProfileState >*
AudioMetadataFrame::mutable_profile_states() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioMetadataFrame.profile_states)
  return &profile_states_;
}
inline const ::signal_rtc::AudioProfileState& AudioMetadataFrame::_internal_profile_states(int index) const {
  return profile_states_.Get(index);
}
inline const ::signal_rtc::AudioProfileState& AudioMetadataFrame::profile_states(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioMetadataFrame.profile_states)
  return _internal_profile_states(index);
}
inline ::signal_rtc::AudioProfileState* AudioMetadataFrame::_internal_add_profile_states() {
  return profile_states_.Add();
}
inline ::signal_rtc::AudioProfileState* AudioMetadataFrame::add_profile_states() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioMetadataFrame.profile_states)
  return _internal_add_profile_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioProfileState >&
AudioMetadataFrame::profile_states() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioMetadataFrame.profile_states)
  return profile_states_;
}

// -------------------------------------------------------------------

// AudioProfileState

// optional uint32 audio_stream_id = 1;
inline bool AudioProfileState::_internal_has_audio_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioProfileState::has_audio_stream_id() const {
  return _internal_has_audio_stream_id();
}
inline void AudioProfileState::clear_audio_stream_id() {
  audio_stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::_internal_audio_stream_id() const {
  return audio_stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::audio_stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioProfileState.audio_stream_id)
  return _internal_audio_stream_id();
}
inline void AudioProfileState::_internal_set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  audio_stream_id_ = value;
}
inline void AudioProfileState::set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_audio_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioProfileState.audio_stream_id)
}

// optional uint32 volume = 2;
inline bool AudioProfileState::_internal_has_volume() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioProfileState::has_volume() const {
  return _internal_has_volume();
}
inline void AudioProfileState::clear_volume() {
  volume_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::_internal_volume() const {
  return volume_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::volume() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioProfileState.volume)
  return _internal_volume();
}
inline void AudioProfileState::_internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  volume_ = value;
}
inline void AudioProfileState::set_volume(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioProfileState.volume)
}

// optional bool muted = 3;
inline bool AudioProfileState::_internal_has_muted() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioProfileState::has_muted() const {
  return _internal_has_muted();
}
inline void AudioProfileState::clear_muted() {
  muted_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AudioProfileState::_internal_muted() const {
  return muted_;
}
inline bool AudioProfileState::muted() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioProfileState.muted)
  return _internal_muted();
}
inline void AudioProfileState::_internal_set_muted(bool value) {
  _has_bits_[0] |= 0x00000004u;
  muted_ = value;
}
inline void AudioProfileState::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioProfileState.muted)
}

// optional uint32 signal_strength = 4;
inline bool AudioProfileState::_internal_has_signal_strength() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioProfileState::has_signal_strength() const {
  return _internal_has_signal_strength();
}
inline void AudioProfileState::clear_signal_strength() {
  signal_strength_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::_internal_signal_strength() const {
  return signal_strength_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioProfileState::signal_strength() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioProfileState.signal_strength)
  return _internal_signal_strength();
}
inline void AudioProfileState::_internal_set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  signal_strength_ = value;
}
inline void AudioProfileState::set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_signal_strength(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioProfileState.signal_strength)
}

// optional fixed64 ntp_timestamp = 5;
inline bool AudioProfileState::_internal_has_ntp_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioProfileState::has_ntp_timestamp() const {
  return _internal_has_ntp_timestamp();
}
inline void AudioProfileState::clear_ntp_timestamp() {
  ntp_timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioProfileState::_internal_ntp_timestamp() const {
  return ntp_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioProfileState::ntp_timestamp() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioProfileState.ntp_timestamp)
  return _internal_ntp_timestamp();
}
inline void AudioProfileState::_internal_set_ntp_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  ntp_timestamp_ = value;
}
inline void AudioProfileState::set_ntp_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ntp_timestamp(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioProfileState.ntp_timestamp)
}

// -------------------------------------------------------------------

// AudioStreamIdInfoFrame

// repeated .signal_rtc.AudioStreamIdInfo streams = 1;
inline int AudioStreamIdInfoFrame::_internal_streams_size() const {
  return streams_.size();
}
inline int AudioStreamIdInfoFrame::streams_size() const {
  return _internal_streams_size();
}
inline void AudioStreamIdInfoFrame::clear_streams() {
  streams_.Clear();
}
inline ::signal_rtc::AudioStreamIdInfo* AudioStreamIdInfoFrame::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioStreamIdInfoFrame.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioStreamIdInfo >*
AudioStreamIdInfoFrame::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioStreamIdInfoFrame.streams)
  return &streams_;
}
inline const ::signal_rtc::AudioStreamIdInfo& AudioStreamIdInfoFrame::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::signal_rtc::AudioStreamIdInfo& AudioStreamIdInfoFrame::streams(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfoFrame.streams)
  return _internal_streams(index);
}
inline ::signal_rtc::AudioStreamIdInfo* AudioStreamIdInfoFrame::_internal_add_streams() {
  return streams_.Add();
}
inline ::signal_rtc::AudioStreamIdInfo* AudioStreamIdInfoFrame::add_streams() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioStreamIdInfoFrame.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioStreamIdInfo >&
AudioStreamIdInfoFrame::streams() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioStreamIdInfoFrame.streams)
  return streams_;
}

// -------------------------------------------------------------------

// AudioStreamIdInfo

// optional uint32 audio_stream_id = 1;
inline bool AudioStreamIdInfo::_internal_has_audio_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioStreamIdInfo::has_audio_stream_id() const {
  return _internal_has_audio_stream_id();
}
inline void AudioStreamIdInfo::clear_audio_stream_id() {
  audio_stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioStreamIdInfo::_internal_audio_stream_id() const {
  return audio_stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioStreamIdInfo::audio_stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfo.audio_stream_id)
  return _internal_audio_stream_id();
}
inline void AudioStreamIdInfo::_internal_set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  audio_stream_id_ = value;
}
inline void AudioStreamIdInfo::set_audio_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_audio_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStreamIdInfo.audio_stream_id)
}

// optional string profile_id = 2;
inline bool AudioStreamIdInfo::_internal_has_profile_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioStreamIdInfo::has_profile_id() const {
  return _internal_has_profile_id();
}
inline void AudioStreamIdInfo::clear_profile_id() {
  profile_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioStreamIdInfo::profile_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfo.profile_id)
  return _internal_profile_id();
}
inline void AudioStreamIdInfo::set_profile_id(const std::string& value) {
  _internal_set_profile_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStreamIdInfo.profile_id)
}
inline std::string* AudioStreamIdInfo::mutable_profile_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioStreamIdInfo.profile_id)
  return _internal_mutable_profile_id();
}
inline const std::string& AudioStreamIdInfo::_internal_profile_id() const {
  return profile_id_.Get();
}
inline void AudioStreamIdInfo::_internal_set_profile_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioStreamIdInfo::set_profile_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  profile_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioStreamIdInfo.profile_id)
}
inline void AudioStreamIdInfo::set_profile_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioStreamIdInfo.profile_id)
}
inline void AudioStreamIdInfo::set_profile_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioStreamIdInfo.profile_id)
}
inline std::string* AudioStreamIdInfo::_internal_mutable_profile_id() {
  _has_bits_[0] |= 0x00000001u;
  return profile_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioStreamIdInfo::release_profile_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioStreamIdInfo.profile_id)
  if (!_internal_has_profile_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return profile_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioStreamIdInfo::set_allocated_profile_id(std::string* profile_id) {
  if (profile_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  profile_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), profile_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioStreamIdInfo.profile_id)
}

// optional bool muted = 3;
inline bool AudioStreamIdInfo::_internal_has_muted() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioStreamIdInfo::has_muted() const {
  return _internal_has_muted();
}
inline void AudioStreamIdInfo::clear_muted() {
  muted_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool AudioStreamIdInfo::_internal_muted() const {
  return muted_;
}
inline bool AudioStreamIdInfo::muted() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfo.muted)
  return _internal_muted();
}
inline void AudioStreamIdInfo::_internal_set_muted(bool value) {
  _has_bits_[0] |= 0x00000008u;
  muted_ = value;
}
inline void AudioStreamIdInfo::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStreamIdInfo.muted)
}

// optional string external_user_id = 4;
inline bool AudioStreamIdInfo::_internal_has_external_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioStreamIdInfo::has_external_user_id() const {
  return _internal_has_external_user_id();
}
inline void AudioStreamIdInfo::clear_external_user_id() {
  external_user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioStreamIdInfo::external_user_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfo.external_user_id)
  return _internal_external_user_id();
}
inline void AudioStreamIdInfo::set_external_user_id(const std::string& value) {
  _internal_set_external_user_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStreamIdInfo.external_user_id)
}
inline std::string* AudioStreamIdInfo::mutable_external_user_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioStreamIdInfo.external_user_id)
  return _internal_mutable_external_user_id();
}
inline const std::string& AudioStreamIdInfo::_internal_external_user_id() const {
  return external_user_id_.Get();
}
inline void AudioStreamIdInfo::_internal_set_external_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioStreamIdInfo::set_external_user_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioStreamIdInfo.external_user_id)
}
inline void AudioStreamIdInfo::set_external_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioStreamIdInfo.external_user_id)
}
inline void AudioStreamIdInfo::set_external_user_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioStreamIdInfo.external_user_id)
}
inline std::string* AudioStreamIdInfo::_internal_mutable_external_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return external_user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioStreamIdInfo::release_external_user_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioStreamIdInfo.external_user_id)
  if (!_internal_has_external_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return external_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioStreamIdInfo::set_allocated_external_user_id(std::string* external_user_id) {
  if (external_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioStreamIdInfo.external_user_id)
}

// optional bool dropped = 5;
inline bool AudioStreamIdInfo::_internal_has_dropped() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioStreamIdInfo::has_dropped() const {
  return _internal_has_dropped();
}
inline void AudioStreamIdInfo::clear_dropped() {
  dropped_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool AudioStreamIdInfo::_internal_dropped() const {
  return dropped_;
}
inline bool AudioStreamIdInfo::dropped() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStreamIdInfo.dropped)
  return _internal_dropped();
}
inline void AudioStreamIdInfo::_internal_set_dropped(bool value) {
  _has_bits_[0] |= 0x00000010u;
  dropped_ = value;
}
inline void AudioStreamIdInfo::set_dropped(bool value) {
  _internal_set_dropped(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStreamIdInfo.dropped)
}

// -------------------------------------------------------------------

// PingPongFrame

// required .signal_rtc.PingPongType type = 1;
inline bool PingPongFrame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PingPongFrame::has_type() const {
  return _internal_has_type();
}
inline void PingPongFrame::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::signal_rtc::PingPongType PingPongFrame::_internal_type() const {
  return static_cast< ::signal_rtc::PingPongType >(type_);
}
inline ::signal_rtc::PingPongType PingPongFrame::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.PingPongFrame.type)
  return _internal_type();
}
inline void PingPongFrame::_internal_set_type(::signal_rtc::PingPongType value) {
  assert(::signal_rtc::PingPongType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void PingPongFrame::set_type(::signal_rtc::PingPongType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.PingPongFrame.type)
}

// required uint32 ping_id = 2;
inline bool PingPongFrame::_internal_has_ping_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PingPongFrame::has_ping_id() const {
  return _internal_has_ping_id();
}
inline void PingPongFrame::clear_ping_id() {
  ping_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PingPongFrame::_internal_ping_id() const {
  return ping_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PingPongFrame::ping_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.PingPongFrame.ping_id)
  return _internal_ping_id();
}
inline void PingPongFrame::_internal_set_ping_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  ping_id_ = value;
}
inline void PingPongFrame::set_ping_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ping_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.PingPongFrame.ping_id)
}

// -------------------------------------------------------------------

// AudioStatusFrame

// optional uint32 xrp_status = 1;
inline bool AudioStatusFrame::_internal_has_xrp_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioStatusFrame::has_xrp_status() const {
  return _internal_has_xrp_status();
}
inline void AudioStatusFrame::clear_xrp_status() {
  xrp_status_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioStatusFrame::_internal_xrp_status() const {
  return xrp_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioStatusFrame::xrp_status() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioStatusFrame.xrp_status)
  return _internal_xrp_status();
}
inline void AudioStatusFrame::_internal_set_xrp_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  xrp_status_ = value;
}
inline void AudioStatusFrame::set_xrp_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_xrp_status(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioStatusFrame.xrp_status)
}

// -------------------------------------------------------------------

// Metric

// optional .signal_rtc.Metric.Type type = 1;
inline bool Metric::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Metric::has_type() const {
  return _internal_has_type();
}
inline void Metric::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::signal_rtc::Metric_Type Metric::_internal_type() const {
  return static_cast< ::signal_rtc::Metric_Type >(type_);
}
inline ::signal_rtc::Metric_Type Metric::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.Metric.type)
  return _internal_type();
}
inline void Metric::_internal_set_type(::signal_rtc::Metric_Type value) {
  assert(::signal_rtc::Metric_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Metric::set_type(::signal_rtc::Metric_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.Metric.type)
}

// optional double value = 2;
inline bool Metric::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Metric::has_value() const {
  return _internal_has_value();
}
inline void Metric::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Metric::_internal_value() const {
  return value_;
}
inline double Metric::value() const {
  // @@protoc_insertion_point(field_get:signal_rtc.Metric.value)
  return _internal_value();
}
inline void Metric::_internal_set_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void Metric::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:signal_rtc.Metric.value)
}

// -------------------------------------------------------------------

// StreamMetricFrame

// optional uint32 stream_id = 3;
inline bool StreamMetricFrame::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamMetricFrame::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void StreamMetricFrame::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamMetricFrame::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamMetricFrame::stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamMetricFrame.stream_id)
  return _internal_stream_id();
}
inline void StreamMetricFrame::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  stream_id_ = value;
}
inline void StreamMetricFrame::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamMetricFrame.stream_id)
}

// optional uint32 group_id = 4;
inline bool StreamMetricFrame::_internal_has_group_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamMetricFrame::has_group_id() const {
  return _internal_has_group_id();
}
inline void StreamMetricFrame::clear_group_id() {
  group_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamMetricFrame::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamMetricFrame::group_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamMetricFrame.group_id)
  return _internal_group_id();
}
inline void StreamMetricFrame::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  group_id_ = value;
}
inline void StreamMetricFrame::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.StreamMetricFrame.group_id)
}

// repeated .signal_rtc.Metric metrics = 5;
inline int StreamMetricFrame::_internal_metrics_size() const {
  return metrics_.size();
}
inline int StreamMetricFrame::metrics_size() const {
  return _internal_metrics_size();
}
inline void StreamMetricFrame::clear_metrics() {
  metrics_.Clear();
}
inline ::signal_rtc::Metric* StreamMetricFrame::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.StreamMetricFrame.metrics)
  return metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >*
StreamMetricFrame::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.StreamMetricFrame.metrics)
  return &metrics_;
}
inline const ::signal_rtc::Metric& StreamMetricFrame::_internal_metrics(int index) const {
  return metrics_.Get(index);
}
inline const ::signal_rtc::Metric& StreamMetricFrame::metrics(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.StreamMetricFrame.metrics)
  return _internal_metrics(index);
}
inline ::signal_rtc::Metric* StreamMetricFrame::_internal_add_metrics() {
  return metrics_.Add();
}
inline ::signal_rtc::Metric* StreamMetricFrame::add_metrics() {
  // @@protoc_insertion_point(field_add:signal_rtc.StreamMetricFrame.metrics)
  return _internal_add_metrics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >&
StreamMetricFrame::metrics() const {
  // @@protoc_insertion_point(field_list:signal_rtc.StreamMetricFrame.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// ClientMetricFrame

// repeated .signal_rtc.Metric global_metrics = 1;
inline int ClientMetricFrame::_internal_global_metrics_size() const {
  return global_metrics_.size();
}
inline int ClientMetricFrame::global_metrics_size() const {
  return _internal_global_metrics_size();
}
inline void ClientMetricFrame::clear_global_metrics() {
  global_metrics_.Clear();
}
inline ::signal_rtc::Metric* ClientMetricFrame::mutable_global_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientMetricFrame.global_metrics)
  return global_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >*
ClientMetricFrame::mutable_global_metrics() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.ClientMetricFrame.global_metrics)
  return &global_metrics_;
}
inline const ::signal_rtc::Metric& ClientMetricFrame::_internal_global_metrics(int index) const {
  return global_metrics_.Get(index);
}
inline const ::signal_rtc::Metric& ClientMetricFrame::global_metrics(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientMetricFrame.global_metrics)
  return _internal_global_metrics(index);
}
inline ::signal_rtc::Metric* ClientMetricFrame::_internal_add_global_metrics() {
  return global_metrics_.Add();
}
inline ::signal_rtc::Metric* ClientMetricFrame::add_global_metrics() {
  // @@protoc_insertion_point(field_add:signal_rtc.ClientMetricFrame.global_metrics)
  return _internal_add_global_metrics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::Metric >&
ClientMetricFrame::global_metrics() const {
  // @@protoc_insertion_point(field_list:signal_rtc.ClientMetricFrame.global_metrics)
  return global_metrics_;
}

// repeated .signal_rtc.StreamMetricFrame stream_metric_frames = 2;
inline int ClientMetricFrame::_internal_stream_metric_frames_size() const {
  return stream_metric_frames_.size();
}
inline int ClientMetricFrame::stream_metric_frames_size() const {
  return _internal_stream_metric_frames_size();
}
inline void ClientMetricFrame::clear_stream_metric_frames() {
  stream_metric_frames_.Clear();
}
inline ::signal_rtc::StreamMetricFrame* ClientMetricFrame::mutable_stream_metric_frames(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.ClientMetricFrame.stream_metric_frames)
  return stream_metric_frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamMetricFrame >*
ClientMetricFrame::mutable_stream_metric_frames() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.ClientMetricFrame.stream_metric_frames)
  return &stream_metric_frames_;
}
inline const ::signal_rtc::StreamMetricFrame& ClientMetricFrame::_internal_stream_metric_frames(int index) const {
  return stream_metric_frames_.Get(index);
}
inline const ::signal_rtc::StreamMetricFrame& ClientMetricFrame::stream_metric_frames(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.ClientMetricFrame.stream_metric_frames)
  return _internal_stream_metric_frames(index);
}
inline ::signal_rtc::StreamMetricFrame* ClientMetricFrame::_internal_add_stream_metric_frames() {
  return stream_metric_frames_.Add();
}
inline ::signal_rtc::StreamMetricFrame* ClientMetricFrame::add_stream_metric_frames() {
  // @@protoc_insertion_point(field_add:signal_rtc.ClientMetricFrame.stream_metric_frames)
  return _internal_add_stream_metric_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::StreamMetricFrame >&
ClientMetricFrame::stream_metric_frames() const {
  // @@protoc_insertion_point(field_list:signal_rtc.ClientMetricFrame.stream_metric_frames)
  return stream_metric_frames_;
}

// -------------------------------------------------------------------

// DataMessageFrame

// repeated .signal_rtc.DataMessagePayload messages = 1;
inline int DataMessageFrame::_internal_messages_size() const {
  return messages_.size();
}
inline int DataMessageFrame::messages_size() const {
  return _internal_messages_size();
}
inline void DataMessageFrame::clear_messages() {
  messages_.Clear();
}
inline ::signal_rtc::DataMessagePayload* DataMessageFrame::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.DataMessageFrame.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::DataMessagePayload >*
DataMessageFrame::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.DataMessageFrame.messages)
  return &messages_;
}
inline const ::signal_rtc::DataMessagePayload& DataMessageFrame::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::signal_rtc::DataMessagePayload& DataMessageFrame::messages(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessageFrame.messages)
  return _internal_messages(index);
}
inline ::signal_rtc::DataMessagePayload* DataMessageFrame::_internal_add_messages() {
  return messages_.Add();
}
inline ::signal_rtc::DataMessagePayload* DataMessageFrame::add_messages() {
  // @@protoc_insertion_point(field_add:signal_rtc.DataMessageFrame.messages)
  return _internal_add_messages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::DataMessagePayload >&
DataMessageFrame::messages() const {
  // @@protoc_insertion_point(field_list:signal_rtc.DataMessageFrame.messages)
  return messages_;
}

// -------------------------------------------------------------------

// DataMessagePayload

// optional string topic = 1;
inline bool DataMessagePayload::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessagePayload::has_topic() const {
  return _internal_has_topic();
}
inline void DataMessagePayload::clear_topic() {
  topic_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessagePayload::topic() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.topic)
  return _internal_topic();
}
inline void DataMessagePayload::set_topic(const std::string& value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.topic)
}
inline std::string* DataMessagePayload::mutable_topic() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.DataMessagePayload.topic)
  return _internal_mutable_topic();
}
inline const std::string& DataMessagePayload::_internal_topic() const {
  return topic_.Get();
}
inline void DataMessagePayload::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataMessagePayload::set_topic(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.DataMessagePayload.topic)
}
inline void DataMessagePayload::set_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.DataMessagePayload.topic)
}
inline void DataMessagePayload::set_topic(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.DataMessagePayload.topic)
}
inline std::string* DataMessagePayload::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataMessagePayload::release_topic() {
  // @@protoc_insertion_point(field_release:signal_rtc.DataMessagePayload.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessagePayload::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.DataMessagePayload.topic)
}

// optional bytes data = 2;
inline bool DataMessagePayload::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessagePayload::has_data() const {
  return _internal_has_data();
}
inline void DataMessagePayload::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessagePayload::data() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.data)
  return _internal_data();
}
inline void DataMessagePayload::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.data)
}
inline std::string* DataMessagePayload::mutable_data() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.DataMessagePayload.data)
  return _internal_mutable_data();
}
inline const std::string& DataMessagePayload::_internal_data() const {
  return data_.Get();
}
inline void DataMessagePayload::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataMessagePayload::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.DataMessagePayload.data)
}
inline void DataMessagePayload::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.DataMessagePayload.data)
}
inline void DataMessagePayload::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.DataMessagePayload.data)
}
inline std::string* DataMessagePayload::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataMessagePayload::release_data() {
  // @@protoc_insertion_point(field_release:signal_rtc.DataMessagePayload.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessagePayload::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.DataMessagePayload.data)
}

// optional uint32 lifetime_ms = 3;
inline bool DataMessagePayload::_internal_has_lifetime_ms() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DataMessagePayload::has_lifetime_ms() const {
  return _internal_has_lifetime_ms();
}
inline void DataMessagePayload::clear_lifetime_ms() {
  lifetime_ms_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataMessagePayload::_internal_lifetime_ms() const {
  return lifetime_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataMessagePayload::lifetime_ms() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.lifetime_ms)
  return _internal_lifetime_ms();
}
inline void DataMessagePayload::_internal_set_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  lifetime_ms_ = value;
}
inline void DataMessagePayload::set_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lifetime_ms(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.lifetime_ms)
}

// optional string sender_profile_id = 4;
inline bool DataMessagePayload::_internal_has_sender_profile_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessagePayload::has_sender_profile_id() const {
  return _internal_has_sender_profile_id();
}
inline void DataMessagePayload::clear_sender_profile_id() {
  sender_profile_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataMessagePayload::sender_profile_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.sender_profile_id)
  return _internal_sender_profile_id();
}
inline void DataMessagePayload::set_sender_profile_id(const std::string& value) {
  _internal_set_sender_profile_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.sender_profile_id)
}
inline std::string* DataMessagePayload::mutable_sender_profile_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.DataMessagePayload.sender_profile_id)
  return _internal_mutable_sender_profile_id();
}
inline const std::string& DataMessagePayload::_internal_sender_profile_id() const {
  return sender_profile_id_.Get();
}
inline void DataMessagePayload::_internal_set_sender_profile_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sender_profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataMessagePayload::set_sender_profile_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  sender_profile_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.DataMessagePayload.sender_profile_id)
}
inline void DataMessagePayload::set_sender_profile_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  sender_profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.DataMessagePayload.sender_profile_id)
}
inline void DataMessagePayload::set_sender_profile_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  sender_profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.DataMessagePayload.sender_profile_id)
}
inline std::string* DataMessagePayload::_internal_mutable_sender_profile_id() {
  _has_bits_[0] |= 0x00000004u;
  return sender_profile_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataMessagePayload::release_sender_profile_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.DataMessagePayload.sender_profile_id)
  if (!_internal_has_sender_profile_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sender_profile_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessagePayload::set_allocated_sender_profile_id(std::string* sender_profile_id) {
  if (sender_profile_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sender_profile_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_profile_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.DataMessagePayload.sender_profile_id)
}

// optional int64 ingest_time_ns = 5;
inline bool DataMessagePayload::_internal_has_ingest_time_ns() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataMessagePayload::has_ingest_time_ns() const {
  return _internal_has_ingest_time_ns();
}
inline void DataMessagePayload::clear_ingest_time_ns() {
  ingest_time_ns_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessagePayload::_internal_ingest_time_ns() const {
  return ingest_time_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessagePayload::ingest_time_ns() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.ingest_time_ns)
  return _internal_ingest_time_ns();
}
inline void DataMessagePayload::_internal_set_ingest_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  ingest_time_ns_ = value;
}
inline void DataMessagePayload::set_ingest_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ingest_time_ns(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.ingest_time_ns)
}

// optional string sender_external_user_id = 6;
inline bool DataMessagePayload::_internal_has_sender_external_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataMessagePayload::has_sender_external_user_id() const {
  return _internal_has_sender_external_user_id();
}
inline void DataMessagePayload::clear_sender_external_user_id() {
  sender_external_user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataMessagePayload::sender_external_user_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.DataMessagePayload.sender_external_user_id)
  return _internal_sender_external_user_id();
}
inline void DataMessagePayload::set_sender_external_user_id(const std::string& value) {
  _internal_set_sender_external_user_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.DataMessagePayload.sender_external_user_id)
}
inline std::string* DataMessagePayload::mutable_sender_external_user_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.DataMessagePayload.sender_external_user_id)
  return _internal_mutable_sender_external_user_id();
}
inline const std::string& DataMessagePayload::_internal_sender_external_user_id() const {
  return sender_external_user_id_.Get();
}
inline void DataMessagePayload::_internal_set_sender_external_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  sender_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataMessagePayload::set_sender_external_user_id(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  sender_external_user_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.DataMessagePayload.sender_external_user_id)
}
inline void DataMessagePayload::set_sender_external_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  sender_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.DataMessagePayload.sender_external_user_id)
}
inline void DataMessagePayload::set_sender_external_user_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  sender_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.DataMessagePayload.sender_external_user_id)
}
inline std::string* DataMessagePayload::_internal_mutable_sender_external_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return sender_external_user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataMessagePayload::release_sender_external_user_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.DataMessagePayload.sender_external_user_id)
  if (!_internal_has_sender_external_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return sender_external_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessagePayload::set_allocated_sender_external_user_id(std::string* sender_external_user_id) {
  if (sender_external_user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sender_external_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_external_user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.DataMessagePayload.sender_external_user_id)
}

// -------------------------------------------------------------------

// TurnCredentials

// optional string username = 1;
inline bool TurnCredentials::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TurnCredentials::has_username() const {
  return _internal_has_username();
}
inline void TurnCredentials::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TurnCredentials::username() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TurnCredentials.username)
  return _internal_username();
}
inline void TurnCredentials::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TurnCredentials.username)
}
inline std::string* TurnCredentials::mutable_username() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.TurnCredentials.username)
  return _internal_mutable_username();
}
inline const std::string& TurnCredentials::_internal_username() const {
  return username_.Get();
}
inline void TurnCredentials::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TurnCredentials::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.TurnCredentials.username)
}
inline void TurnCredentials::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.TurnCredentials.username)
}
inline void TurnCredentials::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.TurnCredentials.username)
}
inline std::string* TurnCredentials::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TurnCredentials::release_username() {
  // @@protoc_insertion_point(field_release:signal_rtc.TurnCredentials.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TurnCredentials::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.TurnCredentials.username)
}

// optional string password = 2;
inline bool TurnCredentials::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TurnCredentials::has_password() const {
  return _internal_has_password();
}
inline void TurnCredentials::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TurnCredentials::password() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TurnCredentials.password)
  return _internal_password();
}
inline void TurnCredentials::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TurnCredentials.password)
}
inline std::string* TurnCredentials::mutable_password() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.TurnCredentials.password)
  return _internal_mutable_password();
}
inline const std::string& TurnCredentials::_internal_password() const {
  return password_.Get();
}
inline void TurnCredentials::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TurnCredentials::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.TurnCredentials.password)
}
inline void TurnCredentials::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.TurnCredentials.password)
}
inline void TurnCredentials::set_password(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.TurnCredentials.password)
}
inline std::string* TurnCredentials::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TurnCredentials::release_password() {
  // @@protoc_insertion_point(field_release:signal_rtc.TurnCredentials.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TurnCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.TurnCredentials.password)
}

// optional uint32 ttl = 3;
inline bool TurnCredentials::_internal_has_ttl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TurnCredentials::has_ttl() const {
  return _internal_has_ttl();
}
inline void TurnCredentials::clear_ttl() {
  ttl_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TurnCredentials::_internal_ttl() const {
  return ttl_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TurnCredentials::ttl() const {
  // @@protoc_insertion_point(field_get:signal_rtc.TurnCredentials.ttl)
  return _internal_ttl();
}
inline void TurnCredentials::_internal_set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ttl_ = value;
}
inline void TurnCredentials::set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:signal_rtc.TurnCredentials.ttl)
}

// repeated string uris = 4;
inline int TurnCredentials::_internal_uris_size() const {
  return uris_.size();
}
inline int TurnCredentials::uris_size() const {
  return _internal_uris_size();
}
inline void TurnCredentials::clear_uris() {
  uris_.Clear();
}
inline std::string* TurnCredentials::add_uris() {
  // @@protoc_insertion_point(field_add_mutable:signal_rtc.TurnCredentials.uris)
  return _internal_add_uris();
}
inline const std::string& TurnCredentials::_internal_uris(int index) const {
  return uris_.Get(index);
}
inline const std::string& TurnCredentials::uris(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.TurnCredentials.uris)
  return _internal_uris(index);
}
inline std::string* TurnCredentials::mutable_uris(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.TurnCredentials.uris)
  return uris_.Mutable(index);
}
inline void TurnCredentials::set_uris(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.TurnCredentials.uris)
  uris_.Mutable(index)->assign(value);
}
inline void TurnCredentials::set_uris(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.TurnCredentials.uris)
  uris_.Mutable(index)->assign(std::move(value));
}
inline void TurnCredentials::set_uris(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:signal_rtc.TurnCredentials.uris)
}
inline void TurnCredentials::set_uris(int index, const char* value, size_t size) {
  uris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.TurnCredentials.uris)
}
inline std::string* TurnCredentials::_internal_add_uris() {
  return uris_.Add();
}
inline void TurnCredentials::add_uris(const std::string& value) {
  uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:signal_rtc.TurnCredentials.uris)
}
inline void TurnCredentials::add_uris(std::string&& value) {
  uris_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:signal_rtc.TurnCredentials.uris)
}
inline void TurnCredentials::add_uris(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:signal_rtc.TurnCredentials.uris)
}
inline void TurnCredentials::add_uris(const char* value, size_t size) {
  uris_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:signal_rtc.TurnCredentials.uris)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TurnCredentials::uris() const {
  // @@protoc_insertion_point(field_list:signal_rtc.TurnCredentials.uris)
  return uris_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TurnCredentials::mutable_uris() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.TurnCredentials.uris)
  return &uris_;
}

// -------------------------------------------------------------------

// AudioTranscriptItem

// optional string content = 1;
inline bool AudioTranscriptItem::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_content() const {
  return _internal_has_content();
}
inline void AudioTranscriptItem::clear_content() {
  content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioTranscriptItem::content() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.content)
  return _internal_content();
}
inline void AudioTranscriptItem::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.content)
}
inline std::string* AudioTranscriptItem::mutable_content() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptItem.content)
  return _internal_mutable_content();
}
inline const std::string& AudioTranscriptItem::_internal_content() const {
  return content_.Get();
}
inline void AudioTranscriptItem::_internal_set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptItem::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  content_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptItem.content)
}
inline void AudioTranscriptItem::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptItem.content)
}
inline void AudioTranscriptItem::set_content(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptItem.content)
}
inline std::string* AudioTranscriptItem::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000001u;
  return content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptItem::release_content() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptItem.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptItem::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptItem.content)
}

// optional int64 end_time = 2;
inline bool AudioTranscriptItem::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_end_time() const {
  return _internal_has_end_time();
}
inline void AudioTranscriptItem::clear_end_time() {
  end_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptItem::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptItem::end_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.end_time)
  return _internal_end_time();
}
inline void AudioTranscriptItem::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  end_time_ = value;
}
inline void AudioTranscriptItem::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.end_time)
}

// optional string speaker_attendee_id = 3;
inline bool AudioTranscriptItem::_internal_has_speaker_attendee_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_speaker_attendee_id() const {
  return _internal_has_speaker_attendee_id();
}
inline void AudioTranscriptItem::clear_speaker_attendee_id() {
  speaker_attendee_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioTranscriptItem::speaker_attendee_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
  return _internal_speaker_attendee_id();
}
inline void AudioTranscriptItem::set_speaker_attendee_id(const std::string& value) {
  _internal_set_speaker_attendee_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
}
inline std::string* AudioTranscriptItem::mutable_speaker_attendee_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
  return _internal_mutable_speaker_attendee_id();
}
inline const std::string& AudioTranscriptItem::_internal_speaker_attendee_id() const {
  return speaker_attendee_id_.Get();
}
inline void AudioTranscriptItem::_internal_set_speaker_attendee_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  speaker_attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptItem::set_speaker_attendee_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  speaker_attendee_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
}
inline void AudioTranscriptItem::set_speaker_attendee_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  speaker_attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
}
inline void AudioTranscriptItem::set_speaker_attendee_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  speaker_attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
}
inline std::string* AudioTranscriptItem::_internal_mutable_speaker_attendee_id() {
  _has_bits_[0] |= 0x00000002u;
  return speaker_attendee_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptItem::release_speaker_attendee_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
  if (!_internal_has_speaker_attendee_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return speaker_attendee_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptItem::set_allocated_speaker_attendee_id(std::string* speaker_attendee_id) {
  if (speaker_attendee_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  speaker_attendee_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), speaker_attendee_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptItem.speaker_attendee_id)
}

// optional string speaker_external_user_id = 4;
inline bool AudioTranscriptItem::_internal_has_speaker_external_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_speaker_external_user_id() const {
  return _internal_has_speaker_external_user_id();
}
inline void AudioTranscriptItem::clear_speaker_external_user_id() {
  speaker_external_user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AudioTranscriptItem::speaker_external_user_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
  return _internal_speaker_external_user_id();
}
inline void AudioTranscriptItem::set_speaker_external_user_id(const std::string& value) {
  _internal_set_speaker_external_user_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
}
inline std::string* AudioTranscriptItem::mutable_speaker_external_user_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
  return _internal_mutable_speaker_external_user_id();
}
inline const std::string& AudioTranscriptItem::_internal_speaker_external_user_id() const {
  return speaker_external_user_id_.Get();
}
inline void AudioTranscriptItem::_internal_set_speaker_external_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  speaker_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptItem::set_speaker_external_user_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  speaker_external_user_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
}
inline void AudioTranscriptItem::set_speaker_external_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  speaker_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
}
inline void AudioTranscriptItem::set_speaker_external_user_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  speaker_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
}
inline std::string* AudioTranscriptItem::_internal_mutable_speaker_external_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return speaker_external_user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptItem::release_speaker_external_user_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
  if (!_internal_has_speaker_external_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return speaker_external_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptItem::set_allocated_speaker_external_user_id(std::string* speaker_external_user_id) {
  if (speaker_external_user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  speaker_external_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), speaker_external_user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptItem.speaker_external_user_id)
}

// optional int64 start_time = 5;
inline bool AudioTranscriptItem::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_start_time() const {
  return _internal_has_start_time();
}
inline void AudioTranscriptItem::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptItem::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptItem::start_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.start_time)
  return _internal_start_time();
}
inline void AudioTranscriptItem::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  start_time_ = value;
}
inline void AudioTranscriptItem::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.start_time)
}

// optional .signal_rtc.AudioTranscriptItem.Type type = 6;
inline bool AudioTranscriptItem::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_type() const {
  return _internal_has_type();
}
inline void AudioTranscriptItem::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::signal_rtc::AudioTranscriptItem_Type AudioTranscriptItem::_internal_type() const {
  return static_cast< ::signal_rtc::AudioTranscriptItem_Type >(type_);
}
inline ::signal_rtc::AudioTranscriptItem_Type AudioTranscriptItem::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.type)
  return _internal_type();
}
inline void AudioTranscriptItem::_internal_set_type(::signal_rtc::AudioTranscriptItem_Type value) {
  assert(::signal_rtc::AudioTranscriptItem_Type_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void AudioTranscriptItem::set_type(::signal_rtc::AudioTranscriptItem_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.type)
}

// optional bool vocabulary_filter_match = 7;
inline bool AudioTranscriptItem::_internal_has_vocabulary_filter_match() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_vocabulary_filter_match() const {
  return _internal_has_vocabulary_filter_match();
}
inline void AudioTranscriptItem::clear_vocabulary_filter_match() {
  vocabulary_filter_match_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool AudioTranscriptItem::_internal_vocabulary_filter_match() const {
  return vocabulary_filter_match_;
}
inline bool AudioTranscriptItem::vocabulary_filter_match() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.vocabulary_filter_match)
  return _internal_vocabulary_filter_match();
}
inline void AudioTranscriptItem::_internal_set_vocabulary_filter_match(bool value) {
  _has_bits_[0] |= 0x00000040u;
  vocabulary_filter_match_ = value;
}
inline void AudioTranscriptItem::set_vocabulary_filter_match(bool value) {
  _internal_set_vocabulary_filter_match(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.vocabulary_filter_match)
}

// optional double confidence = 8;
inline bool AudioTranscriptItem::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_confidence() const {
  return _internal_has_confidence();
}
inline void AudioTranscriptItem::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double AudioTranscriptItem::_internal_confidence() const {
  return confidence_;
}
inline double AudioTranscriptItem::confidence() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.confidence)
  return _internal_confidence();
}
inline void AudioTranscriptItem::_internal_set_confidence(double value) {
  _has_bits_[0] |= 0x00000020u;
  confidence_ = value;
}
inline void AudioTranscriptItem::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.confidence)
}

// optional bool stable = 9;
inline bool AudioTranscriptItem::_internal_has_stable() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AudioTranscriptItem::has_stable() const {
  return _internal_has_stable();
}
inline void AudioTranscriptItem::clear_stable() {
  stable_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool AudioTranscriptItem::_internal_stable() const {
  return stable_;
}
inline bool AudioTranscriptItem::stable() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptItem.stable)
  return _internal_stable();
}
inline void AudioTranscriptItem::_internal_set_stable(bool value) {
  _has_bits_[0] |= 0x00000080u;
  stable_ = value;
}
inline void AudioTranscriptItem::set_stable(bool value) {
  _internal_set_stable(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptItem.stable)
}

// -------------------------------------------------------------------

// AudioTranscriptEntity

// optional string category = 1;
inline bool AudioTranscriptEntity::_internal_has_category() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_category() const {
  return _internal_has_category();
}
inline void AudioTranscriptEntity::clear_category() {
  category_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioTranscriptEntity::category() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.category)
  return _internal_category();
}
inline void AudioTranscriptEntity::set_category(const std::string& value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.category)
}
inline std::string* AudioTranscriptEntity::mutable_category() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptEntity.category)
  return _internal_mutable_category();
}
inline const std::string& AudioTranscriptEntity::_internal_category() const {
  return category_.Get();
}
inline void AudioTranscriptEntity::_internal_set_category(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  category_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptEntity::set_category(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  category_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptEntity.category)
}
inline void AudioTranscriptEntity::set_category(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  category_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptEntity.category)
}
inline void AudioTranscriptEntity::set_category(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  category_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptEntity.category)
}
inline std::string* AudioTranscriptEntity::_internal_mutable_category() {
  _has_bits_[0] |= 0x00000001u;
  return category_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptEntity::release_category() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptEntity.category)
  if (!_internal_has_category()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return category_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptEntity::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptEntity.category)
}

// optional double confidence = 2;
inline bool AudioTranscriptEntity::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_confidence() const {
  return _internal_has_confidence();
}
inline void AudioTranscriptEntity::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double AudioTranscriptEntity::_internal_confidence() const {
  return confidence_;
}
inline double AudioTranscriptEntity::confidence() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.confidence)
  return _internal_confidence();
}
inline void AudioTranscriptEntity::_internal_set_confidence(double value) {
  _has_bits_[0] |= 0x00000008u;
  confidence_ = value;
}
inline void AudioTranscriptEntity::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.confidence)
}

// optional string content = 3;
inline bool AudioTranscriptEntity::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_content() const {
  return _internal_has_content();
}
inline void AudioTranscriptEntity::clear_content() {
  content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioTranscriptEntity::content() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.content)
  return _internal_content();
}
inline void AudioTranscriptEntity::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.content)
}
inline std::string* AudioTranscriptEntity::mutable_content() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptEntity.content)
  return _internal_mutable_content();
}
inline const std::string& AudioTranscriptEntity::_internal_content() const {
  return content_.Get();
}
inline void AudioTranscriptEntity::_internal_set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptEntity::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  content_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptEntity.content)
}
inline void AudioTranscriptEntity::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptEntity.content)
}
inline void AudioTranscriptEntity::set_content(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptEntity.content)
}
inline std::string* AudioTranscriptEntity::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000002u;
  return content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptEntity::release_content() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptEntity.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptEntity::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptEntity.content)
}

// optional int64 end_time = 4;
inline bool AudioTranscriptEntity::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_end_time() const {
  return _internal_has_end_time();
}
inline void AudioTranscriptEntity::clear_end_time() {
  end_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptEntity::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptEntity::end_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.end_time)
  return _internal_end_time();
}
inline void AudioTranscriptEntity::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  end_time_ = value;
}
inline void AudioTranscriptEntity::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.end_time)
}

// optional int64 start_time = 5;
inline bool AudioTranscriptEntity::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_start_time() const {
  return _internal_has_start_time();
}
inline void AudioTranscriptEntity::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptEntity::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptEntity::start_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.start_time)
  return _internal_start_time();
}
inline void AudioTranscriptEntity::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  start_time_ = value;
}
inline void AudioTranscriptEntity::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.start_time)
}

// optional string type = 6;
inline bool AudioTranscriptEntity::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioTranscriptEntity::has_type() const {
  return _internal_has_type();
}
inline void AudioTranscriptEntity::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AudioTranscriptEntity::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEntity.type)
  return _internal_type();
}
inline void AudioTranscriptEntity::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptEntity.type)
}
inline std::string* AudioTranscriptEntity::mutable_type() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptEntity.type)
  return _internal_mutable_type();
}
inline const std::string& AudioTranscriptEntity::_internal_type() const {
  return type_.Get();
}
inline void AudioTranscriptEntity::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptEntity::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptEntity.type)
}
inline void AudioTranscriptEntity::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  type_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptEntity.type)
}
inline void AudioTranscriptEntity::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  type_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptEntity.type)
}
inline std::string* AudioTranscriptEntity::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptEntity::release_type() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptEntity.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptEntity::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptEntity.type)
}

// -------------------------------------------------------------------

// AudioTranscriptAlternative

// repeated .signal_rtc.AudioTranscriptItem items = 1;
inline int AudioTranscriptAlternative::_internal_items_size() const {
  return items_.size();
}
inline int AudioTranscriptAlternative::items_size() const {
  return _internal_items_size();
}
inline void AudioTranscriptAlternative::clear_items() {
  items_.Clear();
}
inline ::signal_rtc::AudioTranscriptItem* AudioTranscriptAlternative::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptAlternative.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptItem >*
AudioTranscriptAlternative::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioTranscriptAlternative.items)
  return &items_;
}
inline const ::signal_rtc::AudioTranscriptItem& AudioTranscriptAlternative::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::signal_rtc::AudioTranscriptItem& AudioTranscriptAlternative::items(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptAlternative.items)
  return _internal_items(index);
}
inline ::signal_rtc::AudioTranscriptItem* AudioTranscriptAlternative::_internal_add_items() {
  return items_.Add();
}
inline ::signal_rtc::AudioTranscriptItem* AudioTranscriptAlternative::add_items() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioTranscriptAlternative.items)
  return _internal_add_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptItem >&
AudioTranscriptAlternative::items() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioTranscriptAlternative.items)
  return items_;
}

// optional string transcript = 2;
inline bool AudioTranscriptAlternative::_internal_has_transcript() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioTranscriptAlternative::has_transcript() const {
  return _internal_has_transcript();
}
inline void AudioTranscriptAlternative::clear_transcript() {
  transcript_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioTranscriptAlternative::transcript() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptAlternative.transcript)
  return _internal_transcript();
}
inline void AudioTranscriptAlternative::set_transcript(const std::string& value) {
  _internal_set_transcript(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptAlternative.transcript)
}
inline std::string* AudioTranscriptAlternative::mutable_transcript() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptAlternative.transcript)
  return _internal_mutable_transcript();
}
inline const std::string& AudioTranscriptAlternative::_internal_transcript() const {
  return transcript_.Get();
}
inline void AudioTranscriptAlternative::_internal_set_transcript(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  transcript_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptAlternative::set_transcript(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  transcript_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptAlternative.transcript)
}
inline void AudioTranscriptAlternative::set_transcript(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  transcript_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptAlternative.transcript)
}
inline void AudioTranscriptAlternative::set_transcript(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  transcript_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptAlternative.transcript)
}
inline std::string* AudioTranscriptAlternative::_internal_mutable_transcript() {
  _has_bits_[0] |= 0x00000001u;
  return transcript_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptAlternative::release_transcript() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptAlternative.transcript)
  if (!_internal_has_transcript()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return transcript_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptAlternative::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transcript_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcript,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptAlternative.transcript)
}

// repeated .signal_rtc.AudioTranscriptEntity entities = 3;
inline int AudioTranscriptAlternative::_internal_entities_size() const {
  return entities_.size();
}
inline int AudioTranscriptAlternative::entities_size() const {
  return _internal_entities_size();
}
inline void AudioTranscriptAlternative::clear_entities() {
  entities_.Clear();
}
inline ::signal_rtc::AudioTranscriptEntity* AudioTranscriptAlternative::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptAlternative.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEntity >*
AudioTranscriptAlternative::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioTranscriptAlternative.entities)
  return &entities_;
}
inline const ::signal_rtc::AudioTranscriptEntity& AudioTranscriptAlternative::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::signal_rtc::AudioTranscriptEntity& AudioTranscriptAlternative::entities(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptAlternative.entities)
  return _internal_entities(index);
}
inline ::signal_rtc::AudioTranscriptEntity* AudioTranscriptAlternative::_internal_add_entities() {
  return entities_.Add();
}
inline ::signal_rtc::AudioTranscriptEntity* AudioTranscriptAlternative::add_entities() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioTranscriptAlternative.entities)
  return _internal_add_entities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEntity >&
AudioTranscriptAlternative::entities() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioTranscriptAlternative.entities)
  return entities_;
}

// -------------------------------------------------------------------

// AudioTranscriptResult

// repeated .signal_rtc.AudioTranscriptAlternative alternatives = 1;
inline int AudioTranscriptResult::_internal_alternatives_size() const {
  return alternatives_.size();
}
inline int AudioTranscriptResult::alternatives_size() const {
  return _internal_alternatives_size();
}
inline void AudioTranscriptResult::clear_alternatives() {
  alternatives_.Clear();
}
inline ::signal_rtc::AudioTranscriptAlternative* AudioTranscriptResult::mutable_alternatives(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptResult.alternatives)
  return alternatives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptAlternative >*
AudioTranscriptResult::mutable_alternatives() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioTranscriptResult.alternatives)
  return &alternatives_;
}
inline const ::signal_rtc::AudioTranscriptAlternative& AudioTranscriptResult::_internal_alternatives(int index) const {
  return alternatives_.Get(index);
}
inline const ::signal_rtc::AudioTranscriptAlternative& AudioTranscriptResult::alternatives(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.alternatives)
  return _internal_alternatives(index);
}
inline ::signal_rtc::AudioTranscriptAlternative* AudioTranscriptResult::_internal_add_alternatives() {
  return alternatives_.Add();
}
inline ::signal_rtc::AudioTranscriptAlternative* AudioTranscriptResult::add_alternatives() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioTranscriptResult.alternatives)
  return _internal_add_alternatives();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptAlternative >&
AudioTranscriptResult::alternatives() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioTranscriptResult.alternatives)
  return alternatives_;
}

// optional string channel_id = 2;
inline bool AudioTranscriptResult::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioTranscriptResult::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void AudioTranscriptResult::clear_channel_id() {
  channel_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioTranscriptResult::channel_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.channel_id)
  return _internal_channel_id();
}
inline void AudioTranscriptResult::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptResult.channel_id)
}
inline std::string* AudioTranscriptResult::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptResult.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& AudioTranscriptResult::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void AudioTranscriptResult::_internal_set_channel_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptResult::set_channel_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptResult.channel_id)
}
inline void AudioTranscriptResult::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  channel_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptResult.channel_id)
}
inline void AudioTranscriptResult::set_channel_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptResult.channel_id)
}
inline std::string* AudioTranscriptResult::_internal_mutable_channel_id() {
  _has_bits_[0] |= 0x00000001u;
  return channel_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptResult::release_channel_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptResult.channel_id)
  if (!_internal_has_channel_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return channel_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptResult::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptResult.channel_id)
}

// optional int64 end_time = 3;
inline bool AudioTranscriptResult::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioTranscriptResult::has_end_time() const {
  return _internal_has_end_time();
}
inline void AudioTranscriptResult::clear_end_time() {
  end_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptResult::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptResult::end_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.end_time)
  return _internal_end_time();
}
inline void AudioTranscriptResult::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  end_time_ = value;
}
inline void AudioTranscriptResult::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptResult.end_time)
}

// optional bool is_partial = 4;
inline bool AudioTranscriptResult::_internal_has_is_partial() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioTranscriptResult::has_is_partial() const {
  return _internal_has_is_partial();
}
inline void AudioTranscriptResult::clear_is_partial() {
  is_partial_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool AudioTranscriptResult::_internal_is_partial() const {
  return is_partial_;
}
inline bool AudioTranscriptResult::is_partial() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.is_partial)
  return _internal_is_partial();
}
inline void AudioTranscriptResult::_internal_set_is_partial(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_partial_ = value;
}
inline void AudioTranscriptResult::set_is_partial(bool value) {
  _internal_set_is_partial(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptResult.is_partial)
}

// optional string result_id = 5;
inline bool AudioTranscriptResult::_internal_has_result_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioTranscriptResult::has_result_id() const {
  return _internal_has_result_id();
}
inline void AudioTranscriptResult::clear_result_id() {
  result_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioTranscriptResult::result_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.result_id)
  return _internal_result_id();
}
inline void AudioTranscriptResult::set_result_id(const std::string& value) {
  _internal_set_result_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptResult.result_id)
}
inline std::string* AudioTranscriptResult::mutable_result_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptResult.result_id)
  return _internal_mutable_result_id();
}
inline const std::string& AudioTranscriptResult::_internal_result_id() const {
  return result_id_.Get();
}
inline void AudioTranscriptResult::_internal_set_result_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  result_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioTranscriptResult::set_result_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  result_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.AudioTranscriptResult.result_id)
}
inline void AudioTranscriptResult::set_result_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  result_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.AudioTranscriptResult.result_id)
}
inline void AudioTranscriptResult::set_result_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  result_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.AudioTranscriptResult.result_id)
}
inline std::string* AudioTranscriptResult::_internal_mutable_result_id() {
  _has_bits_[0] |= 0x00000002u;
  return result_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioTranscriptResult::release_result_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptResult.result_id)
  if (!_internal_has_result_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return result_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioTranscriptResult::set_allocated_result_id(std::string* result_id) {
  if (result_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptResult.result_id)
}

// optional int64 start_time = 6;
inline bool AudioTranscriptResult::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioTranscriptResult::has_start_time() const {
  return _internal_has_start_time();
}
inline void AudioTranscriptResult::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptResult::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioTranscriptResult::start_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptResult.start_time)
  return _internal_start_time();
}
inline void AudioTranscriptResult::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  start_time_ = value;
}
inline void AudioTranscriptResult::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.AudioTranscriptResult.start_time)
}

// -------------------------------------------------------------------

// AudioTranscript

// repeated .signal_rtc.AudioTranscriptResult results = 1;
inline int AudioTranscript::_internal_results_size() const {
  return results_.size();
}
inline int AudioTranscript::results_size() const {
  return _internal_results_size();
}
inline void AudioTranscript::clear_results() {
  results_.Clear();
}
inline ::signal_rtc::AudioTranscriptResult* AudioTranscript::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscript.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptResult >*
AudioTranscript::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioTranscript.results)
  return &results_;
}
inline const ::signal_rtc::AudioTranscriptResult& AudioTranscript::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::signal_rtc::AudioTranscriptResult& AudioTranscript::results(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscript.results)
  return _internal_results(index);
}
inline ::signal_rtc::AudioTranscriptResult* AudioTranscript::_internal_add_results() {
  return results_.Add();
}
inline ::signal_rtc::AudioTranscriptResult* AudioTranscript::add_results() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioTranscript.results)
  return _internal_add_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptResult >&
AudioTranscript::results() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioTranscript.results)
  return results_;
}

// -------------------------------------------------------------------

// MeetingTranscriptionStatus

// optional .signal_rtc.MeetingTranscriptionStatus.Type type = 1;
inline bool MeetingTranscriptionStatus::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MeetingTranscriptionStatus::has_type() const {
  return _internal_has_type();
}
inline void MeetingTranscriptionStatus::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::signal_rtc::MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::_internal_type() const {
  return static_cast< ::signal_rtc::MeetingTranscriptionStatus_Type >(type_);
}
inline ::signal_rtc::MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingTranscriptionStatus.type)
  return _internal_type();
}
inline void MeetingTranscriptionStatus::_internal_set_type(::signal_rtc::MeetingTranscriptionStatus_Type value) {
  assert(::signal_rtc::MeetingTranscriptionStatus_Type_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void MeetingTranscriptionStatus::set_type(::signal_rtc::MeetingTranscriptionStatus_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingTranscriptionStatus.type)
}

// optional int64 event_time = 2;
inline bool MeetingTranscriptionStatus::_internal_has_event_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MeetingTranscriptionStatus::has_event_time() const {
  return _internal_has_event_time();
}
inline void MeetingTranscriptionStatus::clear_event_time() {
  event_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeetingTranscriptionStatus::_internal_event_time() const {
  return event_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeetingTranscriptionStatus::event_time() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingTranscriptionStatus.event_time)
  return _internal_event_time();
}
inline void MeetingTranscriptionStatus::_internal_set_event_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  event_time_ = value;
}
inline void MeetingTranscriptionStatus::set_event_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_event_time(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingTranscriptionStatus.event_time)
}

// optional string transcription_region = 3;
inline bool MeetingTranscriptionStatus::_internal_has_transcription_region() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MeetingTranscriptionStatus::has_transcription_region() const {
  return _internal_has_transcription_region();
}
inline void MeetingTranscriptionStatus::clear_transcription_region() {
  transcription_region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeetingTranscriptionStatus::transcription_region() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingTranscriptionStatus.transcription_region)
  return _internal_transcription_region();
}
inline void MeetingTranscriptionStatus::set_transcription_region(const std::string& value) {
  _internal_set_transcription_region(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingTranscriptionStatus.transcription_region)
}
inline std::string* MeetingTranscriptionStatus::mutable_transcription_region() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingTranscriptionStatus.transcription_region)
  return _internal_mutable_transcription_region();
}
inline const std::string& MeetingTranscriptionStatus::_internal_transcription_region() const {
  return transcription_region_.Get();
}
inline void MeetingTranscriptionStatus::_internal_set_transcription_region(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  transcription_region_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingTranscriptionStatus::set_transcription_region(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  transcription_region_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingTranscriptionStatus.transcription_region)
}
inline void MeetingTranscriptionStatus::set_transcription_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  transcription_region_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingTranscriptionStatus.transcription_region)
}
inline void MeetingTranscriptionStatus::set_transcription_region(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  transcription_region_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingTranscriptionStatus.transcription_region)
}
inline std::string* MeetingTranscriptionStatus::_internal_mutable_transcription_region() {
  _has_bits_[0] |= 0x00000001u;
  return transcription_region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingTranscriptionStatus::release_transcription_region() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingTranscriptionStatus.transcription_region)
  if (!_internal_has_transcription_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return transcription_region_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingTranscriptionStatus::set_allocated_transcription_region(std::string* transcription_region) {
  if (transcription_region != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transcription_region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcription_region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingTranscriptionStatus.transcription_region)
}

// optional string transcription_configuration = 4;
inline bool MeetingTranscriptionStatus::_internal_has_transcription_configuration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MeetingTranscriptionStatus::has_transcription_configuration() const {
  return _internal_has_transcription_configuration();
}
inline void MeetingTranscriptionStatus::clear_transcription_configuration() {
  transcription_configuration_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MeetingTranscriptionStatus::transcription_configuration() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
  return _internal_transcription_configuration();
}
inline void MeetingTranscriptionStatus::set_transcription_configuration(const std::string& value) {
  _internal_set_transcription_configuration(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
}
inline std::string* MeetingTranscriptionStatus::mutable_transcription_configuration() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
  return _internal_mutable_transcription_configuration();
}
inline const std::string& MeetingTranscriptionStatus::_internal_transcription_configuration() const {
  return transcription_configuration_.Get();
}
inline void MeetingTranscriptionStatus::_internal_set_transcription_configuration(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  transcription_configuration_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingTranscriptionStatus::set_transcription_configuration(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  transcription_configuration_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
}
inline void MeetingTranscriptionStatus::set_transcription_configuration(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  transcription_configuration_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
}
inline void MeetingTranscriptionStatus::set_transcription_configuration(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  transcription_configuration_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
}
inline std::string* MeetingTranscriptionStatus::_internal_mutable_transcription_configuration() {
  _has_bits_[0] |= 0x00000002u;
  return transcription_configuration_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingTranscriptionStatus::release_transcription_configuration() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
  if (!_internal_has_transcription_configuration()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return transcription_configuration_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingTranscriptionStatus::set_allocated_transcription_configuration(std::string* transcription_configuration) {
  if (transcription_configuration != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transcription_configuration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcription_configuration,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingTranscriptionStatus.transcription_configuration)
}

// optional string message = 5;
inline bool MeetingTranscriptionStatus::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MeetingTranscriptionStatus::has_message() const {
  return _internal_has_message();
}
inline void MeetingTranscriptionStatus::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MeetingTranscriptionStatus::message() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingTranscriptionStatus.message)
  return _internal_message();
}
inline void MeetingTranscriptionStatus::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingTranscriptionStatus.message)
}
inline std::string* MeetingTranscriptionStatus::mutable_message() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingTranscriptionStatus.message)
  return _internal_mutable_message();
}
inline const std::string& MeetingTranscriptionStatus::_internal_message() const {
  return message_.Get();
}
inline void MeetingTranscriptionStatus::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingTranscriptionStatus::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingTranscriptionStatus.message)
}
inline void MeetingTranscriptionStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  message_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingTranscriptionStatus.message)
}
inline void MeetingTranscriptionStatus::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingTranscriptionStatus.message)
}
inline std::string* MeetingTranscriptionStatus::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000004u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingTranscriptionStatus::release_message() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingTranscriptionStatus.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingTranscriptionStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingTranscriptionStatus.message)
}

// -------------------------------------------------------------------

// AudioTranscriptEvent

// .signal_rtc.MeetingTranscriptionStatus status = 1;
inline bool AudioTranscriptEvent::_internal_has_status() const {
  return Event_case() == kStatus;
}
inline bool AudioTranscriptEvent::has_status() const {
  return _internal_has_status();
}
inline void AudioTranscriptEvent::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void AudioTranscriptEvent::clear_status() {
  if (_internal_has_status()) {
    if (GetArena() == nullptr) {
      delete Event_.status_;
    }
    clear_has_Event();
  }
}
inline ::signal_rtc::MeetingTranscriptionStatus* AudioTranscriptEvent::release_status() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptEvent.status)
  if (_internal_has_status()) {
    clear_has_Event();
      ::signal_rtc::MeetingTranscriptionStatus* temp = Event_.status_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_rtc::MeetingTranscriptionStatus& AudioTranscriptEvent::_internal_status() const {
  return _internal_has_status()
      ? *Event_.status_
      : reinterpret_cast< ::signal_rtc::MeetingTranscriptionStatus&>(::signal_rtc::_MeetingTranscriptionStatus_default_instance_);
}
inline const ::signal_rtc::MeetingTranscriptionStatus& AudioTranscriptEvent::status() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEvent.status)
  return _internal_status();
}
inline ::signal_rtc::MeetingTranscriptionStatus* AudioTranscriptEvent::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:signal_rtc.AudioTranscriptEvent.status)
  if (_internal_has_status()) {
    clear_has_Event();
    ::signal_rtc::MeetingTranscriptionStatus* temp = Event_.status_;
    Event_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioTranscriptEvent::unsafe_arena_set_allocated_status(::signal_rtc::MeetingTranscriptionStatus* status) {
  clear_Event();
  if (status) {
    set_has_status();
    Event_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.AudioTranscriptEvent.status)
}
inline ::signal_rtc::MeetingTranscriptionStatus* AudioTranscriptEvent::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_Event();
    set_has_status();
    Event_.status_ = CreateMaybeMessage< ::signal_rtc::MeetingTranscriptionStatus >(GetArena());
  }
  return Event_.status_;
}
inline ::signal_rtc::MeetingTranscriptionStatus* AudioTranscriptEvent::mutable_status() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptEvent.status)
  return _internal_mutable_status();
}

// .signal_rtc.AudioTranscript transcript = 2;
inline bool AudioTranscriptEvent::_internal_has_transcript() const {
  return Event_case() == kTranscript;
}
inline bool AudioTranscriptEvent::has_transcript() const {
  return _internal_has_transcript();
}
inline void AudioTranscriptEvent::set_has_transcript() {
  _oneof_case_[0] = kTranscript;
}
inline void AudioTranscriptEvent::clear_transcript() {
  if (_internal_has_transcript()) {
    if (GetArena() == nullptr) {
      delete Event_.transcript_;
    }
    clear_has_Event();
  }
}
inline ::signal_rtc::AudioTranscript* AudioTranscriptEvent::release_transcript() {
  // @@protoc_insertion_point(field_release:signal_rtc.AudioTranscriptEvent.transcript)
  if (_internal_has_transcript()) {
    clear_has_Event();
      ::signal_rtc::AudioTranscript* temp = Event_.transcript_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_rtc::AudioTranscript& AudioTranscriptEvent::_internal_transcript() const {
  return _internal_has_transcript()
      ? *Event_.transcript_
      : reinterpret_cast< ::signal_rtc::AudioTranscript&>(::signal_rtc::_AudioTranscript_default_instance_);
}
inline const ::signal_rtc::AudioTranscript& AudioTranscriptEvent::transcript() const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptEvent.transcript)
  return _internal_transcript();
}
inline ::signal_rtc::AudioTranscript* AudioTranscriptEvent::unsafe_arena_release_transcript() {
  // @@protoc_insertion_point(field_unsafe_arena_release:signal_rtc.AudioTranscriptEvent.transcript)
  if (_internal_has_transcript()) {
    clear_has_Event();
    ::signal_rtc::AudioTranscript* temp = Event_.transcript_;
    Event_.transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioTranscriptEvent::unsafe_arena_set_allocated_transcript(::signal_rtc::AudioTranscript* transcript) {
  clear_Event();
  if (transcript) {
    set_has_transcript();
    Event_.transcript_ = transcript;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.AudioTranscriptEvent.transcript)
}
inline ::signal_rtc::AudioTranscript* AudioTranscriptEvent::_internal_mutable_transcript() {
  if (!_internal_has_transcript()) {
    clear_Event();
    set_has_transcript();
    Event_.transcript_ = CreateMaybeMessage< ::signal_rtc::AudioTranscript >(GetArena());
  }
  return Event_.transcript_;
}
inline ::signal_rtc::AudioTranscript* AudioTranscriptEvent::mutable_transcript() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptEvent.transcript)
  return _internal_mutable_transcript();
}

inline bool AudioTranscriptEvent::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void AudioTranscriptEvent::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline AudioTranscriptEvent::EventCase AudioTranscriptEvent::Event_case() const {
  return AudioTranscriptEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AudioTranscriptFrame

// repeated .signal_rtc.AudioTranscriptEvent events = 1;
inline int AudioTranscriptFrame::_internal_events_size() const {
  return events_.size();
}
inline int AudioTranscriptFrame::events_size() const {
  return _internal_events_size();
}
inline void AudioTranscriptFrame::clear_events() {
  events_.Clear();
}
inline ::signal_rtc::AudioTranscriptEvent* AudioTranscriptFrame::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.AudioTranscriptFrame.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEvent >*
AudioTranscriptFrame::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.AudioTranscriptFrame.events)
  return &events_;
}
inline const ::signal_rtc::AudioTranscriptEvent& AudioTranscriptFrame::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::signal_rtc::AudioTranscriptEvent& AudioTranscriptFrame::events(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.AudioTranscriptFrame.events)
  return _internal_events(index);
}
inline ::signal_rtc::AudioTranscriptEvent* AudioTranscriptFrame::_internal_add_events() {
  return events_.Add();
}
inline ::signal_rtc::AudioTranscriptEvent* AudioTranscriptFrame::add_events() {
  // @@protoc_insertion_point(field_add:signal_rtc.AudioTranscriptFrame.events)
  return _internal_add_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::AudioTranscriptEvent >&
AudioTranscriptFrame::events() const {
  // @@protoc_insertion_point(field_list:signal_rtc.AudioTranscriptFrame.events)
  return events_;
}

// -------------------------------------------------------------------

// RemoteVideoUpdateFrame

// repeated .signal_rtc.VideoSubscriptionConfiguration added_or_updated_video_subscriptions = 1;
inline int RemoteVideoUpdateFrame::_internal_added_or_updated_video_subscriptions_size() const {
  return added_or_updated_video_subscriptions_.size();
}
inline int RemoteVideoUpdateFrame::added_or_updated_video_subscriptions_size() const {
  return _internal_added_or_updated_video_subscriptions_size();
}
inline void RemoteVideoUpdateFrame::clear_added_or_updated_video_subscriptions() {
  added_or_updated_video_subscriptions_.Clear();
}
inline ::signal_rtc::VideoSubscriptionConfiguration* RemoteVideoUpdateFrame::mutable_added_or_updated_video_subscriptions(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.RemoteVideoUpdateFrame.added_or_updated_video_subscriptions)
  return added_or_updated_video_subscriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::VideoSubscriptionConfiguration >*
RemoteVideoUpdateFrame::mutable_added_or_updated_video_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.RemoteVideoUpdateFrame.added_or_updated_video_subscriptions)
  return &added_or_updated_video_subscriptions_;
}
inline const ::signal_rtc::VideoSubscriptionConfiguration& RemoteVideoUpdateFrame::_internal_added_or_updated_video_subscriptions(int index) const {
  return added_or_updated_video_subscriptions_.Get(index);
}
inline const ::signal_rtc::VideoSubscriptionConfiguration& RemoteVideoUpdateFrame::added_or_updated_video_subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.RemoteVideoUpdateFrame.added_or_updated_video_subscriptions)
  return _internal_added_or_updated_video_subscriptions(index);
}
inline ::signal_rtc::VideoSubscriptionConfiguration* RemoteVideoUpdateFrame::_internal_add_added_or_updated_video_subscriptions() {
  return added_or_updated_video_subscriptions_.Add();
}
inline ::signal_rtc::VideoSubscriptionConfiguration* RemoteVideoUpdateFrame::add_added_or_updated_video_subscriptions() {
  // @@protoc_insertion_point(field_add:signal_rtc.RemoteVideoUpdateFrame.added_or_updated_video_subscriptions)
  return _internal_add_added_or_updated_video_subscriptions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signal_rtc::VideoSubscriptionConfiguration >&
RemoteVideoUpdateFrame::added_or_updated_video_subscriptions() const {
  // @@protoc_insertion_point(field_list:signal_rtc.RemoteVideoUpdateFrame.added_or_updated_video_subscriptions)
  return added_or_updated_video_subscriptions_;
}

// repeated string removed_video_subscription_mids = 2;
inline int RemoteVideoUpdateFrame::_internal_removed_video_subscription_mids_size() const {
  return removed_video_subscription_mids_.size();
}
inline int RemoteVideoUpdateFrame::removed_video_subscription_mids_size() const {
  return _internal_removed_video_subscription_mids_size();
}
inline void RemoteVideoUpdateFrame::clear_removed_video_subscription_mids() {
  removed_video_subscription_mids_.Clear();
}
inline std::string* RemoteVideoUpdateFrame::add_removed_video_subscription_mids() {
  // @@protoc_insertion_point(field_add_mutable:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  return _internal_add_removed_video_subscription_mids();
}
inline const std::string& RemoteVideoUpdateFrame::_internal_removed_video_subscription_mids(int index) const {
  return removed_video_subscription_mids_.Get(index);
}
inline const std::string& RemoteVideoUpdateFrame::removed_video_subscription_mids(int index) const {
  // @@protoc_insertion_point(field_get:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  return _internal_removed_video_subscription_mids(index);
}
inline std::string* RemoteVideoUpdateFrame::mutable_removed_video_subscription_mids(int index) {
  // @@protoc_insertion_point(field_mutable:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  return removed_video_subscription_mids_.Mutable(index);
}
inline void RemoteVideoUpdateFrame::set_removed_video_subscription_mids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  removed_video_subscription_mids_.Mutable(index)->assign(value);
}
inline void RemoteVideoUpdateFrame::set_removed_video_subscription_mids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  removed_video_subscription_mids_.Mutable(index)->assign(std::move(value));
}
inline void RemoteVideoUpdateFrame::set_removed_video_subscription_mids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removed_video_subscription_mids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline void RemoteVideoUpdateFrame::set_removed_video_subscription_mids(int index, const char* value, size_t size) {
  removed_video_subscription_mids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline std::string* RemoteVideoUpdateFrame::_internal_add_removed_video_subscription_mids() {
  return removed_video_subscription_mids_.Add();
}
inline void RemoteVideoUpdateFrame::add_removed_video_subscription_mids(const std::string& value) {
  removed_video_subscription_mids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline void RemoteVideoUpdateFrame::add_removed_video_subscription_mids(std::string&& value) {
  removed_video_subscription_mids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline void RemoteVideoUpdateFrame::add_removed_video_subscription_mids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removed_video_subscription_mids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline void RemoteVideoUpdateFrame::add_removed_video_subscription_mids(const char* value, size_t size) {
  removed_video_subscription_mids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RemoteVideoUpdateFrame::removed_video_subscription_mids() const {
  // @@protoc_insertion_point(field_list:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  return removed_video_subscription_mids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RemoteVideoUpdateFrame::mutable_removed_video_subscription_mids() {
  // @@protoc_insertion_point(field_mutable_list:signal_rtc.RemoteVideoUpdateFrame.removed_video_subscription_mids)
  return &removed_video_subscription_mids_;
}

// -------------------------------------------------------------------

// VideoSubscriptionConfiguration

// required string mid = 1;
inline bool VideoSubscriptionConfiguration::_internal_has_mid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoSubscriptionConfiguration::has_mid() const {
  return _internal_has_mid();
}
inline void VideoSubscriptionConfiguration::clear_mid() {
  mid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoSubscriptionConfiguration::mid() const {
  // @@protoc_insertion_point(field_get:signal_rtc.VideoSubscriptionConfiguration.mid)
  return _internal_mid();
}
inline void VideoSubscriptionConfiguration::set_mid(const std::string& value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:signal_rtc.VideoSubscriptionConfiguration.mid)
}
inline std::string* VideoSubscriptionConfiguration::mutable_mid() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.VideoSubscriptionConfiguration.mid)
  return _internal_mutable_mid();
}
inline const std::string& VideoSubscriptionConfiguration::_internal_mid() const {
  return mid_.Get();
}
inline void VideoSubscriptionConfiguration::_internal_set_mid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSubscriptionConfiguration::set_mid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  mid_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.VideoSubscriptionConfiguration.mid)
}
inline void VideoSubscriptionConfiguration::set_mid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  mid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.VideoSubscriptionConfiguration.mid)
}
inline void VideoSubscriptionConfiguration::set_mid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  mid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.VideoSubscriptionConfiguration.mid)
}
inline std::string* VideoSubscriptionConfiguration::_internal_mutable_mid() {
  _has_bits_[0] |= 0x00000001u;
  return mid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSubscriptionConfiguration::release_mid() {
  // @@protoc_insertion_point(field_release:signal_rtc.VideoSubscriptionConfiguration.mid)
  if (!_internal_has_mid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return mid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSubscriptionConfiguration::set_allocated_mid(std::string* mid) {
  if (mid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.VideoSubscriptionConfiguration.mid)
}

// optional string attendee_id = 2;
inline bool VideoSubscriptionConfiguration::_internal_has_attendee_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoSubscriptionConfiguration::has_attendee_id() const {
  return _internal_has_attendee_id();
}
inline void VideoSubscriptionConfiguration::clear_attendee_id() {
  attendee_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoSubscriptionConfiguration::attendee_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
  return _internal_attendee_id();
}
inline void VideoSubscriptionConfiguration::set_attendee_id(const std::string& value) {
  _internal_set_attendee_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
}
inline std::string* VideoSubscriptionConfiguration::mutable_attendee_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
  return _internal_mutable_attendee_id();
}
inline const std::string& VideoSubscriptionConfiguration::_internal_attendee_id() const {
  return attendee_id_.Get();
}
inline void VideoSubscriptionConfiguration::_internal_set_attendee_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSubscriptionConfiguration::set_attendee_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  attendee_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
}
inline void VideoSubscriptionConfiguration::set_attendee_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
}
inline void VideoSubscriptionConfiguration::set_attendee_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
}
inline std::string* VideoSubscriptionConfiguration::_internal_mutable_attendee_id() {
  _has_bits_[0] |= 0x00000002u;
  return attendee_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSubscriptionConfiguration::release_attendee_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
  if (!_internal_has_attendee_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return attendee_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSubscriptionConfiguration::set_allocated_attendee_id(std::string* attendee_id) {
  if (attendee_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attendee_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attendee_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.VideoSubscriptionConfiguration.attendee_id)
}

// optional uint32 stream_id = 3;
inline bool VideoSubscriptionConfiguration::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoSubscriptionConfiguration::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void VideoSubscriptionConfiguration::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoSubscriptionConfiguration::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoSubscriptionConfiguration::stream_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.VideoSubscriptionConfiguration.stream_id)
  return _internal_stream_id();
}
inline void VideoSubscriptionConfiguration::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  stream_id_ = value;
}
inline void VideoSubscriptionConfiguration::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.VideoSubscriptionConfiguration.stream_id)
}

// -------------------------------------------------------------------

// PrimaryMeetingJoinFrame

// optional .signal_rtc.MeetingSessionCredentials credentials = 1;
inline bool PrimaryMeetingJoinFrame::_internal_has_credentials() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || credentials_ != nullptr);
  return value;
}
inline bool PrimaryMeetingJoinFrame::has_credentials() const {
  return _internal_has_credentials();
}
inline void PrimaryMeetingJoinFrame::clear_credentials() {
  if (credentials_ != nullptr) credentials_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::signal_rtc::MeetingSessionCredentials& PrimaryMeetingJoinFrame::_internal_credentials() const {
  const ::signal_rtc::MeetingSessionCredentials* p = credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::signal_rtc::MeetingSessionCredentials&>(
      ::signal_rtc::_MeetingSessionCredentials_default_instance_);
}
inline const ::signal_rtc::MeetingSessionCredentials& PrimaryMeetingJoinFrame::credentials() const {
  // @@protoc_insertion_point(field_get:signal_rtc.PrimaryMeetingJoinFrame.credentials)
  return _internal_credentials();
}
inline void PrimaryMeetingJoinFrame::unsafe_arena_set_allocated_credentials(
    ::signal_rtc::MeetingSessionCredentials* credentials) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credentials_);
  }
  credentials_ = credentials;
  if (credentials) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signal_rtc.PrimaryMeetingJoinFrame.credentials)
}
inline ::signal_rtc::MeetingSessionCredentials* PrimaryMeetingJoinFrame::release_credentials() {
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::MeetingSessionCredentials* temp = credentials_;
  credentials_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::signal_rtc::MeetingSessionCredentials* PrimaryMeetingJoinFrame::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:signal_rtc.PrimaryMeetingJoinFrame.credentials)
  _has_bits_[0] &= ~0x00000001u;
  ::signal_rtc::MeetingSessionCredentials* temp = credentials_;
  credentials_ = nullptr;
  return temp;
}
inline ::signal_rtc::MeetingSessionCredentials* PrimaryMeetingJoinFrame::_internal_mutable_credentials() {
  _has_bits_[0] |= 0x00000001u;
  if (credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::signal_rtc::MeetingSessionCredentials>(GetArena());
    credentials_ = p;
  }
  return credentials_;
}
inline ::signal_rtc::MeetingSessionCredentials* PrimaryMeetingJoinFrame::mutable_credentials() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.PrimaryMeetingJoinFrame.credentials)
  return _internal_mutable_credentials();
}
inline void PrimaryMeetingJoinFrame::set_allocated_credentials(::signal_rtc::MeetingSessionCredentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete credentials_;
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.PrimaryMeetingJoinFrame.credentials)
}

// -------------------------------------------------------------------

// PrimaryMeetingJoinAckFrame

// optional string attendee_id = 1;
inline bool PrimaryMeetingJoinAckFrame::_internal_has_attendee_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrimaryMeetingJoinAckFrame::has_attendee_id() const {
  return _internal_has_attendee_id();
}
inline void PrimaryMeetingJoinAckFrame::clear_attendee_id() {
  attendee_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrimaryMeetingJoinAckFrame::attendee_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
  return _internal_attendee_id();
}
inline void PrimaryMeetingJoinAckFrame::set_attendee_id(const std::string& value) {
  _internal_set_attendee_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
}
inline std::string* PrimaryMeetingJoinAckFrame::mutable_attendee_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
  return _internal_mutable_attendee_id();
}
inline const std::string& PrimaryMeetingJoinAckFrame::_internal_attendee_id() const {
  return attendee_id_.Get();
}
inline void PrimaryMeetingJoinAckFrame::_internal_set_attendee_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PrimaryMeetingJoinAckFrame::set_attendee_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
}
inline void PrimaryMeetingJoinAckFrame::set_attendee_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
}
inline void PrimaryMeetingJoinAckFrame::set_attendee_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
}
inline std::string* PrimaryMeetingJoinAckFrame::_internal_mutable_attendee_id() {
  _has_bits_[0] |= 0x00000001u;
  return attendee_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PrimaryMeetingJoinAckFrame::release_attendee_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
  if (!_internal_has_attendee_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return attendee_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PrimaryMeetingJoinAckFrame::set_allocated_attendee_id(std::string* attendee_id) {
  if (attendee_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  attendee_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attendee_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.PrimaryMeetingJoinAckFrame.attendee_id)
}

// -------------------------------------------------------------------

// PrimaryMeetingLeaveFrame

// -------------------------------------------------------------------

// BridgeReserveFrame

// optional .signal_rtc.BridgeReserveFrame.ReservationType type = 1;
inline bool BridgeReserveFrame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BridgeReserveFrame::has_type() const {
  return _internal_has_type();
}
inline void BridgeReserveFrame::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::signal_rtc::BridgeReserveFrame_ReservationType BridgeReserveFrame::_internal_type() const {
  return static_cast< ::signal_rtc::BridgeReserveFrame_ReservationType >(type_);
}
inline ::signal_rtc::BridgeReserveFrame_ReservationType BridgeReserveFrame::type() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeReserveFrame.type)
  return _internal_type();
}
inline void BridgeReserveFrame::_internal_set_type(::signal_rtc::BridgeReserveFrame_ReservationType value) {
  assert(::signal_rtc::BridgeReserveFrame_ReservationType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void BridgeReserveFrame::set_type(::signal_rtc::BridgeReserveFrame_ReservationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeReserveFrame.type)
}

// optional .signal_rtc.BridgeReserveFrame.Action action = 2;
inline bool BridgeReserveFrame::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BridgeReserveFrame::has_action() const {
  return _internal_has_action();
}
inline void BridgeReserveFrame::clear_action() {
  action_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::signal_rtc::BridgeReserveFrame_Action BridgeReserveFrame::_internal_action() const {
  return static_cast< ::signal_rtc::BridgeReserveFrame_Action >(action_);
}
inline ::signal_rtc::BridgeReserveFrame_Action BridgeReserveFrame::action() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeReserveFrame.action)
  return _internal_action();
}
inline void BridgeReserveFrame::_internal_set_action(::signal_rtc::BridgeReserveFrame_Action value) {
  assert(::signal_rtc::BridgeReserveFrame_Action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  action_ = value;
}
inline void BridgeReserveFrame::set_action(::signal_rtc::BridgeReserveFrame_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeReserveFrame.action)
}

// optional string client_request_token = 3;
inline bool BridgeReserveFrame::_internal_has_client_request_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BridgeReserveFrame::has_client_request_token() const {
  return _internal_has_client_request_token();
}
inline void BridgeReserveFrame::clear_client_request_token() {
  client_request_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BridgeReserveFrame::client_request_token() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeReserveFrame.client_request_token)
  return _internal_client_request_token();
}
inline void BridgeReserveFrame::set_client_request_token(const std::string& value) {
  _internal_set_client_request_token(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeReserveFrame.client_request_token)
}
inline std::string* BridgeReserveFrame::mutable_client_request_token() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BridgeReserveFrame.client_request_token)
  return _internal_mutable_client_request_token();
}
inline const std::string& BridgeReserveFrame::_internal_client_request_token() const {
  return client_request_token_.Get();
}
inline void BridgeReserveFrame::_internal_set_client_request_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BridgeReserveFrame::set_client_request_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.BridgeReserveFrame.client_request_token)
}
inline void BridgeReserveFrame::set_client_request_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.BridgeReserveFrame.client_request_token)
}
inline void BridgeReserveFrame::set_client_request_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.BridgeReserveFrame.client_request_token)
}
inline std::string* BridgeReserveFrame::_internal_mutable_client_request_token() {
  _has_bits_[0] |= 0x00000001u;
  return client_request_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BridgeReserveFrame::release_client_request_token() {
  // @@protoc_insertion_point(field_release:signal_rtc.BridgeReserveFrame.client_request_token)
  if (!_internal_has_client_request_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_request_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeReserveFrame::set_allocated_client_request_token(std::string* client_request_token) {
  if (client_request_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_request_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_request_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.BridgeReserveFrame.client_request_token)
}

// -------------------------------------------------------------------

// BridgeReserveAckFrame

// optional string client_request_token = 1;
inline bool BridgeReserveAckFrame::_internal_has_client_request_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BridgeReserveAckFrame::has_client_request_token() const {
  return _internal_has_client_request_token();
}
inline void BridgeReserveAckFrame::clear_client_request_token() {
  client_request_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BridgeReserveAckFrame::client_request_token() const {
  // @@protoc_insertion_point(field_get:signal_rtc.BridgeReserveAckFrame.client_request_token)
  return _internal_client_request_token();
}
inline void BridgeReserveAckFrame::set_client_request_token(const std::string& value) {
  _internal_set_client_request_token(value);
  // @@protoc_insertion_point(field_set:signal_rtc.BridgeReserveAckFrame.client_request_token)
}
inline std::string* BridgeReserveAckFrame::mutable_client_request_token() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.BridgeReserveAckFrame.client_request_token)
  return _internal_mutable_client_request_token();
}
inline const std::string& BridgeReserveAckFrame::_internal_client_request_token() const {
  return client_request_token_.Get();
}
inline void BridgeReserveAckFrame::_internal_set_client_request_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BridgeReserveAckFrame::set_client_request_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.BridgeReserveAckFrame.client_request_token)
}
inline void BridgeReserveAckFrame::set_client_request_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.BridgeReserveAckFrame.client_request_token)
}
inline void BridgeReserveAckFrame::set_client_request_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.BridgeReserveAckFrame.client_request_token)
}
inline std::string* BridgeReserveAckFrame::_internal_mutable_client_request_token() {
  _has_bits_[0] |= 0x00000001u;
  return client_request_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BridgeReserveAckFrame::release_client_request_token() {
  // @@protoc_insertion_point(field_release:signal_rtc.BridgeReserveAckFrame.client_request_token)
  if (!_internal_has_client_request_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_request_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BridgeReserveAckFrame::set_allocated_client_request_token(std::string* client_request_token) {
  if (client_request_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_request_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_request_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.BridgeReserveAckFrame.client_request_token)
}

// -------------------------------------------------------------------

// MeetingSessionCredentials

// optional string attendee_id = 1;
inline bool MeetingSessionCredentials::_internal_has_attendee_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MeetingSessionCredentials::has_attendee_id() const {
  return _internal_has_attendee_id();
}
inline void MeetingSessionCredentials::clear_attendee_id() {
  attendee_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MeetingSessionCredentials::attendee_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingSessionCredentials.attendee_id)
  return _internal_attendee_id();
}
inline void MeetingSessionCredentials::set_attendee_id(const std::string& value) {
  _internal_set_attendee_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingSessionCredentials.attendee_id)
}
inline std::string* MeetingSessionCredentials::mutable_attendee_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingSessionCredentials.attendee_id)
  return _internal_mutable_attendee_id();
}
inline const std::string& MeetingSessionCredentials::_internal_attendee_id() const {
  return attendee_id_.Get();
}
inline void MeetingSessionCredentials::_internal_set_attendee_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingSessionCredentials::set_attendee_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingSessionCredentials.attendee_id)
}
inline void MeetingSessionCredentials::set_attendee_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingSessionCredentials.attendee_id)
}
inline void MeetingSessionCredentials::set_attendee_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingSessionCredentials.attendee_id)
}
inline std::string* MeetingSessionCredentials::_internal_mutable_attendee_id() {
  _has_bits_[0] |= 0x00000001u;
  return attendee_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingSessionCredentials::release_attendee_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingSessionCredentials.attendee_id)
  if (!_internal_has_attendee_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return attendee_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingSessionCredentials::set_allocated_attendee_id(std::string* attendee_id) {
  if (attendee_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  attendee_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attendee_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingSessionCredentials.attendee_id)
}

// optional string external_user_id = 2;
inline bool MeetingSessionCredentials::_internal_has_external_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MeetingSessionCredentials::has_external_user_id() const {
  return _internal_has_external_user_id();
}
inline void MeetingSessionCredentials::clear_external_user_id() {
  external_user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MeetingSessionCredentials::external_user_id() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingSessionCredentials.external_user_id)
  return _internal_external_user_id();
}
inline void MeetingSessionCredentials::set_external_user_id(const std::string& value) {
  _internal_set_external_user_id(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingSessionCredentials.external_user_id)
}
inline std::string* MeetingSessionCredentials::mutable_external_user_id() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingSessionCredentials.external_user_id)
  return _internal_mutable_external_user_id();
}
inline const std::string& MeetingSessionCredentials::_internal_external_user_id() const {
  return external_user_id_.Get();
}
inline void MeetingSessionCredentials::_internal_set_external_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingSessionCredentials::set_external_user_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingSessionCredentials.external_user_id)
}
inline void MeetingSessionCredentials::set_external_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingSessionCredentials.external_user_id)
}
inline void MeetingSessionCredentials::set_external_user_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingSessionCredentials.external_user_id)
}
inline std::string* MeetingSessionCredentials::_internal_mutable_external_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return external_user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingSessionCredentials::release_external_user_id() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingSessionCredentials.external_user_id)
  if (!_internal_has_external_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return external_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingSessionCredentials::set_allocated_external_user_id(std::string* external_user_id) {
  if (external_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), external_user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingSessionCredentials.external_user_id)
}

// optional string join_token = 3;
inline bool MeetingSessionCredentials::_internal_has_join_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MeetingSessionCredentials::has_join_token() const {
  return _internal_has_join_token();
}
inline void MeetingSessionCredentials::clear_join_token() {
  join_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MeetingSessionCredentials::join_token() const {
  // @@protoc_insertion_point(field_get:signal_rtc.MeetingSessionCredentials.join_token)
  return _internal_join_token();
}
inline void MeetingSessionCredentials::set_join_token(const std::string& value) {
  _internal_set_join_token(value);
  // @@protoc_insertion_point(field_set:signal_rtc.MeetingSessionCredentials.join_token)
}
inline std::string* MeetingSessionCredentials::mutable_join_token() {
  // @@protoc_insertion_point(field_mutable:signal_rtc.MeetingSessionCredentials.join_token)
  return _internal_mutable_join_token();
}
inline const std::string& MeetingSessionCredentials::_internal_join_token() const {
  return join_token_.Get();
}
inline void MeetingSessionCredentials::_internal_set_join_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  join_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MeetingSessionCredentials::set_join_token(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  join_token_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:signal_rtc.MeetingSessionCredentials.join_token)
}
inline void MeetingSessionCredentials::set_join_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  join_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:signal_rtc.MeetingSessionCredentials.join_token)
}
inline void MeetingSessionCredentials::set_join_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  join_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:signal_rtc.MeetingSessionCredentials.join_token)
}
inline std::string* MeetingSessionCredentials::_internal_mutable_join_token() {
  _has_bits_[0] |= 0x00000004u;
  return join_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MeetingSessionCredentials::release_join_token() {
  // @@protoc_insertion_point(field_release:signal_rtc.MeetingSessionCredentials.join_token)
  if (!_internal_has_join_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return join_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeetingSessionCredentials::set_allocated_join_token(std::string* join_token) {
  if (join_token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  join_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), join_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.MeetingSessionCredentials.join_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace signal_rtc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::signal_rtc::SignalFrame_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::Metric_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::AudioTranscriptItem_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::MeetingTranscriptionStatus_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::BridgeReserveFrame_ReservationType> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::BridgeReserveFrame_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::JoinFlags> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::StreamServiceType> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::StreamMediaType> : ::std::true_type {};
template <> struct is_proto_enum< ::signal_rtc::PingPongType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_video_5fcontrol_2eproto
