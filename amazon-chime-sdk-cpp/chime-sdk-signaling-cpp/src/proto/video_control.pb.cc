// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video_control.proto

#include "video_control.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioControlFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioMetadataFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioProfileState_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioStatusFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioStreamIdInfo_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscript_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioTranscriptEntity_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_AudioTranscriptEvent_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscriptFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioTranscriptItem_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscriptResult_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Bitrate_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BitrateFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeJoinFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeReserveFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientDetails_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientMetricFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DataMessageFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DataMessagePayload_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ErrorFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IndexFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_JoinAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_JoinFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaveAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaveFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MeetingSessionCredentials_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Metric_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PauseResumeFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PingPongFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamAllocation_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamDescriptor_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StreamMetricFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SubscribeAckFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SubscribeFrame_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackMapping_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TurnCredentials_video_5fcontrol_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_video_5fcontrol_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto;
namespace signal_rtc {
class SignalFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SignalFrame> _instance;
} _SignalFrame_default_instance_;
class ErrorFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ErrorFrame> _instance;
} _ErrorFrame_default_instance_;
class ClientDetailsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientDetails> _instance;
} _ClientDetails_default_instance_;
class JoinFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<JoinFrame> _instance;
} _JoinFrame_default_instance_;
class JoinAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<JoinAckFrame> _instance;
} _JoinAckFrame_default_instance_;
class BridgeJoinFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BridgeJoinFrame> _instance;
} _BridgeJoinFrame_default_instance_;
class BridgeJoinAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BridgeJoinAckFrame> _instance;
} _BridgeJoinAckFrame_default_instance_;
class LeaveFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LeaveFrame> _instance;
} _LeaveFrame_default_instance_;
class LeaveAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LeaveAckFrame> _instance;
} _LeaveAckFrame_default_instance_;
class SubscribeFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SubscribeFrame> _instance;
} _SubscribeFrame_default_instance_;
class SubscribeAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SubscribeAckFrame> _instance;
} _SubscribeAckFrame_default_instance_;
class IndexFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IndexFrame> _instance;
} _IndexFrame_default_instance_;
class PauseResumeFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PauseResumeFrame> _instance;
} _PauseResumeFrame_default_instance_;
class BitrateFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BitrateFrame> _instance;
} _BitrateFrame_default_instance_;
class StreamDescriptorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StreamDescriptor> _instance;
} _StreamDescriptor_default_instance_;
class StreamAllocationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StreamAllocation> _instance;
} _StreamAllocation_default_instance_;
class TrackMappingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrackMapping> _instance;
} _TrackMapping_default_instance_;
class BitrateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Bitrate> _instance;
} _Bitrate_default_instance_;
class AudioControlFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioControlFrame> _instance;
} _AudioControlFrame_default_instance_;
class AudioMetadataFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioMetadataFrame> _instance;
} _AudioMetadataFrame_default_instance_;
class AudioProfileStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioProfileState> _instance;
} _AudioProfileState_default_instance_;
class AudioStreamIdInfoFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioStreamIdInfoFrame> _instance;
} _AudioStreamIdInfoFrame_default_instance_;
class AudioStreamIdInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioStreamIdInfo> _instance;
} _AudioStreamIdInfo_default_instance_;
class PingPongFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PingPongFrame> _instance;
} _PingPongFrame_default_instance_;
class AudioStatusFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioStatusFrame> _instance;
} _AudioStatusFrame_default_instance_;
class MetricDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Metric> _instance;
} _Metric_default_instance_;
class StreamMetricFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StreamMetricFrame> _instance;
} _StreamMetricFrame_default_instance_;
class ClientMetricFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientMetricFrame> _instance;
} _ClientMetricFrame_default_instance_;
class DataMessageFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DataMessageFrame> _instance;
} _DataMessageFrame_default_instance_;
class DataMessagePayloadDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DataMessagePayload> _instance;
} _DataMessagePayload_default_instance_;
class TurnCredentialsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TurnCredentials> _instance;
} _TurnCredentials_default_instance_;
class AudioTranscriptItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptItem> _instance;
} _AudioTranscriptItem_default_instance_;
class AudioTranscriptEntityDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptEntity> _instance;
} _AudioTranscriptEntity_default_instance_;
class AudioTranscriptAlternativeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptAlternative> _instance;
} _AudioTranscriptAlternative_default_instance_;
class AudioTranscriptResultDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptResult> _instance;
} _AudioTranscriptResult_default_instance_;
class AudioTranscriptDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscript> _instance;
} _AudioTranscript_default_instance_;
class MeetingTranscriptionStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MeetingTranscriptionStatus> _instance;
} _MeetingTranscriptionStatus_default_instance_;
class AudioTranscriptEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptEvent> _instance;
} _AudioTranscriptEvent_default_instance_;
class AudioTranscriptFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AudioTranscriptFrame> _instance;
} _AudioTranscriptFrame_default_instance_;
class RemoteVideoUpdateFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RemoteVideoUpdateFrame> _instance;
} _RemoteVideoUpdateFrame_default_instance_;
class VideoSubscriptionConfigurationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VideoSubscriptionConfiguration> _instance;
} _VideoSubscriptionConfiguration_default_instance_;
class PrimaryMeetingJoinFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PrimaryMeetingJoinFrame> _instance;
} _PrimaryMeetingJoinFrame_default_instance_;
class PrimaryMeetingJoinAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PrimaryMeetingJoinAckFrame> _instance;
} _PrimaryMeetingJoinAckFrame_default_instance_;
class PrimaryMeetingLeaveFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PrimaryMeetingLeaveFrame> _instance;
} _PrimaryMeetingLeaveFrame_default_instance_;
class BridgeReserveFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BridgeReserveFrame> _instance;
} _BridgeReserveFrame_default_instance_;
class BridgeReserveAckFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BridgeReserveAckFrame> _instance;
} _BridgeReserveAckFrame_default_instance_;
class MeetingSessionCredentialsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MeetingSessionCredentials> _instance;
} _MeetingSessionCredentials_default_instance_;
}  // namespace signal_rtc
static void InitDefaultsscc_info_AudioControlFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioControlFrame_default_instance_;
    new (ptr) ::signal_rtc::AudioControlFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioControlFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioControlFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioMetadataFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioMetadataFrame_default_instance_;
    new (ptr) ::signal_rtc::AudioMetadataFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioMetadataFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AudioMetadataFrame_video_5fcontrol_2eproto}, {
      &scc_info_AudioProfileState_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioProfileState_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioProfileState_default_instance_;
    new (ptr) ::signal_rtc::AudioProfileState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioProfileState_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioProfileState_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioStatusFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioStatusFrame_default_instance_;
    new (ptr) ::signal_rtc::AudioStatusFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioStatusFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioStatusFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioStreamIdInfo_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioStreamIdInfo_default_instance_;
    new (ptr) ::signal_rtc::AudioStreamIdInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioStreamIdInfo_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioStreamIdInfo_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioStreamIdInfoFrame_default_instance_;
    new (ptr) ::signal_rtc::AudioStreamIdInfoFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto}, {
      &scc_info_AudioStreamIdInfo_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioTranscript_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscript_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscript();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscript_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AudioTranscript_video_5fcontrol_2eproto}, {
      &scc_info_AudioTranscriptResult_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptAlternative_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptAlternative();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto}, {
      &scc_info_AudioTranscriptItem_video_5fcontrol_2eproto.base,
      &scc_info_AudioTranscriptEntity_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioTranscriptEntity_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptEntity_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptEntity();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioTranscriptEntity_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioTranscriptEntity_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioTranscriptEvent_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptEvent_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_AudioTranscriptEvent_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_AudioTranscriptEvent_video_5fcontrol_2eproto}, {
      &scc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto.base,
      &scc_info_AudioTranscript_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioTranscriptFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptFrame_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscriptFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AudioTranscriptFrame_video_5fcontrol_2eproto}, {
      &scc_info_AudioTranscriptEvent_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_AudioTranscriptItem_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptItem_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AudioTranscriptItem_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AudioTranscriptItem_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_AudioTranscriptResult_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_AudioTranscriptResult_default_instance_;
    new (ptr) ::signal_rtc::AudioTranscriptResult();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AudioTranscriptResult_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AudioTranscriptResult_video_5fcontrol_2eproto}, {
      &scc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_Bitrate_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_Bitrate_default_instance_;
    new (ptr) ::signal_rtc::Bitrate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Bitrate_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Bitrate_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_BitrateFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_BitrateFrame_default_instance_;
    new (ptr) ::signal_rtc::BitrateFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BitrateFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_BitrateFrame_video_5fcontrol_2eproto}, {
      &scc_info_Bitrate_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_BridgeJoinAckFrame_default_instance_;
    new (ptr) ::signal_rtc::BridgeJoinAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto}, {
      &scc_info_TurnCredentials_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_BridgeJoinFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_BridgeJoinFrame_default_instance_;
    new (ptr) ::signal_rtc::BridgeJoinFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeJoinFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BridgeJoinFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_BridgeReserveAckFrame_default_instance_;
    new (ptr) ::signal_rtc::BridgeReserveAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_BridgeReserveFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_BridgeReserveFrame_default_instance_;
    new (ptr) ::signal_rtc::BridgeReserveFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BridgeReserveFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BridgeReserveFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_ClientDetails_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_ClientDetails_default_instance_;
    new (ptr) ::signal_rtc::ClientDetails();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientDetails_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ClientDetails_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_ClientMetricFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_ClientMetricFrame_default_instance_;
    new (ptr) ::signal_rtc::ClientMetricFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ClientMetricFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ClientMetricFrame_video_5fcontrol_2eproto}, {
      &scc_info_Metric_video_5fcontrol_2eproto.base,
      &scc_info_StreamMetricFrame_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_DataMessageFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_DataMessageFrame_default_instance_;
    new (ptr) ::signal_rtc::DataMessageFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DataMessageFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_DataMessageFrame_video_5fcontrol_2eproto}, {
      &scc_info_DataMessagePayload_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_DataMessagePayload_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_DataMessagePayload_default_instance_;
    new (ptr) ::signal_rtc::DataMessagePayload();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DataMessagePayload_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DataMessagePayload_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_ErrorFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_ErrorFrame_default_instance_;
    new (ptr) ::signal_rtc::ErrorFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ErrorFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ErrorFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_IndexFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_IndexFrame_default_instance_;
    new (ptr) ::signal_rtc::IndexFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IndexFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_IndexFrame_video_5fcontrol_2eproto}, {
      &scc_info_StreamDescriptor_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_JoinAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_JoinAckFrame_default_instance_;
    new (ptr) ::signal_rtc::JoinAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_JoinAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_JoinAckFrame_video_5fcontrol_2eproto}, {
      &scc_info_TurnCredentials_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_JoinFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_JoinFrame_default_instance_;
    new (ptr) ::signal_rtc::JoinFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_JoinFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_JoinFrame_video_5fcontrol_2eproto}, {
      &scc_info_ClientDetails_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_LeaveAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_LeaveAckFrame_default_instance_;
    new (ptr) ::signal_rtc::LeaveAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaveAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LeaveAckFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_LeaveFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_LeaveFrame_default_instance_;
    new (ptr) ::signal_rtc::LeaveFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaveFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LeaveFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_MeetingSessionCredentials_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_MeetingSessionCredentials_default_instance_;
    new (ptr) ::signal_rtc::MeetingSessionCredentials();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MeetingSessionCredentials_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MeetingSessionCredentials_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_MeetingTranscriptionStatus_default_instance_;
    new (ptr) ::signal_rtc::MeetingTranscriptionStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_Metric_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_Metric_default_instance_;
    new (ptr) ::signal_rtc::Metric();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Metric_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Metric_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_PauseResumeFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_PauseResumeFrame_default_instance_;
    new (ptr) ::signal_rtc::PauseResumeFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PauseResumeFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PauseResumeFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_PingPongFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_PingPongFrame_default_instance_;
    new (ptr) ::signal_rtc::PingPongFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PingPongFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PingPongFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_PrimaryMeetingJoinAckFrame_default_instance_;
    new (ptr) ::signal_rtc::PrimaryMeetingJoinAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_PrimaryMeetingJoinFrame_default_instance_;
    new (ptr) ::signal_rtc::PrimaryMeetingJoinFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto}, {
      &scc_info_MeetingSessionCredentials_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_PrimaryMeetingLeaveFrame_default_instance_;
    new (ptr) ::signal_rtc::PrimaryMeetingLeaveFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_RemoteVideoUpdateFrame_default_instance_;
    new (ptr) ::signal_rtc::RemoteVideoUpdateFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto}, {
      &scc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_SignalFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_SignalFrame_default_instance_;
    new (ptr) ::signal_rtc::SignalFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<26> scc_info_SignalFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 26, 0, InitDefaultsscc_info_SignalFrame_video_5fcontrol_2eproto}, {
      &scc_info_ErrorFrame_video_5fcontrol_2eproto.base,
      &scc_info_JoinFrame_video_5fcontrol_2eproto.base,
      &scc_info_JoinAckFrame_video_5fcontrol_2eproto.base,
      &scc_info_SubscribeFrame_video_5fcontrol_2eproto.base,
      &scc_info_SubscribeAckFrame_video_5fcontrol_2eproto.base,
      &scc_info_IndexFrame_video_5fcontrol_2eproto.base,
      &scc_info_PauseResumeFrame_video_5fcontrol_2eproto.base,
      &scc_info_LeaveFrame_video_5fcontrol_2eproto.base,
      &scc_info_LeaveAckFrame_video_5fcontrol_2eproto.base,
      &scc_info_BitrateFrame_video_5fcontrol_2eproto.base,
      &scc_info_AudioControlFrame_video_5fcontrol_2eproto.base,
      &scc_info_AudioMetadataFrame_video_5fcontrol_2eproto.base,
      &scc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto.base,
      &scc_info_PingPongFrame_video_5fcontrol_2eproto.base,
      &scc_info_AudioStatusFrame_video_5fcontrol_2eproto.base,
      &scc_info_ClientMetricFrame_video_5fcontrol_2eproto.base,
      &scc_info_DataMessageFrame_video_5fcontrol_2eproto.base,
      &scc_info_AudioTranscriptFrame_video_5fcontrol_2eproto.base,
      &scc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto.base,
      &scc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto.base,
      &scc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto.base,
      &scc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto.base,
      &scc_info_BridgeJoinFrame_video_5fcontrol_2eproto.base,
      &scc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto.base,
      &scc_info_BridgeReserveFrame_video_5fcontrol_2eproto.base,
      &scc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_StreamAllocation_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_StreamAllocation_default_instance_;
    new (ptr) ::signal_rtc::StreamAllocation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamAllocation_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StreamAllocation_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_StreamDescriptor_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_StreamDescriptor_default_instance_;
    new (ptr) ::signal_rtc::StreamDescriptor();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamDescriptor_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StreamDescriptor_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_StreamMetricFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_StreamMetricFrame_default_instance_;
    new (ptr) ::signal_rtc::StreamMetricFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StreamMetricFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StreamMetricFrame_video_5fcontrol_2eproto}, {
      &scc_info_Metric_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_SubscribeAckFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_SubscribeAckFrame_default_instance_;
    new (ptr) ::signal_rtc::SubscribeAckFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SubscribeAckFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_SubscribeAckFrame_video_5fcontrol_2eproto}, {
      &scc_info_StreamAllocation_video_5fcontrol_2eproto.base,
      &scc_info_TrackMapping_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_SubscribeFrame_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_SubscribeFrame_default_instance_;
    new (ptr) ::signal_rtc::SubscribeFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SubscribeFrame_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_SubscribeFrame_video_5fcontrol_2eproto}, {
      &scc_info_StreamDescriptor_video_5fcontrol_2eproto.base,}};

static void InitDefaultsscc_info_TrackMapping_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_TrackMapping_default_instance_;
    new (ptr) ::signal_rtc::TrackMapping();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TrackMapping_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TrackMapping_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_TurnCredentials_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_TurnCredentials_default_instance_;
    new (ptr) ::signal_rtc::TurnCredentials();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TurnCredentials_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TurnCredentials_video_5fcontrol_2eproto}, {}};

static void InitDefaultsscc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::signal_rtc::_VideoSubscriptionConfiguration_default_instance_;
    new (ptr) ::signal_rtc::VideoSubscriptionConfiguration();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto}, {}};

namespace signal_rtc {
bool SignalFrame_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SignalFrame_Type_strings[26] = {};

static const char SignalFrame_Type_names[] =
  "AUDIO_CONTROL"
  "AUDIO_METADATA"
  "AUDIO_STATUS"
  "AUDIO_STREAM_ID_INFO"
  "AUDIO_TRANSCRIPT"
  "BITRATES"
  "BRIDGE_JOIN"
  "BRIDGE_JOIN_ACK"
  "BRIDGE_RESERVE"
  "BRIDGE_RESERVE_ACK"
  "CLIENT_METRIC"
  "DATA_MESSAGE"
  "INDEX"
  "JOIN"
  "JOIN_ACK"
  "LEAVE"
  "LEAVE_ACK"
  "PAUSE"
  "PING_PONG"
  "PRIMARY_MEETING_JOIN"
  "PRIMARY_MEETING_JOIN_ACK"
  "PRIMARY_MEETING_LEAVE"
  "REMOTE_VIDEO_UPDATE"
  "RESUME"
  "SUBSCRIBE"
  "SUBSCRIBE_ACK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SignalFrame_Type_entries[] = {
  { {SignalFrame_Type_names + 0, 13}, 16 },
  { {SignalFrame_Type_names + 13, 14}, 17 },
  { {SignalFrame_Type_names + 27, 12}, 20 },
  { {SignalFrame_Type_names + 39, 20}, 18 },
  { {SignalFrame_Type_names + 59, 16}, 23 },
  { {SignalFrame_Type_names + 75, 8}, 13 },
  { {SignalFrame_Type_names + 83, 11}, 28 },
  { {SignalFrame_Type_names + 94, 15}, 29 },
  { {SignalFrame_Type_names + 109, 14}, 30 },
  { {SignalFrame_Type_names + 123, 18}, 31 },
  { {SignalFrame_Type_names + 141, 13}, 21 },
  { {SignalFrame_Type_names + 154, 12}, 22 },
  { {SignalFrame_Type_names + 166, 5}, 5 },
  { {SignalFrame_Type_names + 171, 4}, 1 },
  { {SignalFrame_Type_names + 175, 8}, 2 },
  { {SignalFrame_Type_names + 183, 5}, 9 },
  { {SignalFrame_Type_names + 188, 9}, 10 },
  { {SignalFrame_Type_names + 197, 5}, 7 },
  { {SignalFrame_Type_names + 202, 9}, 19 },
  { {SignalFrame_Type_names + 211, 20}, 25 },
  { {SignalFrame_Type_names + 231, 24}, 26 },
  { {SignalFrame_Type_names + 255, 21}, 27 },
  { {SignalFrame_Type_names + 276, 19}, 24 },
  { {SignalFrame_Type_names + 295, 6}, 8 },
  { {SignalFrame_Type_names + 301, 9}, 3 },
  { {SignalFrame_Type_names + 310, 13}, 4 },
};

static const int SignalFrame_Type_entries_by_number[] = {
  13, // 1 -> JOIN
  14, // 2 -> JOIN_ACK
  24, // 3 -> SUBSCRIBE
  25, // 4 -> SUBSCRIBE_ACK
  12, // 5 -> INDEX
  17, // 7 -> PAUSE
  23, // 8 -> RESUME
  15, // 9 -> LEAVE
  16, // 10 -> LEAVE_ACK
  5, // 13 -> BITRATES
  0, // 16 -> AUDIO_CONTROL
  1, // 17 -> AUDIO_METADATA
  3, // 18 -> AUDIO_STREAM_ID_INFO
  18, // 19 -> PING_PONG
  2, // 20 -> AUDIO_STATUS
  10, // 21 -> CLIENT_METRIC
  11, // 22 -> DATA_MESSAGE
  4, // 23 -> AUDIO_TRANSCRIPT
  22, // 24 -> REMOTE_VIDEO_UPDATE
  19, // 25 -> PRIMARY_MEETING_JOIN
  20, // 26 -> PRIMARY_MEETING_JOIN_ACK
  21, // 27 -> PRIMARY_MEETING_LEAVE
  6, // 28 -> BRIDGE_JOIN
  7, // 29 -> BRIDGE_JOIN_ACK
  8, // 30 -> BRIDGE_RESERVE
  9, // 31 -> BRIDGE_RESERVE_ACK
};

const std::string& SignalFrame_Type_Name(
    SignalFrame_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SignalFrame_Type_entries,
          SignalFrame_Type_entries_by_number,
          26, SignalFrame_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SignalFrame_Type_entries,
      SignalFrame_Type_entries_by_number,
      26, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SignalFrame_Type_strings[idx].get();
}
bool SignalFrame_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalFrame_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SignalFrame_Type_entries, 26, name, &int_value);
  if (success) {
    *value = static_cast<SignalFrame_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SignalFrame_Type SignalFrame::JOIN;
constexpr SignalFrame_Type SignalFrame::JOIN_ACK;
constexpr SignalFrame_Type SignalFrame::SUBSCRIBE;
constexpr SignalFrame_Type SignalFrame::SUBSCRIBE_ACK;
constexpr SignalFrame_Type SignalFrame::INDEX;
constexpr SignalFrame_Type SignalFrame::PAUSE;
constexpr SignalFrame_Type SignalFrame::RESUME;
constexpr SignalFrame_Type SignalFrame::LEAVE;
constexpr SignalFrame_Type SignalFrame::LEAVE_ACK;
constexpr SignalFrame_Type SignalFrame::BITRATES;
constexpr SignalFrame_Type SignalFrame::AUDIO_CONTROL;
constexpr SignalFrame_Type SignalFrame::AUDIO_METADATA;
constexpr SignalFrame_Type SignalFrame::AUDIO_STREAM_ID_INFO;
constexpr SignalFrame_Type SignalFrame::PING_PONG;
constexpr SignalFrame_Type SignalFrame::AUDIO_STATUS;
constexpr SignalFrame_Type SignalFrame::CLIENT_METRIC;
constexpr SignalFrame_Type SignalFrame::DATA_MESSAGE;
constexpr SignalFrame_Type SignalFrame::AUDIO_TRANSCRIPT;
constexpr SignalFrame_Type SignalFrame::REMOTE_VIDEO_UPDATE;
constexpr SignalFrame_Type SignalFrame::PRIMARY_MEETING_JOIN;
constexpr SignalFrame_Type SignalFrame::PRIMARY_MEETING_JOIN_ACK;
constexpr SignalFrame_Type SignalFrame::PRIMARY_MEETING_LEAVE;
constexpr SignalFrame_Type SignalFrame::BRIDGE_JOIN;
constexpr SignalFrame_Type SignalFrame::BRIDGE_JOIN_ACK;
constexpr SignalFrame_Type SignalFrame::BRIDGE_RESERVE;
constexpr SignalFrame_Type SignalFrame::BRIDGE_RESERVE_ACK;
constexpr SignalFrame_Type SignalFrame::Type_MIN;
constexpr SignalFrame_Type SignalFrame::Type_MAX;
constexpr int SignalFrame::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Metric_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 54:
    case 55:
    case 56:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Metric_Type_strings[83] = {};

static const char Metric_Type_names[] =
  "PROCESS_CPU"
  "RTC_MIC_BITRATE"
  "RTC_MIC_FRACTION_PACKET_LOST_PERCENT"
  "RTC_MIC_JITTER_MS"
  "RTC_MIC_PPS"
  "RTC_MIC_RTT_MS"
  "RTC_SPK_BITRATE"
  "RTC_SPK_CURRENT_DELAY_MS"
  "RTC_SPK_FRACTION_DECODER_LOSS_PERCENT"
  "RTC_SPK_FRACTION_PACKET_LOST_PERCENT"
  "RTC_SPK_JITTER_BUFFER_MS"
  "RTC_SPK_JITTER_MS"
  "RTC_SPK_PPS"
  "SOCKET_DISCARDED_PPS"
  "STUN_RTT_MS"
  "TOTAL_CPU"
  "VIDEO_ACTUAL_ENCODER_BITRATE"
  "VIDEO_ACTUAL_SUBSCRIBED_BITRATE"
  "VIDEO_AVAILABLE_RECEIVE_BANDWIDTH"
  "VIDEO_AVAILABLE_SEND_BANDWIDTH"
  "VIDEO_AVERAGE_ENCODE_MS"
  "VIDEO_BUCKET_DELAY_MS"
  "VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS"
  "VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY"
  "VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY"
  "VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION"
  "VIDEO_CAPTURER_ADAPTER_FRAME_DROPS"
  "VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS"
  "VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY"
  "VIDEO_CAPTURER_ADAPTER_SIGMA"
  "VIDEO_CURRENT_DELAY_MS"
  "VIDEO_DECODE_ASPECT_RATIO"
  "VIDEO_DECODE_FPS"
  "VIDEO_DECODE_HEIGHT"
  "VIDEO_DECODE_MS"
  "VIDEO_DECODE_WIDTH"
  "VIDEO_DISCARDED_PPS"
  "VIDEO_DROPPED_FPS"
  "VIDEO_ENCODER_BW_ADAPTATION_DURATION"
  "VIDEO_ENCODER_CPU_ADAPTATION_DURATION"
  "VIDEO_ENCODE_ASPECT_RATIO"
  "VIDEO_ENCODE_FPS"
  "VIDEO_ENCODE_HEIGHT"
  "VIDEO_ENCODE_USAGE_PERCENT"
  "VIDEO_ENCODE_WIDTH"
  "VIDEO_FIRS_RECEIVED"
  "VIDEO_FIRS_SENT"
  "VIDEO_INPUT_ASPECT_RATIO"
  "VIDEO_INPUT_FPS"
  "VIDEO_INPUT_HEIGHT"
  "VIDEO_JITTER_BUFFER_MS"
  "VIDEO_LOCAL_RENDER_FPS"
  "VIDEO_NACKS_RECEIVED"
  "VIDEO_NACKS_SENT"
  "VIDEO_OUTPUT_FPS"
  "VIDEO_PLIS_RECEIVED"
  "VIDEO_PLIS_SENT"
  "VIDEO_RECEIVED_BITRATE"
  "VIDEO_RECEIVED_FPS"
  "VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT"
  "VIDEO_RECEIVED_JITTER_MS"
  "VIDEO_RECEIVED_KEYFRAMES"
  "VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION"
  "VIDEO_RECEIVED_PPS"
  "VIDEO_RECEIVED_QP_SUM"
  "VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES"
  "VIDEO_RECEIVED_TOTAL_FREEZE_DURATION"
  "VIDEO_REMOTE_RENDER_FPS"
  "VIDEO_RENDER_DELAY_MS"
  "VIDEO_RESETS_STARTED"
  "VIDEO_RETRANSMIT_BITRATE"
  "VIDEO_SENT_BITRATE"
  "VIDEO_SENT_FPS"
  "VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT"
  "VIDEO_SENT_KEYFRAMES"
  "VIDEO_SENT_PPS"
  "VIDEO_SENT_QP_SUM"
  "VIDEO_SENT_RTT_MS"
  "VIDEO_SENT_SIMULCAST_STREAMS"
  "VIDEO_SUBSCRIBES_COMPLETED"
  "VIDEO_TARGET_DELAY_MS"
  "VIDEO_TARGET_ENCODER_BITRATE"
  "VIDEO_TARGET_SUBSCRIBED_BITRATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Metric_Type_entries[] = {
  { {Metric_Type_names + 0, 11}, 54 },
  { {Metric_Type_names + 11, 15}, 12 },
  { {Metric_Type_names + 26, 36}, 11 },
  { {Metric_Type_names + 62, 17}, 9 },
  { {Metric_Type_names + 79, 11}, 10 },
  { {Metric_Type_names + 90, 14}, 13 },
  { {Metric_Type_names + 104, 15}, 18 },
  { {Metric_Type_names + 119, 24}, 19 },
  { {Metric_Type_names + 143, 37}, 17 },
  { {Metric_Type_names + 180, 36}, 15 },
  { {Metric_Type_names + 216, 24}, 20 },
  { {Metric_Type_names + 240, 17}, 16 },
  { {Metric_Type_names + 257, 11}, 14 },
  { {Metric_Type_names + 268, 20}, 8 },
  { {Metric_Type_names + 288, 11}, 7 },
  { {Metric_Type_names + 299, 9}, 55 },
  { {Metric_Type_names + 308, 28}, 1 },
  { {Metric_Type_names + 336, 31}, 75 },
  { {Metric_Type_names + 367, 33}, 4 },
  { {Metric_Type_names + 400, 30}, 2 },
  { {Metric_Type_names + 430, 23}, 25 },
  { {Metric_Type_names + 453, 21}, 6 },
  { {Metric_Type_names + 474, 34}, 82 },
  { {Metric_Type_names + 508, 36}, 80 },
  { {Metric_Type_names + 544, 42}, 83 },
  { {Metric_Type_names + 586, 39}, 78 },
  { {Metric_Type_names + 625, 34}, 81 },
  { {Metric_Type_names + 659, 35}, 85 },
  { {Metric_Type_names + 694, 36}, 79 },
  { {Metric_Type_names + 730, 28}, 84 },
  { {Metric_Type_names + 758, 22}, 45 },
  { {Metric_Type_names + 780, 25}, 70 },
  { {Metric_Type_names + 805, 16}, 41 },
  { {Metric_Type_names + 821, 19}, 69 },
  { {Metric_Type_names + 840, 15}, 35 },
  { {Metric_Type_names + 855, 18}, 87 },
  { {Metric_Type_names + 873, 19}, 47 },
  { {Metric_Type_names + 892, 17}, 33 },
  { {Metric_Type_names + 909, 36}, 68 },
  { {Metric_Type_names + 945, 37}, 67 },
  { {Metric_Type_names + 982, 25}, 65 },
  { {Metric_Type_names + 1007, 16}, 27 },
  { {Metric_Type_names + 1023, 19}, 64 },
  { {Metric_Type_names + 1042, 26}, 22 },
  { {Metric_Type_names + 1068, 18}, 86 },
  { {Metric_Type_names + 1086, 19}, 29 },
  { {Metric_Type_names + 1105, 15}, 43 },
  { {Metric_Type_names + 1120, 24}, 61 },
  { {Metric_Type_names + 1144, 15}, 26 },
  { {Metric_Type_names + 1159, 18}, 60 },
  { {Metric_Type_names + 1177, 22}, 46 },
  { {Metric_Type_names + 1199, 22}, 52 },
  { {Metric_Type_names + 1221, 20}, 23 },
  { {Metric_Type_names + 1241, 16}, 42 },
  { {Metric_Type_names + 1257, 16}, 36 },
  { {Metric_Type_names + 1273, 19}, 24 },
  { {Metric_Type_names + 1292, 15}, 48 },
  { {Metric_Type_names + 1307, 22}, 44 },
  { {Metric_Type_names + 1329, 18}, 40 },
  { {Metric_Type_names + 1347, 43}, 38 },
  { {Metric_Type_names + 1390, 24}, 49 },
  { {Metric_Type_names + 1414, 24}, 71 },
  { {Metric_Type_names + 1438, 41}, 77 },
  { {Metric_Type_names + 1479, 18}, 37 },
  { {Metric_Type_names + 1497, 21}, 72 },
  { {Metric_Type_names + 1518, 40}, 76 },
  { {Metric_Type_names + 1558, 36}, 73 },
  { {Metric_Type_names + 1594, 23}, 56 },
  { {Metric_Type_names + 1617, 21}, 39 },
  { {Metric_Type_names + 1638, 20}, 51 },
  { {Metric_Type_names + 1658, 24}, 3 },
  { {Metric_Type_names + 1682, 18}, 32 },
  { {Metric_Type_names + 1700, 14}, 28 },
  { {Metric_Type_names + 1714, 39}, 31 },
  { {Metric_Type_names + 1753, 20}, 63 },
  { {Metric_Type_names + 1773, 14}, 30 },
  { {Metric_Type_names + 1787, 17}, 66 },
  { {Metric_Type_names + 1804, 17}, 21 },
  { {Metric_Type_names + 1821, 28}, 62 },
  { {Metric_Type_names + 1849, 26}, 50 },
  { {Metric_Type_names + 1875, 21}, 34 },
  { {Metric_Type_names + 1896, 28}, 5 },
  { {Metric_Type_names + 1924, 31}, 74 },
};

static const int Metric_Type_entries_by_number[] = {
  16, // 1 -> VIDEO_ACTUAL_ENCODER_BITRATE
  19, // 2 -> VIDEO_AVAILABLE_SEND_BANDWIDTH
  70, // 3 -> VIDEO_RETRANSMIT_BITRATE
  18, // 4 -> VIDEO_AVAILABLE_RECEIVE_BANDWIDTH
  81, // 5 -> VIDEO_TARGET_ENCODER_BITRATE
  21, // 6 -> VIDEO_BUCKET_DELAY_MS
  14, // 7 -> STUN_RTT_MS
  13, // 8 -> SOCKET_DISCARDED_PPS
  3, // 9 -> RTC_MIC_JITTER_MS
  4, // 10 -> RTC_MIC_PPS
  2, // 11 -> RTC_MIC_FRACTION_PACKET_LOST_PERCENT
  1, // 12 -> RTC_MIC_BITRATE
  5, // 13 -> RTC_MIC_RTT_MS
  12, // 14 -> RTC_SPK_PPS
  9, // 15 -> RTC_SPK_FRACTION_PACKET_LOST_PERCENT
  11, // 16 -> RTC_SPK_JITTER_MS
  8, // 17 -> RTC_SPK_FRACTION_DECODER_LOSS_PERCENT
  6, // 18 -> RTC_SPK_BITRATE
  7, // 19 -> RTC_SPK_CURRENT_DELAY_MS
  10, // 20 -> RTC_SPK_JITTER_BUFFER_MS
  77, // 21 -> VIDEO_SENT_RTT_MS
  43, // 22 -> VIDEO_ENCODE_USAGE_PERCENT
  52, // 23 -> VIDEO_NACKS_RECEIVED
  55, // 24 -> VIDEO_PLIS_RECEIVED
  20, // 25 -> VIDEO_AVERAGE_ENCODE_MS
  48, // 26 -> VIDEO_INPUT_FPS
  41, // 27 -> VIDEO_ENCODE_FPS
  72, // 28 -> VIDEO_SENT_FPS
  45, // 29 -> VIDEO_FIRS_RECEIVED
  75, // 30 -> VIDEO_SENT_PPS
  73, // 31 -> VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT
  71, // 32 -> VIDEO_SENT_BITRATE
  37, // 33 -> VIDEO_DROPPED_FPS
  80, // 34 -> VIDEO_TARGET_DELAY_MS
  34, // 35 -> VIDEO_DECODE_MS
  54, // 36 -> VIDEO_OUTPUT_FPS
  63, // 37 -> VIDEO_RECEIVED_PPS
  59, // 38 -> VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT
  68, // 39 -> VIDEO_RENDER_DELAY_MS
  58, // 40 -> VIDEO_RECEIVED_FPS
  32, // 41 -> VIDEO_DECODE_FPS
  53, // 42 -> VIDEO_NACKS_SENT
  46, // 43 -> VIDEO_FIRS_SENT
  57, // 44 -> VIDEO_RECEIVED_BITRATE
  30, // 45 -> VIDEO_CURRENT_DELAY_MS
  50, // 46 -> VIDEO_JITTER_BUFFER_MS
  36, // 47 -> VIDEO_DISCARDED_PPS
  56, // 48 -> VIDEO_PLIS_SENT
  60, // 49 -> VIDEO_RECEIVED_JITTER_MS
  79, // 50 -> VIDEO_SUBSCRIBES_COMPLETED
  69, // 51 -> VIDEO_RESETS_STARTED
  51, // 52 -> VIDEO_LOCAL_RENDER_FPS
  0, // 54 -> PROCESS_CPU
  15, // 55 -> TOTAL_CPU
  67, // 56 -> VIDEO_REMOTE_RENDER_FPS
  49, // 60 -> VIDEO_INPUT_HEIGHT
  47, // 61 -> VIDEO_INPUT_ASPECT_RATIO
  78, // 62 -> VIDEO_SENT_SIMULCAST_STREAMS
  74, // 63 -> VIDEO_SENT_KEYFRAMES
  42, // 64 -> VIDEO_ENCODE_HEIGHT
  40, // 65 -> VIDEO_ENCODE_ASPECT_RATIO
  76, // 66 -> VIDEO_SENT_QP_SUM
  39, // 67 -> VIDEO_ENCODER_CPU_ADAPTATION_DURATION
  38, // 68 -> VIDEO_ENCODER_BW_ADAPTATION_DURATION
  33, // 69 -> VIDEO_DECODE_HEIGHT
  31, // 70 -> VIDEO_DECODE_ASPECT_RATIO
  61, // 71 -> VIDEO_RECEIVED_KEYFRAMES
  64, // 72 -> VIDEO_RECEIVED_QP_SUM
  66, // 73 -> VIDEO_RECEIVED_TOTAL_FREEZE_DURATION
  82, // 74 -> VIDEO_TARGET_SUBSCRIBED_BITRATE
  17, // 75 -> VIDEO_ACTUAL_SUBSCRIBED_BITRATE
  65, // 76 -> VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES
  62, // 77 -> VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION
  25, // 78 -> VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION
  28, // 79 -> VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY
  23, // 80 -> VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY
  26, // 81 -> VIDEO_CAPTURER_ADAPTER_FRAME_DROPS
  22, // 82 -> VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS
  24, // 83 -> VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY
  29, // 84 -> VIDEO_CAPTURER_ADAPTER_SIGMA
  27, // 85 -> VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS
  44, // 86 -> VIDEO_ENCODE_WIDTH
  35, // 87 -> VIDEO_DECODE_WIDTH
};

const std::string& Metric_Type_Name(
    Metric_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Metric_Type_entries,
          Metric_Type_entries_by_number,
          83, Metric_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Metric_Type_entries,
      Metric_Type_entries_by_number,
      83, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Metric_Type_strings[idx].get();
}
bool Metric_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Metric_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Metric_Type_entries, 83, name, &int_value);
  if (success) {
    *value = static_cast<Metric_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Metric_Type Metric::VIDEO_ACTUAL_ENCODER_BITRATE;
constexpr Metric_Type Metric::VIDEO_AVAILABLE_SEND_BANDWIDTH;
constexpr Metric_Type Metric::VIDEO_RETRANSMIT_BITRATE;
constexpr Metric_Type Metric::VIDEO_AVAILABLE_RECEIVE_BANDWIDTH;
constexpr Metric_Type Metric::VIDEO_TARGET_ENCODER_BITRATE;
constexpr Metric_Type Metric::VIDEO_BUCKET_DELAY_MS;
constexpr Metric_Type Metric::STUN_RTT_MS;
constexpr Metric_Type Metric::SOCKET_DISCARDED_PPS;
constexpr Metric_Type Metric::RTC_MIC_JITTER_MS;
constexpr Metric_Type Metric::RTC_MIC_PPS;
constexpr Metric_Type Metric::RTC_MIC_FRACTION_PACKET_LOST_PERCENT;
constexpr Metric_Type Metric::RTC_MIC_BITRATE;
constexpr Metric_Type Metric::RTC_MIC_RTT_MS;
constexpr Metric_Type Metric::RTC_SPK_PPS;
constexpr Metric_Type Metric::RTC_SPK_FRACTION_PACKET_LOST_PERCENT;
constexpr Metric_Type Metric::RTC_SPK_JITTER_MS;
constexpr Metric_Type Metric::RTC_SPK_FRACTION_DECODER_LOSS_PERCENT;
constexpr Metric_Type Metric::RTC_SPK_BITRATE;
constexpr Metric_Type Metric::RTC_SPK_CURRENT_DELAY_MS;
constexpr Metric_Type Metric::RTC_SPK_JITTER_BUFFER_MS;
constexpr Metric_Type Metric::VIDEO_SENT_RTT_MS;
constexpr Metric_Type Metric::VIDEO_ENCODE_USAGE_PERCENT;
constexpr Metric_Type Metric::VIDEO_NACKS_RECEIVED;
constexpr Metric_Type Metric::VIDEO_PLIS_RECEIVED;
constexpr Metric_Type Metric::VIDEO_AVERAGE_ENCODE_MS;
constexpr Metric_Type Metric::VIDEO_INPUT_FPS;
constexpr Metric_Type Metric::VIDEO_ENCODE_FPS;
constexpr Metric_Type Metric::VIDEO_SENT_FPS;
constexpr Metric_Type Metric::VIDEO_FIRS_RECEIVED;
constexpr Metric_Type Metric::VIDEO_SENT_PPS;
constexpr Metric_Type Metric::VIDEO_SENT_FRACTION_PACKET_LOST_PERCENT;
constexpr Metric_Type Metric::VIDEO_SENT_BITRATE;
constexpr Metric_Type Metric::VIDEO_DROPPED_FPS;
constexpr Metric_Type Metric::VIDEO_TARGET_DELAY_MS;
constexpr Metric_Type Metric::VIDEO_DECODE_MS;
constexpr Metric_Type Metric::VIDEO_OUTPUT_FPS;
constexpr Metric_Type Metric::VIDEO_RECEIVED_PPS;
constexpr Metric_Type Metric::VIDEO_RECEIVED_FRACTION_PACKET_LOST_PERCENT;
constexpr Metric_Type Metric::VIDEO_RENDER_DELAY_MS;
constexpr Metric_Type Metric::VIDEO_RECEIVED_FPS;
constexpr Metric_Type Metric::VIDEO_DECODE_FPS;
constexpr Metric_Type Metric::VIDEO_NACKS_SENT;
constexpr Metric_Type Metric::VIDEO_FIRS_SENT;
constexpr Metric_Type Metric::VIDEO_RECEIVED_BITRATE;
constexpr Metric_Type Metric::VIDEO_CURRENT_DELAY_MS;
constexpr Metric_Type Metric::VIDEO_JITTER_BUFFER_MS;
constexpr Metric_Type Metric::VIDEO_DISCARDED_PPS;
constexpr Metric_Type Metric::VIDEO_PLIS_SENT;
constexpr Metric_Type Metric::VIDEO_RECEIVED_JITTER_MS;
constexpr Metric_Type Metric::VIDEO_SUBSCRIBES_COMPLETED;
constexpr Metric_Type Metric::VIDEO_RESETS_STARTED;
constexpr Metric_Type Metric::VIDEO_LOCAL_RENDER_FPS;
constexpr Metric_Type Metric::PROCESS_CPU;
constexpr Metric_Type Metric::TOTAL_CPU;
constexpr Metric_Type Metric::VIDEO_REMOTE_RENDER_FPS;
constexpr Metric_Type Metric::VIDEO_INPUT_HEIGHT;
constexpr Metric_Type Metric::VIDEO_INPUT_ASPECT_RATIO;
constexpr Metric_Type Metric::VIDEO_SENT_SIMULCAST_STREAMS;
constexpr Metric_Type Metric::VIDEO_SENT_KEYFRAMES;
constexpr Metric_Type Metric::VIDEO_ENCODE_HEIGHT;
constexpr Metric_Type Metric::VIDEO_ENCODE_ASPECT_RATIO;
constexpr Metric_Type Metric::VIDEO_SENT_QP_SUM;
constexpr Metric_Type Metric::VIDEO_ENCODER_CPU_ADAPTATION_DURATION;
constexpr Metric_Type Metric::VIDEO_ENCODER_BW_ADAPTATION_DURATION;
constexpr Metric_Type Metric::VIDEO_DECODE_HEIGHT;
constexpr Metric_Type Metric::VIDEO_DECODE_ASPECT_RATIO;
constexpr Metric_Type Metric::VIDEO_RECEIVED_KEYFRAMES;
constexpr Metric_Type Metric::VIDEO_RECEIVED_QP_SUM;
constexpr Metric_Type Metric::VIDEO_RECEIVED_TOTAL_FREEZE_DURATION;
constexpr Metric_Type Metric::VIDEO_TARGET_SUBSCRIBED_BITRATE;
constexpr Metric_Type Metric::VIDEO_ACTUAL_SUBSCRIBED_BITRATE;
constexpr Metric_Type Metric::VIDEO_RECEIVED_SIMULCAST_STREAM_SWITCHES;
constexpr Metric_Type Metric::VIDEO_RECEIVED_PAUSES_FOR_POOR_CONNECTION;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_ENABLED_DURATION;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_FRAME_LATENCY;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_ASYNC_LATENCY;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_FRAME_DROPS;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_ASYNC_DROPS;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_ASYNC_USAGE_LATENCY;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_SIGMA;
constexpr Metric_Type Metric::VIDEO_CAPTURER_ADAPTER_FRAME_ERRORS;
constexpr Metric_Type Metric::VIDEO_ENCODE_WIDTH;
constexpr Metric_Type Metric::VIDEO_DECODE_WIDTH;
constexpr Metric_Type Metric::Type_MIN;
constexpr Metric_Type Metric::Type_MAX;
constexpr int Metric::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool AudioTranscriptItem_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioTranscriptItem_Type_strings[2] = {};

static const char AudioTranscriptItem_Type_names[] =
  "PRONUNCIATION"
  "PUNCTUATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioTranscriptItem_Type_entries[] = {
  { {AudioTranscriptItem_Type_names + 0, 13}, 1 },
  { {AudioTranscriptItem_Type_names + 13, 11}, 2 },
};

static const int AudioTranscriptItem_Type_entries_by_number[] = {
  0, // 1 -> PRONUNCIATION
  1, // 2 -> PUNCTUATION
};

const std::string& AudioTranscriptItem_Type_Name(
    AudioTranscriptItem_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioTranscriptItem_Type_entries,
          AudioTranscriptItem_Type_entries_by_number,
          2, AudioTranscriptItem_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioTranscriptItem_Type_entries,
      AudioTranscriptItem_Type_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioTranscriptItem_Type_strings[idx].get();
}
bool AudioTranscriptItem_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioTranscriptItem_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioTranscriptItem_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AudioTranscriptItem_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AudioTranscriptItem_Type AudioTranscriptItem::PRONUNCIATION;
constexpr AudioTranscriptItem_Type AudioTranscriptItem::PUNCTUATION;
constexpr AudioTranscriptItem_Type AudioTranscriptItem::Type_MIN;
constexpr AudioTranscriptItem_Type AudioTranscriptItem::Type_MAX;
constexpr int AudioTranscriptItem::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool MeetingTranscriptionStatus_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MeetingTranscriptionStatus_Type_strings[5] = {};

static const char MeetingTranscriptionStatus_Type_names[] =
  "FAILED"
  "INTERRUPTED"
  "RESUMED"
  "STARTED"
  "STOPPED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MeetingTranscriptionStatus_Type_entries[] = {
  { {MeetingTranscriptionStatus_Type_names + 0, 6}, 5 },
  { {MeetingTranscriptionStatus_Type_names + 6, 11}, 2 },
  { {MeetingTranscriptionStatus_Type_names + 17, 7}, 3 },
  { {MeetingTranscriptionStatus_Type_names + 24, 7}, 1 },
  { {MeetingTranscriptionStatus_Type_names + 31, 7}, 4 },
};

static const int MeetingTranscriptionStatus_Type_entries_by_number[] = {
  3, // 1 -> STARTED
  1, // 2 -> INTERRUPTED
  2, // 3 -> RESUMED
  4, // 4 -> STOPPED
  0, // 5 -> FAILED
};

const std::string& MeetingTranscriptionStatus_Type_Name(
    MeetingTranscriptionStatus_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MeetingTranscriptionStatus_Type_entries,
          MeetingTranscriptionStatus_Type_entries_by_number,
          5, MeetingTranscriptionStatus_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MeetingTranscriptionStatus_Type_entries,
      MeetingTranscriptionStatus_Type_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MeetingTranscriptionStatus_Type_strings[idx].get();
}
bool MeetingTranscriptionStatus_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MeetingTranscriptionStatus_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MeetingTranscriptionStatus_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<MeetingTranscriptionStatus_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::STARTED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::INTERRUPTED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::RESUMED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::STOPPED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::FAILED;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::Type_MIN;
constexpr MeetingTranscriptionStatus_Type MeetingTranscriptionStatus::Type_MAX;
constexpr int MeetingTranscriptionStatus::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool BridgeReserveFrame_ReservationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BridgeReserveFrame_ReservationType_strings[2] = {};

static const char BridgeReserveFrame_ReservationType_names[] =
  "CONTENT_VIDEO_INPUT"
  "VIDEO_INPUT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BridgeReserveFrame_ReservationType_entries[] = {
  { {BridgeReserveFrame_ReservationType_names + 0, 19}, 2 },
  { {BridgeReserveFrame_ReservationType_names + 19, 11}, 1 },
};

static const int BridgeReserveFrame_ReservationType_entries_by_number[] = {
  1, // 1 -> VIDEO_INPUT
  0, // 2 -> CONTENT_VIDEO_INPUT
};

const std::string& BridgeReserveFrame_ReservationType_Name(
    BridgeReserveFrame_ReservationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BridgeReserveFrame_ReservationType_entries,
          BridgeReserveFrame_ReservationType_entries_by_number,
          2, BridgeReserveFrame_ReservationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BridgeReserveFrame_ReservationType_entries,
      BridgeReserveFrame_ReservationType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BridgeReserveFrame_ReservationType_strings[idx].get();
}
bool BridgeReserveFrame_ReservationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BridgeReserveFrame_ReservationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BridgeReserveFrame_ReservationType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<BridgeReserveFrame_ReservationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame::VIDEO_INPUT;
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame::CONTENT_VIDEO_INPUT;
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame::ReservationType_MIN;
constexpr BridgeReserveFrame_ReservationType BridgeReserveFrame::ReservationType_MAX;
constexpr int BridgeReserveFrame::ReservationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool BridgeReserveFrame_Action_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BridgeReserveFrame_Action_strings[2] = {};

static const char BridgeReserveFrame_Action_names[] =
  "RELEASE"
  "RESERVE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BridgeReserveFrame_Action_entries[] = {
  { {BridgeReserveFrame_Action_names + 0, 7}, 2 },
  { {BridgeReserveFrame_Action_names + 7, 7}, 1 },
};

static const int BridgeReserveFrame_Action_entries_by_number[] = {
  1, // 1 -> RESERVE
  0, // 2 -> RELEASE
};

const std::string& BridgeReserveFrame_Action_Name(
    BridgeReserveFrame_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BridgeReserveFrame_Action_entries,
          BridgeReserveFrame_Action_entries_by_number,
          2, BridgeReserveFrame_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BridgeReserveFrame_Action_entries,
      BridgeReserveFrame_Action_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BridgeReserveFrame_Action_strings[idx].get();
}
bool BridgeReserveFrame_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BridgeReserveFrame_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BridgeReserveFrame_Action_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<BridgeReserveFrame_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BridgeReserveFrame_Action BridgeReserveFrame::RESERVE;
constexpr BridgeReserveFrame_Action BridgeReserveFrame::RELEASE;
constexpr BridgeReserveFrame_Action BridgeReserveFrame::Action_MIN;
constexpr BridgeReserveFrame_Action BridgeReserveFrame::Action_MAX;
constexpr int BridgeReserveFrame::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool JoinFlags_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 8:
    case 32:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> JoinFlags_strings[4] = {};

static const char JoinFlags_names[] =
  "EXCLUDE_SELF_CONTENT_IN_INDEX"
  "HAS_STREAM_UPDATE"
  "SEND_BITRATES"
  "USE_SEND_SIDE_BWE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry JoinFlags_entries[] = {
  { {JoinFlags_names + 0, 29}, 32 },
  { {JoinFlags_names + 29, 17}, 2 },
  { {JoinFlags_names + 46, 13}, 1 },
  { {JoinFlags_names + 59, 17}, 8 },
};

static const int JoinFlags_entries_by_number[] = {
  2, // 1 -> SEND_BITRATES
  1, // 2 -> HAS_STREAM_UPDATE
  3, // 8 -> USE_SEND_SIDE_BWE
  0, // 32 -> EXCLUDE_SELF_CONTENT_IN_INDEX
};

const std::string& JoinFlags_Name(
    JoinFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          JoinFlags_entries,
          JoinFlags_entries_by_number,
          4, JoinFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      JoinFlags_entries,
      JoinFlags_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     JoinFlags_strings[idx].get();
}
bool JoinFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      JoinFlags_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<JoinFlags>(int_value);
  }
  return success;
}
bool StreamServiceType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamServiceType_strings[4] = {};

static const char StreamServiceType_names[] =
  "DUPLEX"
  "IDLE"
  "RX"
  "TX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamServiceType_entries[] = {
  { {StreamServiceType_names + 0, 6}, 3 },
  { {StreamServiceType_names + 6, 4}, 4 },
  { {StreamServiceType_names + 10, 2}, 1 },
  { {StreamServiceType_names + 12, 2}, 2 },
};

static const int StreamServiceType_entries_by_number[] = {
  2, // 1 -> RX
  3, // 2 -> TX
  0, // 3 -> DUPLEX
  1, // 4 -> IDLE
};

const std::string& StreamServiceType_Name(
    StreamServiceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StreamServiceType_entries,
          StreamServiceType_entries_by_number,
          4, StreamServiceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StreamServiceType_entries,
      StreamServiceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StreamServiceType_strings[idx].get();
}
bool StreamServiceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamServiceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StreamServiceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<StreamServiceType>(int_value);
  }
  return success;
}
bool StreamMediaType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamMediaType_strings[2] = {};

static const char StreamMediaType_names[] =
  "AUDIO"
  "VIDEO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamMediaType_entries[] = {
  { {StreamMediaType_names + 0, 5}, 1 },
  { {StreamMediaType_names + 5, 5}, 2 },
};

static const int StreamMediaType_entries_by_number[] = {
  0, // 1 -> AUDIO
  1, // 2 -> VIDEO
};

const std::string& StreamMediaType_Name(
    StreamMediaType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StreamMediaType_entries,
          StreamMediaType_entries_by_number,
          2, StreamMediaType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StreamMediaType_entries,
      StreamMediaType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StreamMediaType_strings[idx].get();
}
bool StreamMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamMediaType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StreamMediaType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<StreamMediaType>(int_value);
  }
  return success;
}
bool PingPongType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PingPongType_strings[2] = {};

static const char PingPongType_names[] =
  "PING"
  "PONG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PingPongType_entries[] = {
  { {PingPongType_names + 0, 4}, 1 },
  { {PingPongType_names + 4, 4}, 2 },
};

static const int PingPongType_entries_by_number[] = {
  0, // 1 -> PING
  1, // 2 -> PONG
};

const std::string& PingPongType_Name(
    PingPongType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PingPongType_entries,
          PingPongType_entries_by_number,
          2, PingPongType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PingPongType_entries,
      PingPongType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PingPongType_strings[idx].get();
}
bool PingPongType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PingPongType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PingPongType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PingPongType>(int_value);
  }
  return success;
}

// ===================================================================

class SignalFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<SignalFrame>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::signal_rtc::ErrorFrame& error(const SignalFrame* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::signal_rtc::JoinFrame& join(const SignalFrame* msg);
  static void set_has_join(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::signal_rtc::JoinAckFrame& joinack(const SignalFrame* msg);
  static void set_has_joinack(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::signal_rtc::SubscribeFrame& sub(const SignalFrame* msg);
  static void set_has_sub(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::signal_rtc::SubscribeAckFrame& suback(const SignalFrame* msg);
  static void set_has_suback(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::signal_rtc::IndexFrame& index(const SignalFrame* msg);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::signal_rtc::PauseResumeFrame& pause(const SignalFrame* msg);
  static void set_has_pause(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::signal_rtc::LeaveFrame& leave(const SignalFrame* msg);
  static void set_has_leave(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::signal_rtc::LeaveAckFrame& leave_ack(const SignalFrame* msg);
  static void set_has_leave_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::signal_rtc::BitrateFrame& bitrates(const SignalFrame* msg);
  static void set_has_bitrates(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::signal_rtc::AudioControlFrame& audio_control(const SignalFrame* msg);
  static void set_has_audio_control(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::signal_rtc::AudioMetadataFrame& audio_metadata(const SignalFrame* msg);
  static void set_has_audio_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::signal_rtc::AudioStreamIdInfoFrame& audio_stream_id_info(const SignalFrame* msg);
  static void set_has_audio_stream_id_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::signal_rtc::PingPongFrame& ping_pong(const SignalFrame* msg);
  static void set_has_ping_pong(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::signal_rtc::AudioStatusFrame& audio_status(const SignalFrame* msg);
  static void set_has_audio_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::signal_rtc::ClientMetricFrame& client_metric(const SignalFrame* msg);
  static void set_has_client_metric(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::signal_rtc::DataMessageFrame& data_message(const SignalFrame* msg);
  static void set_has_data_message(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::signal_rtc::AudioTranscriptFrame& audio_transcript(const SignalFrame* msg);
  static void set_has_audio_transcript(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::signal_rtc::RemoteVideoUpdateFrame& remote_video_update(const SignalFrame* msg);
  static void set_has_remote_video_update(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::signal_rtc::PrimaryMeetingJoinFrame& primary_meeting_join(const SignalFrame* msg);
  static void set_has_primary_meeting_join(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::signal_rtc::PrimaryMeetingJoinAckFrame& primary_meeting_join_ack(const SignalFrame* msg);
  static void set_has_primary_meeting_join_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::signal_rtc::PrimaryMeetingLeaveFrame& primary_meeting_leave(const SignalFrame* msg);
  static void set_has_primary_meeting_leave(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::signal_rtc::BridgeJoinFrame& bridge_join(const SignalFrame* msg);
  static void set_has_bridge_join(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::signal_rtc::BridgeJoinAckFrame& bridge_join_ack(const SignalFrame* msg);
  static void set_has_bridge_join_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::signal_rtc::BridgeReserveFrame& bridge_reserve(const SignalFrame* msg);
  static void set_has_bridge_reserve(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::signal_rtc::BridgeReserveAckFrame& bridge_reserve_ack(const SignalFrame* msg);
  static void set_has_bridge_reserve_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0c000000) ^ 0x0c000000) != 0;
  }
};

const ::signal_rtc::ErrorFrame&
SignalFrame::_Internal::error(const SignalFrame* msg) {
  return *msg->error_;
}
const ::signal_rtc::JoinFrame&
SignalFrame::_Internal::join(const SignalFrame* msg) {
  return *msg->join_;
}
const ::signal_rtc::JoinAckFrame&
SignalFrame::_Internal::joinack(const SignalFrame* msg) {
  return *msg->joinack_;
}
const ::signal_rtc::SubscribeFrame&
SignalFrame::_Internal::sub(const SignalFrame* msg) {
  return *msg->sub_;
}
const ::signal_rtc::SubscribeAckFrame&
SignalFrame::_Internal::suback(const SignalFrame* msg) {
  return *msg->suback_;
}
const ::signal_rtc::IndexFrame&
SignalFrame::_Internal::index(const SignalFrame* msg) {
  return *msg->index_;
}
const ::signal_rtc::PauseResumeFrame&
SignalFrame::_Internal::pause(const SignalFrame* msg) {
  return *msg->pause_;
}
const ::signal_rtc::LeaveFrame&
SignalFrame::_Internal::leave(const SignalFrame* msg) {
  return *msg->leave_;
}
const ::signal_rtc::LeaveAckFrame&
SignalFrame::_Internal::leave_ack(const SignalFrame* msg) {
  return *msg->leave_ack_;
}
const ::signal_rtc::BitrateFrame&
SignalFrame::_Internal::bitrates(const SignalFrame* msg) {
  return *msg->bitrates_;
}
const ::signal_rtc::AudioControlFrame&
SignalFrame::_Internal::audio_control(const SignalFrame* msg) {
  return *msg->audio_control_;
}
const ::signal_rtc::AudioMetadataFrame&
SignalFrame::_Internal::audio_metadata(const SignalFrame* msg) {
  return *msg->audio_metadata_;
}
const ::signal_rtc::AudioStreamIdInfoFrame&
SignalFrame::_Internal::audio_stream_id_info(const SignalFrame* msg) {
  return *msg->audio_stream_id_info_;
}
const ::signal_rtc::PingPongFrame&
SignalFrame::_Internal::ping_pong(const SignalFrame* msg) {
  return *msg->ping_pong_;
}
const ::signal_rtc::AudioStatusFrame&
SignalFrame::_Internal::audio_status(const SignalFrame* msg) {
  return *msg->audio_status_;
}
const ::signal_rtc::ClientMetricFrame&
SignalFrame::_Internal::client_metric(const SignalFrame* msg) {
  return *msg->client_metric_;
}
const ::signal_rtc::DataMessageFrame&
SignalFrame::_Internal::data_message(const SignalFrame* msg) {
  return *msg->data_message_;
}
const ::signal_rtc::AudioTranscriptFrame&
SignalFrame::_Internal::audio_transcript(const SignalFrame* msg) {
  return *msg->audio_transcript_;
}
const ::signal_rtc::RemoteVideoUpdateFrame&
SignalFrame::_Internal::remote_video_update(const SignalFrame* msg) {
  return *msg->remote_video_update_;
}
const ::signal_rtc::PrimaryMeetingJoinFrame&
SignalFrame::_Internal::primary_meeting_join(const SignalFrame* msg) {
  return *msg->primary_meeting_join_;
}
const ::signal_rtc::PrimaryMeetingJoinAckFrame&
SignalFrame::_Internal::primary_meeting_join_ack(const SignalFrame* msg) {
  return *msg->primary_meeting_join_ack_;
}
const ::signal_rtc::PrimaryMeetingLeaveFrame&
SignalFrame::_Internal::primary_meeting_leave(const SignalFrame* msg) {
  return *msg->primary_meeting_leave_;
}
const ::signal_rtc::BridgeJoinFrame&
SignalFrame::_Internal::bridge_join(const SignalFrame* msg) {
  return *msg->bridge_join_;
}
const ::signal_rtc::BridgeJoinAckFrame&
SignalFrame::_Internal::bridge_join_ack(const SignalFrame* msg) {
  return *msg->bridge_join_ack_;
}
const ::signal_rtc::BridgeReserveFrame&
SignalFrame::_Internal::bridge_reserve(const SignalFrame* msg) {
  return *msg->bridge_reserve_;
}
const ::signal_rtc::BridgeReserveAckFrame&
SignalFrame::_Internal::bridge_reserve_ack(const SignalFrame* msg) {
  return *msg->bridge_reserve_ack_;
}
SignalFrame::SignalFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.SignalFrame)
}
SignalFrame::SignalFrame(const SignalFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_error()) {
    error_ = new ::signal_rtc::ErrorFrame(*from.error_);
  } else {
    error_ = nullptr;
  }
  if (from._internal_has_join()) {
    join_ = new ::signal_rtc::JoinFrame(*from.join_);
  } else {
    join_ = nullptr;
  }
  if (from._internal_has_joinack()) {
    joinack_ = new ::signal_rtc::JoinAckFrame(*from.joinack_);
  } else {
    joinack_ = nullptr;
  }
  if (from._internal_has_sub()) {
    sub_ = new ::signal_rtc::SubscribeFrame(*from.sub_);
  } else {
    sub_ = nullptr;
  }
  if (from._internal_has_suback()) {
    suback_ = new ::signal_rtc::SubscribeAckFrame(*from.suback_);
  } else {
    suback_ = nullptr;
  }
  if (from._internal_has_index()) {
    index_ = new ::signal_rtc::IndexFrame(*from.index_);
  } else {
    index_ = nullptr;
  }
  if (from._internal_has_pause()) {
    pause_ = new ::signal_rtc::PauseResumeFrame(*from.pause_);
  } else {
    pause_ = nullptr;
  }
  if (from._internal_has_leave()) {
    leave_ = new ::signal_rtc::LeaveFrame(*from.leave_);
  } else {
    leave_ = nullptr;
  }
  if (from._internal_has_leave_ack()) {
    leave_ack_ = new ::signal_rtc::LeaveAckFrame(*from.leave_ack_);
  } else {
    leave_ack_ = nullptr;
  }
  if (from._internal_has_bitrates()) {
    bitrates_ = new ::signal_rtc::BitrateFrame(*from.bitrates_);
  } else {
    bitrates_ = nullptr;
  }
  if (from._internal_has_audio_control()) {
    audio_control_ = new ::signal_rtc::AudioControlFrame(*from.audio_control_);
  } else {
    audio_control_ = nullptr;
  }
  if (from._internal_has_audio_metadata()) {
    audio_metadata_ = new ::signal_rtc::AudioMetadataFrame(*from.audio_metadata_);
  } else {
    audio_metadata_ = nullptr;
  }
  if (from._internal_has_audio_stream_id_info()) {
    audio_stream_id_info_ = new ::signal_rtc::AudioStreamIdInfoFrame(*from.audio_stream_id_info_);
  } else {
    audio_stream_id_info_ = nullptr;
  }
  if (from._internal_has_ping_pong()) {
    ping_pong_ = new ::signal_rtc::PingPongFrame(*from.ping_pong_);
  } else {
    ping_pong_ = nullptr;
  }
  if (from._internal_has_audio_status()) {
    audio_status_ = new ::signal_rtc::AudioStatusFrame(*from.audio_status_);
  } else {
    audio_status_ = nullptr;
  }
  if (from._internal_has_client_metric()) {
    client_metric_ = new ::signal_rtc::ClientMetricFrame(*from.client_metric_);
  } else {
    client_metric_ = nullptr;
  }
  if (from._internal_has_data_message()) {
    data_message_ = new ::signal_rtc::DataMessageFrame(*from.data_message_);
  } else {
    data_message_ = nullptr;
  }
  if (from._internal_has_audio_transcript()) {
    audio_transcript_ = new ::signal_rtc::AudioTranscriptFrame(*from.audio_transcript_);
  } else {
    audio_transcript_ = nullptr;
  }
  if (from._internal_has_remote_video_update()) {
    remote_video_update_ = new ::signal_rtc::RemoteVideoUpdateFrame(*from.remote_video_update_);
  } else {
    remote_video_update_ = nullptr;
  }
  if (from._internal_has_primary_meeting_join()) {
    primary_meeting_join_ = new ::signal_rtc::PrimaryMeetingJoinFrame(*from.primary_meeting_join_);
  } else {
    primary_meeting_join_ = nullptr;
  }
  if (from._internal_has_primary_meeting_join_ack()) {
    primary_meeting_join_ack_ = new ::signal_rtc::PrimaryMeetingJoinAckFrame(*from.primary_meeting_join_ack_);
  } else {
    primary_meeting_join_ack_ = nullptr;
  }
  if (from._internal_has_primary_meeting_leave()) {
    primary_meeting_leave_ = new ::signal_rtc::PrimaryMeetingLeaveFrame(*from.primary_meeting_leave_);
  } else {
    primary_meeting_leave_ = nullptr;
  }
  if (from._internal_has_bridge_join()) {
    bridge_join_ = new ::signal_rtc::BridgeJoinFrame(*from.bridge_join_);
  } else {
    bridge_join_ = nullptr;
  }
  if (from._internal_has_bridge_join_ack()) {
    bridge_join_ack_ = new ::signal_rtc::BridgeJoinAckFrame(*from.bridge_join_ack_);
  } else {
    bridge_join_ack_ = nullptr;
  }
  if (from._internal_has_bridge_reserve()) {
    bridge_reserve_ = new ::signal_rtc::BridgeReserveFrame(*from.bridge_reserve_);
  } else {
    bridge_reserve_ = nullptr;
  }
  if (from._internal_has_bridge_reserve_ack()) {
    bridge_reserve_ack_ = new ::signal_rtc::BridgeReserveAckFrame(*from.bridge_reserve_ack_);
  } else {
    bridge_reserve_ack_ = nullptr;
  }
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.SignalFrame)
}

void SignalFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SignalFrame_video_5fcontrol_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&error_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp_ms_) -
      reinterpret_cast<char*>(&error_)) + sizeof(timestamp_ms_));
  type_ = 1;
}

SignalFrame::~SignalFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.SignalFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void SignalFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete join_;
  if (this != internal_default_instance()) delete joinack_;
  if (this != internal_default_instance()) delete sub_;
  if (this != internal_default_instance()) delete suback_;
  if (this != internal_default_instance()) delete index_;
  if (this != internal_default_instance()) delete pause_;
  if (this != internal_default_instance()) delete leave_;
  if (this != internal_default_instance()) delete leave_ack_;
  if (this != internal_default_instance()) delete bitrates_;
  if (this != internal_default_instance()) delete audio_control_;
  if (this != internal_default_instance()) delete audio_metadata_;
  if (this != internal_default_instance()) delete audio_stream_id_info_;
  if (this != internal_default_instance()) delete ping_pong_;
  if (this != internal_default_instance()) delete audio_status_;
  if (this != internal_default_instance()) delete client_metric_;
  if (this != internal_default_instance()) delete data_message_;
  if (this != internal_default_instance()) delete audio_transcript_;
  if (this != internal_default_instance()) delete remote_video_update_;
  if (this != internal_default_instance()) delete primary_meeting_join_;
  if (this != internal_default_instance()) delete primary_meeting_join_ack_;
  if (this != internal_default_instance()) delete primary_meeting_leave_;
  if (this != internal_default_instance()) delete bridge_join_;
  if (this != internal_default_instance()) delete bridge_join_ack_;
  if (this != internal_default_instance()) delete bridge_reserve_;
  if (this != internal_default_instance()) delete bridge_reserve_ack_;
}

void SignalFrame::ArenaDtor(void* object) {
  SignalFrame* _this = reinterpret_cast< SignalFrame* >(object);
  (void)_this;
}
void SignalFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignalFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SignalFrame& SignalFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SignalFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void SignalFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.SignalFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(join_ != nullptr);
      join_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(joinack_ != nullptr);
      joinack_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(sub_ != nullptr);
      sub_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(suback_ != nullptr);
      suback_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(index_ != nullptr);
      index_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(pause_ != nullptr);
      pause_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(leave_ != nullptr);
      leave_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(leave_ack_ != nullptr);
      leave_ack_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(bitrates_ != nullptr);
      bitrates_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(audio_control_ != nullptr);
      audio_control_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(audio_metadata_ != nullptr);
      audio_metadata_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(audio_stream_id_info_ != nullptr);
      audio_stream_id_info_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(ping_pong_ != nullptr);
      ping_pong_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(audio_status_ != nullptr);
      audio_status_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(client_metric_ != nullptr);
      client_metric_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(data_message_ != nullptr);
      data_message_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(audio_transcript_ != nullptr);
      audio_transcript_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(remote_video_update_ != nullptr);
      remote_video_update_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(primary_meeting_join_ != nullptr);
      primary_meeting_join_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(primary_meeting_join_ack_ != nullptr);
      primary_meeting_join_ack_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(primary_meeting_leave_ != nullptr);
      primary_meeting_leave_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(bridge_join_ != nullptr);
      bridge_join_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(bridge_join_ack_ != nullptr);
      bridge_join_ack_->Clear();
    }
  }
  if (cached_has_bits & 0x03000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(bridge_reserve_ != nullptr);
      bridge_reserve_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(bridge_reserve_ack_ != nullptr);
      bridge_reserve_ack_->Clear();
    }
  }
  if (cached_has_bits & 0x0c000000u) {
    timestamp_ms_ = PROTOBUF_ULONGLONG(0);
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SignalFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .signal_rtc.SignalFrame.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::SignalFrame_Type_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::SignalFrame_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.ErrorFrame error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.JoinFrame join = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_join(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.JoinAckFrame joinack = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_joinack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.SubscribeFrame sub = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.SubscribeAckFrame suback = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_suback(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.IndexFrame index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_index(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.PauseResumeFrame pause = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pause(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.LeaveFrame leave = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_leave(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.LeaveAckFrame leave_ack = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_leave_ack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BitrateFrame bitrates = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bitrates(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioControlFrame audio_control = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_control(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioMetadataFrame audio_metadata = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioStreamIdInfoFrame audio_stream_id_info = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_stream_id_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.PingPongFrame ping_pong = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_ping_pong(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioStatusFrame audio_status = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.ClientMetricFrame client_metric = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_metric(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.DataMessageFrame data_message = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioTranscriptFrame audio_transcript = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_transcript(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.RemoteVideoUpdateFrame remote_video_update = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_remote_video_update(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.PrimaryMeetingJoinFrame primary_meeting_join = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_primary_meeting_join(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.PrimaryMeetingJoinAckFrame primary_meeting_join_ack = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_primary_meeting_join_ack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.PrimaryMeetingLeaveFrame primary_meeting_leave = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_primary_meeting_leave(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BridgeJoinFrame bridge_join = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_bridge_join(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BridgeJoinAckFrame bridge_join_ack = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_bridge_join_ack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BridgeReserveFrame bridge_reserve = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_bridge_reserve(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BridgeReserveAckFrame bridge_reserve_ack = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_bridge_reserve_ack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignalFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.SignalFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 timestamp_ms = 1;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // required .signal_rtc.SignalFrame.Type type = 2;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional .signal_rtc.ErrorFrame error = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::error(this), target, stream);
  }

  // optional .signal_rtc.JoinFrame join = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::join(this), target, stream);
  }

  // optional .signal_rtc.JoinAckFrame joinack = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::joinack(this), target, stream);
  }

  // optional .signal_rtc.SubscribeFrame sub = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::sub(this), target, stream);
  }

  // optional .signal_rtc.SubscribeAckFrame suback = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::suback(this), target, stream);
  }

  // optional .signal_rtc.IndexFrame index = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::index(this), target, stream);
  }

  // optional .signal_rtc.PauseResumeFrame pause = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::pause(this), target, stream);
  }

  // optional .signal_rtc.LeaveFrame leave = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::leave(this), target, stream);
  }

  // optional .signal_rtc.LeaveAckFrame leave_ack = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::leave_ack(this), target, stream);
  }

  // optional .signal_rtc.BitrateFrame bitrates = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::bitrates(this), target, stream);
  }

  // optional .signal_rtc.AudioControlFrame audio_control = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::audio_control(this), target, stream);
  }

  // optional .signal_rtc.AudioMetadataFrame audio_metadata = 18;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::audio_metadata(this), target, stream);
  }

  // optional .signal_rtc.AudioStreamIdInfoFrame audio_stream_id_info = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::audio_stream_id_info(this), target, stream);
  }

  // optional .signal_rtc.PingPongFrame ping_pong = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::ping_pong(this), target, stream);
  }

  // optional .signal_rtc.AudioStatusFrame audio_status = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::audio_status(this), target, stream);
  }

  // optional .signal_rtc.ClientMetricFrame client_metric = 22;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::client_metric(this), target, stream);
  }

  // optional .signal_rtc.DataMessageFrame data_message = 23;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::data_message(this), target, stream);
  }

  // optional .signal_rtc.AudioTranscriptFrame audio_transcript = 24;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::audio_transcript(this), target, stream);
  }

  // optional .signal_rtc.RemoteVideoUpdateFrame remote_video_update = 25;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::remote_video_update(this), target, stream);
  }

  // optional .signal_rtc.PrimaryMeetingJoinFrame primary_meeting_join = 26;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::primary_meeting_join(this), target, stream);
  }

  // optional .signal_rtc.PrimaryMeetingJoinAckFrame primary_meeting_join_ack = 27;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::primary_meeting_join_ack(this), target, stream);
  }

  // optional .signal_rtc.PrimaryMeetingLeaveFrame primary_meeting_leave = 28;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        28, _Internal::primary_meeting_leave(this), target, stream);
  }

  // optional .signal_rtc.BridgeJoinFrame bridge_join = 29;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        29, _Internal::bridge_join(this), target, stream);
  }

  // optional .signal_rtc.BridgeJoinAckFrame bridge_join_ack = 30;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::bridge_join_ack(this), target, stream);
  }

  // optional .signal_rtc.BridgeReserveFrame bridge_reserve = 31;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::bridge_reserve(this), target, stream);
  }

  // optional .signal_rtc.BridgeReserveAckFrame bridge_reserve_ack = 32;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::bridge_reserve_ack(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.SignalFrame)
  return target;
}

size_t SignalFrame::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:signal_rtc.SignalFrame)
  size_t total_size = 0;

  if (_internal_has_timestamp_ms()) {
    // required uint64 timestamp_ms = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_timestamp_ms());
  }

  if (_internal_has_type()) {
    // required .signal_rtc.SignalFrame.Type type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t SignalFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.SignalFrame)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0c000000) ^ 0x0c000000) == 0) {  // All required fields are present.
    // required uint64 timestamp_ms = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_timestamp_ms());

    // required .signal_rtc.SignalFrame.Type type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .signal_rtc.ErrorFrame error = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional .signal_rtc.JoinFrame join = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *join_);
    }

    // optional .signal_rtc.JoinAckFrame joinack = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joinack_);
    }

    // optional .signal_rtc.SubscribeFrame sub = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sub_);
    }

    // optional .signal_rtc.SubscribeAckFrame suback = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *suback_);
    }

    // optional .signal_rtc.IndexFrame index = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_);
    }

    // optional .signal_rtc.PauseResumeFrame pause = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pause_);
    }

    // optional .signal_rtc.LeaveFrame leave = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *leave_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .signal_rtc.LeaveAckFrame leave_ack = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *leave_ack_);
    }

    // optional .signal_rtc.BitrateFrame bitrates = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bitrates_);
    }

    // optional .signal_rtc.AudioControlFrame audio_control = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_control_);
    }

    // optional .signal_rtc.AudioMetadataFrame audio_metadata = 18;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_metadata_);
    }

    // optional .signal_rtc.AudioStreamIdInfoFrame audio_stream_id_info = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_stream_id_info_);
    }

    // optional .signal_rtc.PingPongFrame ping_pong = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ping_pong_);
    }

    // optional .signal_rtc.AudioStatusFrame audio_status = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_status_);
    }

    // optional .signal_rtc.ClientMetricFrame client_metric = 22;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_metric_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .signal_rtc.DataMessageFrame data_message = 23;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_message_);
    }

    // optional .signal_rtc.AudioTranscriptFrame audio_transcript = 24;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_transcript_);
    }

    // optional .signal_rtc.RemoteVideoUpdateFrame remote_video_update = 25;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *remote_video_update_);
    }

    // optional .signal_rtc.PrimaryMeetingJoinFrame primary_meeting_join = 26;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *primary_meeting_join_);
    }

    // optional .signal_rtc.PrimaryMeetingJoinAckFrame primary_meeting_join_ack = 27;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *primary_meeting_join_ack_);
    }

    // optional .signal_rtc.PrimaryMeetingLeaveFrame primary_meeting_leave = 28;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *primary_meeting_leave_);
    }

    // optional .signal_rtc.BridgeJoinFrame bridge_join = 29;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bridge_join_);
    }

    // optional .signal_rtc.BridgeJoinAckFrame bridge_join_ack = 30;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bridge_join_ack_);
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional .signal_rtc.BridgeReserveFrame bridge_reserve = 31;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bridge_reserve_);
    }

    // optional .signal_rtc.BridgeReserveAckFrame bridge_reserve_ack = 32;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bridge_reserve_ack_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignalFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SignalFrame*>(
      &from));
}

void SignalFrame::MergeFrom(const SignalFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.SignalFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_error()->::signal_rtc::ErrorFrame::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_join()->::signal_rtc::JoinFrame::MergeFrom(from._internal_join());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_joinack()->::signal_rtc::JoinAckFrame::MergeFrom(from._internal_joinack());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_sub()->::signal_rtc::SubscribeFrame::MergeFrom(from._internal_sub());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_suback()->::signal_rtc::SubscribeAckFrame::MergeFrom(from._internal_suback());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_index()->::signal_rtc::IndexFrame::MergeFrom(from._internal_index());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_pause()->::signal_rtc::PauseResumeFrame::MergeFrom(from._internal_pause());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_leave()->::signal_rtc::LeaveFrame::MergeFrom(from._internal_leave());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_leave_ack()->::signal_rtc::LeaveAckFrame::MergeFrom(from._internal_leave_ack());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_bitrates()->::signal_rtc::BitrateFrame::MergeFrom(from._internal_bitrates());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_audio_control()->::signal_rtc::AudioControlFrame::MergeFrom(from._internal_audio_control());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_audio_metadata()->::signal_rtc::AudioMetadataFrame::MergeFrom(from._internal_audio_metadata());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_audio_stream_id_info()->::signal_rtc::AudioStreamIdInfoFrame::MergeFrom(from._internal_audio_stream_id_info());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_ping_pong()->::signal_rtc::PingPongFrame::MergeFrom(from._internal_ping_pong());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_audio_status()->::signal_rtc::AudioStatusFrame::MergeFrom(from._internal_audio_status());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_client_metric()->::signal_rtc::ClientMetricFrame::MergeFrom(from._internal_client_metric());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_data_message()->::signal_rtc::DataMessageFrame::MergeFrom(from._internal_data_message());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_audio_transcript()->::signal_rtc::AudioTranscriptFrame::MergeFrom(from._internal_audio_transcript());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_remote_video_update()->::signal_rtc::RemoteVideoUpdateFrame::MergeFrom(from._internal_remote_video_update());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_primary_meeting_join()->::signal_rtc::PrimaryMeetingJoinFrame::MergeFrom(from._internal_primary_meeting_join());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_primary_meeting_join_ack()->::signal_rtc::PrimaryMeetingJoinAckFrame::MergeFrom(from._internal_primary_meeting_join_ack());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_primary_meeting_leave()->::signal_rtc::PrimaryMeetingLeaveFrame::MergeFrom(from._internal_primary_meeting_leave());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_bridge_join()->::signal_rtc::BridgeJoinFrame::MergeFrom(from._internal_bridge_join());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_bridge_join_ack()->::signal_rtc::BridgeJoinAckFrame::MergeFrom(from._internal_bridge_join_ack());
    }
  }
  if (cached_has_bits & 0x0f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _internal_mutable_bridge_reserve()->::signal_rtc::BridgeReserveFrame::MergeFrom(from._internal_bridge_reserve());
    }
    if (cached_has_bits & 0x02000000u) {
      _internal_mutable_bridge_reserve_ack()->::signal_rtc::BridgeReserveAckFrame::MergeFrom(from._internal_bridge_reserve_ack());
    }
    if (cached_has_bits & 0x04000000u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x08000000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SignalFrame::CopyFrom(const SignalFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.SignalFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalFrame::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_ping_pong()) {
    if (!ping_pong_->IsInitialized()) return false;
  }
  if (_internal_has_remote_video_update()) {
    if (!remote_video_update_->IsInitialized()) return false;
  }
  return true;
}

void SignalFrame::InternalSwap(SignalFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignalFrame, timestamp_ms_)
      + sizeof(SignalFrame::timestamp_ms_)
      - PROTOBUF_FIELD_OFFSET(SignalFrame, error_)>(
          reinterpret_cast<char*>(&error_),
          reinterpret_cast<char*>(&other->error_));
  swap(type_, other->type_);
}

std::string SignalFrame::GetTypeName() const {
  return "signal_rtc.SignalFrame";
}


// ===================================================================

class ErrorFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorFrame>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ErrorFrame::ErrorFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.ErrorFrame)
}
ErrorFrame::ErrorFrame(const ErrorFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_description(),
      GetArena());
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.ErrorFrame)
}

void ErrorFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ErrorFrame_video_5fcontrol_2eproto.base);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_ = 0u;
}

ErrorFrame::~ErrorFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.ErrorFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ErrorFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ErrorFrame::ArenaDtor(void* object) {
  ErrorFrame* _this = reinterpret_cast< ErrorFrame* >(object);
  (void)_this;
}
void ErrorFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ErrorFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ErrorFrame& ErrorFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ErrorFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void ErrorFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.ErrorFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    description_.ClearNonDefaultToEmpty();
  }
  status_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ErrorFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ErrorFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.ErrorFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_status(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.ErrorFrame)
  return target;
}

size_t ErrorFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.ErrorFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional uint32 status = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErrorFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ErrorFrame*>(
      &from));
}

void ErrorFrame::MergeFrom(const ErrorFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.ErrorFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ErrorFrame::CopyFrom(const ErrorFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.ErrorFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorFrame::IsInitialized() const {
  return true;
}

void ErrorFrame::InternalSwap(ErrorFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(status_, other->status_);
}

std::string ErrorFrame::GetTypeName() const {
  return "signal_rtc.ErrorFrame";
}


// ===================================================================

class ClientDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDetails>()._has_bits_);
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_make(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_source(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_chime_sdk_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

ClientDetails::ClientDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.ClientDetails)
}
ClientDetails::ClientDetails(const ClientDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  app_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_app_name()) {
    app_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_app_name(),
      GetArena());
  }
  app_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_app_version()) {
    app_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_app_version(),
      GetArena());
  }
  device_model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_device_model()) {
    device_model_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_device_model(),
      GetArena());
  }
  device_make_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_device_make()) {
    device_make_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_device_make(),
      GetArena());
  }
  platform_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_platform_name()) {
    platform_name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_platform_name(),
      GetArena());
  }
  platform_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_platform_version()) {
    platform_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_platform_version(),
      GetArena());
  }
  client_source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_source()) {
    client_source_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_source(),
      GetArena());
  }
  chime_sdk_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_chime_sdk_version()) {
    chime_sdk_version_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_chime_sdk_version(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.ClientDetails)
}

void ClientDetails::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientDetails_video_5fcontrol_2eproto.base);
  app_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  app_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_make_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  platform_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  platform_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  client_source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  chime_sdk_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ClientDetails::~ClientDetails() {
  // @@protoc_insertion_point(destructor:signal_rtc.ClientDetails)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ClientDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  app_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  app_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_make_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  platform_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  platform_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  client_source_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  chime_sdk_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ClientDetails::ArenaDtor(void* object) {
  ClientDetails* _this = reinterpret_cast< ClientDetails* >(object);
  (void)_this;
}
void ClientDetails::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClientDetails::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientDetails& ClientDetails::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientDetails_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void ClientDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.ClientDetails)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      app_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      device_model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_make_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      platform_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      platform_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      client_source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      chime_sdk_version_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDetails::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string app_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_app_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string app_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_app_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string device_model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_device_model();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string device_make = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_device_make();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string platform_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_platform_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string platform_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_platform_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string client_source = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_client_source();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string chime_sdk_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_chime_sdk_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ClientDetails::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.ClientDetails)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string app_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_name(), target);
  }

  // optional string app_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_app_version(), target);
  }

  // optional string device_model = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_device_model(), target);
  }

  // optional string device_make = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_device_make(), target);
  }

  // optional string platform_name = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_platform_name(), target);
  }

  // optional string platform_version = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_platform_version(), target);
  }

  // optional string client_source = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_client_source(), target);
  }

  // optional string chime_sdk_version = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_chime_sdk_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.ClientDetails)
  return target;
}

size_t ClientDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.ClientDetails)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string app_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_name());
    }

    // optional string app_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_version());
    }

    // optional string device_model = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_model());
    }

    // optional string device_make = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_make());
    }

    // optional string platform_name = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform_name());
    }

    // optional string platform_version = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform_version());
    }

    // optional string client_source = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_source());
    }

    // optional string chime_sdk_version = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chime_sdk_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientDetails*>(
      &from));
}

void ClientDetails::MergeFrom(const ClientDetails& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.ClientDetails)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_app_version(from._internal_app_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_device_model(from._internal_device_model());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_make(from._internal_device_make());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_platform_name(from._internal_platform_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_platform_version(from._internal_platform_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_client_source(from._internal_client_source());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_chime_sdk_version(from._internal_chime_sdk_version());
    }
  }
}

void ClientDetails::CopyFrom(const ClientDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.ClientDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDetails::IsInitialized() const {
  return true;
}

void ClientDetails::InternalSwap(ClientDetails* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  app_name_.Swap(&other->app_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  app_version_.Swap(&other->app_version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  device_model_.Swap(&other->device_model_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  device_make_.Swap(&other->device_make_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  platform_name_.Swap(&other->platform_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  platform_version_.Swap(&other->platform_version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  client_source_.Swap(&other->client_source_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  chime_sdk_version_.Swap(&other->chime_sdk_version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string ClientDetails::GetTypeName() const {
  return "signal_rtc.ClientDetails";
}


// ===================================================================

class JoinFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinFrame>()._has_bits_);
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_num_of_videos(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::signal_rtc::ClientDetails& client_details(const JoinFrame* msg);
  static void set_has_client_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::signal_rtc::ClientDetails&
JoinFrame::_Internal::client_details(const JoinFrame* msg) {
  return *msg->client_details_;
}
JoinFrame::JoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  enabled_experiments_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.JoinFrame)
}
JoinFrame::JoinFrame(const JoinFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      enabled_experiments_(from.enabled_experiments_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client_details()) {
    client_details_ = new ::signal_rtc::ClientDetails(*from.client_details_);
  } else {
    client_details_ = nullptr;
  }
  ::memcpy(&audio_session_id_, &from.audio_session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_num_of_videos_) -
    reinterpret_cast<char*>(&audio_session_id_)) + sizeof(max_num_of_videos_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.JoinFrame)
}

void JoinFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_JoinFrame_video_5fcontrol_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&client_details_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&client_details_)) + sizeof(flags_));
  protocol_version_ = 2u;
  max_num_of_videos_ = 8u;
}

JoinFrame::~JoinFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.JoinFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void JoinFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete client_details_;
}

void JoinFrame::ArenaDtor(void* object) {
  JoinFrame* _this = reinterpret_cast< JoinFrame* >(object);
  (void)_this;
}
void JoinFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JoinFrame& JoinFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_JoinFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void JoinFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.JoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enabled_experiments_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(client_details_ != nullptr);
    client_details_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&audio_session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&audio_session_id_)) + sizeof(flags_));
    protocol_version_ = 2u;
    max_num_of_videos_ = 8u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 protocol_version = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_num_of_videos = 2 [default = 8];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_num_of_videos(&has_bits);
          max_num_of_videos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.ClientDetails client_details = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_details(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string enabled_experiments = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_enabled_experiments();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 audio_session_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_audio_session_id(&has_bits);
          audio_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* JoinFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.JoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 protocol_version = 1 [default = 2];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_protocol_version(), target);
  }

  // optional uint32 max_num_of_videos = 2 [default = 8];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_num_of_videos(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional .signal_rtc.ClientDetails client_details = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::client_details(this), target, stream);
  }

  // repeated string enabled_experiments = 5;
  for (int i = 0, n = this->_internal_enabled_experiments_size(); i < n; i++) {
    const auto& s = this->_internal_enabled_experiments(i);
    target = stream->WriteString(5, s, target);
  }

  // optional uint64 audio_session_id = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_audio_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.JoinFrame)
  return target;
}

size_t JoinFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.JoinFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string enabled_experiments = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(enabled_experiments_.size());
  for (int i = 0, n = enabled_experiments_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      enabled_experiments_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .signal_rtc.ClientDetails client_details = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_details_);
    }

    // optional uint64 audio_session_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_audio_session_id());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 protocol_version = 1 [default = 2];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_protocol_version());
    }

    // optional uint32 max_num_of_videos = 2 [default = 8];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_num_of_videos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinFrame*>(
      &from));
}

void JoinFrame::MergeFrom(const JoinFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.JoinFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  enabled_experiments_.MergeFrom(from.enabled_experiments_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client_details()->::signal_rtc::ClientDetails::MergeFrom(from._internal_client_details());
    }
    if (cached_has_bits & 0x00000002u) {
      audio_session_id_ = from.audio_session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      protocol_version_ = from.protocol_version_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_num_of_videos_ = from.max_num_of_videos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void JoinFrame::CopyFrom(const JoinFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.JoinFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinFrame::IsInitialized() const {
  return true;
}

void JoinFrame::InternalSwap(JoinFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  enabled_experiments_.InternalSwap(&other->enabled_experiments_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinFrame, flags_)
      + sizeof(JoinFrame::flags_)
      - PROTOBUF_FIELD_OFFSET(JoinFrame, client_details_)>(
          reinterpret_cast<char*>(&client_details_),
          reinterpret_cast<char*>(&other->client_details_));
  swap(protocol_version_, other->protocol_version_);
  swap(max_num_of_videos_, other->max_num_of_videos_);
}

std::string JoinFrame::GetTypeName() const {
  return "signal_rtc.JoinFrame";
}


// ===================================================================

class JoinAckFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinAckFrame>()._has_bits_);
  static const ::signal_rtc::TurnCredentials& turn_credentials(const JoinAckFrame* msg);
  static void set_has_turn_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_video_subscription_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::signal_rtc::TurnCredentials&
JoinAckFrame::_Internal::turn_credentials(const JoinAckFrame* msg) {
  return *msg->turn_credentials_;
}
JoinAckFrame::JoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.JoinAckFrame)
}
JoinAckFrame::JoinAckFrame(const JoinAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_turn_credentials()) {
    turn_credentials_ = new ::signal_rtc::TurnCredentials(*from.turn_credentials_);
  } else {
    turn_credentials_ = nullptr;
  }
  video_subscription_limit_ = from.video_subscription_limit_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.JoinAckFrame)
}

void JoinAckFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_JoinAckFrame_video_5fcontrol_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&turn_credentials_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&video_subscription_limit_) -
      reinterpret_cast<char*>(&turn_credentials_)) + sizeof(video_subscription_limit_));
}

JoinAckFrame::~JoinAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.JoinAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void JoinAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete turn_credentials_;
}

void JoinAckFrame::ArenaDtor(void* object) {
  JoinAckFrame* _this = reinterpret_cast< JoinAckFrame* >(object);
  (void)_this;
}
void JoinAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JoinAckFrame& JoinAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_JoinAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void JoinAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.JoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(turn_credentials_ != nullptr);
    turn_credentials_->Clear();
  }
  video_subscription_limit_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JoinAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.TurnCredentials turn_credentials = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_credentials(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 video_subscription_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_video_subscription_limit(&has_bits);
          video_subscription_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* JoinAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.JoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.TurnCredentials turn_credentials = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::turn_credentials(this), target, stream);
  }

  // optional uint32 video_subscription_limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_video_subscription_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.JoinAckFrame)
  return target;
}

size_t JoinAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.JoinAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .signal_rtc.TurnCredentials turn_credentials = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *turn_credentials_);
    }

    // optional uint32 video_subscription_limit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_video_subscription_limit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JoinAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const JoinAckFrame*>(
      &from));
}

void JoinAckFrame::MergeFrom(const JoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.JoinAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_turn_credentials()->::signal_rtc::TurnCredentials::MergeFrom(from._internal_turn_credentials());
    }
    if (cached_has_bits & 0x00000002u) {
      video_subscription_limit_ = from.video_subscription_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void JoinAckFrame::CopyFrom(const JoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.JoinAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinAckFrame::IsInitialized() const {
  return true;
}

void JoinAckFrame::InternalSwap(JoinAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinAckFrame, video_subscription_limit_)
      + sizeof(JoinAckFrame::video_subscription_limit_)
      - PROTOBUF_FIELD_OFFSET(JoinAckFrame, turn_credentials_)>(
          reinterpret_cast<char*>(&turn_credentials_),
          reinterpret_cast<char*>(&other->turn_credentials_));
}

std::string JoinAckFrame::GetTypeName() const {
  return "signal_rtc.JoinAckFrame";
}


// ===================================================================

class BridgeJoinFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BridgeJoinFrame>()._has_bits_);
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dtls_fingerprint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BridgeJoinFrame::BridgeJoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.BridgeJoinFrame)
}
BridgeJoinFrame::BridgeJoinFrame(const BridgeJoinFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  dtls_fingerprint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_dtls_fingerprint()) {
    dtls_fingerprint_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_dtls_fingerprint(),
      GetArena());
  }
  protocol_version_ = from.protocol_version_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.BridgeJoinFrame)
}

void BridgeJoinFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BridgeJoinFrame_video_5fcontrol_2eproto.base);
  dtls_fingerprint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  protocol_version_ = 1u;
}

BridgeJoinFrame::~BridgeJoinFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.BridgeJoinFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void BridgeJoinFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  dtls_fingerprint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BridgeJoinFrame::ArenaDtor(void* object) {
  BridgeJoinFrame* _this = reinterpret_cast< BridgeJoinFrame* >(object);
  (void)_this;
}
void BridgeJoinFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BridgeJoinFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BridgeJoinFrame& BridgeJoinFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BridgeJoinFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void BridgeJoinFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.BridgeJoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dtls_fingerprint_.ClearNonDefaultToEmpty();
    }
    protocol_version_ = 1u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BridgeJoinFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 protocol_version = 1 [default = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string dtls_fingerprint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_dtls_fingerprint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BridgeJoinFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.BridgeJoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 protocol_version = 1 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_protocol_version(), target);
  }

  // optional string dtls_fingerprint = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_dtls_fingerprint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.BridgeJoinFrame)
  return target;
}

size_t BridgeJoinFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.BridgeJoinFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string dtls_fingerprint = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dtls_fingerprint());
    }

    // optional uint32 protocol_version = 1 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BridgeJoinFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BridgeJoinFrame*>(
      &from));
}

void BridgeJoinFrame::MergeFrom(const BridgeJoinFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.BridgeJoinFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dtls_fingerprint(from._internal_dtls_fingerprint());
    }
    if (cached_has_bits & 0x00000002u) {
      protocol_version_ = from.protocol_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BridgeJoinFrame::CopyFrom(const BridgeJoinFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.BridgeJoinFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BridgeJoinFrame::IsInitialized() const {
  return true;
}

void BridgeJoinFrame::InternalSwap(BridgeJoinFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dtls_fingerprint_.Swap(&other->dtls_fingerprint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(protocol_version_, other->protocol_version_);
}

std::string BridgeJoinFrame::GetTypeName() const {
  return "signal_rtc.BridgeJoinFrame";
}


// ===================================================================

class BridgeJoinAckFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BridgeJoinAckFrame>()._has_bits_);
  static const ::signal_rtc::TurnCredentials& turn_credentials(const BridgeJoinAckFrame* msg);
  static void set_has_turn_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_listener_ip_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::signal_rtc::TurnCredentials&
BridgeJoinAckFrame::_Internal::turn_credentials(const BridgeJoinAckFrame* msg) {
  return *msg->turn_credentials_;
}
BridgeJoinAckFrame::BridgeJoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.BridgeJoinAckFrame)
}
BridgeJoinAckFrame::BridgeJoinAckFrame(const BridgeJoinAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  listener_ip_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_listener_ip_port()) {
    listener_ip_port_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_listener_ip_port(),
      GetArena());
  }
  if (from._internal_has_turn_credentials()) {
    turn_credentials_ = new ::signal_rtc::TurnCredentials(*from.turn_credentials_);
  } else {
    turn_credentials_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.BridgeJoinAckFrame)
}

void BridgeJoinAckFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto.base);
  listener_ip_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  turn_credentials_ = nullptr;
}

BridgeJoinAckFrame::~BridgeJoinAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.BridgeJoinAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void BridgeJoinAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  listener_ip_port_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete turn_credentials_;
}

void BridgeJoinAckFrame::ArenaDtor(void* object) {
  BridgeJoinAckFrame* _this = reinterpret_cast< BridgeJoinAckFrame* >(object);
  (void)_this;
}
void BridgeJoinAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BridgeJoinAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BridgeJoinAckFrame& BridgeJoinAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BridgeJoinAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void BridgeJoinAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.BridgeJoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      listener_ip_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(turn_credentials_ != nullptr);
      turn_credentials_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BridgeJoinAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.TurnCredentials turn_credentials = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_credentials(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string listener_ip_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_listener_ip_port();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BridgeJoinAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.BridgeJoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.TurnCredentials turn_credentials = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::turn_credentials(this), target, stream);
  }

  // optional string listener_ip_port = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_listener_ip_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.BridgeJoinAckFrame)
  return target;
}

size_t BridgeJoinAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.BridgeJoinAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string listener_ip_port = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_listener_ip_port());
    }

    // optional .signal_rtc.TurnCredentials turn_credentials = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *turn_credentials_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BridgeJoinAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BridgeJoinAckFrame*>(
      &from));
}

void BridgeJoinAckFrame::MergeFrom(const BridgeJoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.BridgeJoinAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_listener_ip_port(from._internal_listener_ip_port());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_turn_credentials()->::signal_rtc::TurnCredentials::MergeFrom(from._internal_turn_credentials());
    }
  }
}

void BridgeJoinAckFrame::CopyFrom(const BridgeJoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.BridgeJoinAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BridgeJoinAckFrame::IsInitialized() const {
  return true;
}

void BridgeJoinAckFrame::InternalSwap(BridgeJoinAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  listener_ip_port_.Swap(&other->listener_ip_port_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(turn_credentials_, other->turn_credentials_);
}

std::string BridgeJoinAckFrame::GetTypeName() const {
  return "signal_rtc.BridgeJoinAckFrame";
}


// ===================================================================

class LeaveFrame::_Internal {
 public:
};

LeaveFrame::LeaveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.LeaveFrame)
}
LeaveFrame::LeaveFrame(const LeaveFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.LeaveFrame)
}

void LeaveFrame::SharedCtor() {
}

LeaveFrame::~LeaveFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.LeaveFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LeaveFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LeaveFrame::ArenaDtor(void* object) {
  LeaveFrame* _this = reinterpret_cast< LeaveFrame* >(object);
  (void)_this;
}
void LeaveFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaveFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LeaveFrame& LeaveFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LeaveFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void LeaveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.LeaveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LeaveFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LeaveFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.LeaveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.LeaveFrame)
  return target;
}

size_t LeaveFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.LeaveFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaveFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LeaveFrame*>(
      &from));
}

void LeaveFrame::MergeFrom(const LeaveFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.LeaveFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void LeaveFrame::CopyFrom(const LeaveFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.LeaveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveFrame::IsInitialized() const {
  return true;
}

void LeaveFrame::InternalSwap(LeaveFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string LeaveFrame::GetTypeName() const {
  return "signal_rtc.LeaveFrame";
}


// ===================================================================

class LeaveAckFrame::_Internal {
 public:
};

LeaveAckFrame::LeaveAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.LeaveAckFrame)
}
LeaveAckFrame::LeaveAckFrame(const LeaveAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.LeaveAckFrame)
}

void LeaveAckFrame::SharedCtor() {
}

LeaveAckFrame::~LeaveAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.LeaveAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LeaveAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LeaveAckFrame::ArenaDtor(void* object) {
  LeaveAckFrame* _this = reinterpret_cast< LeaveAckFrame* >(object);
  (void)_this;
}
void LeaveAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaveAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LeaveAckFrame& LeaveAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LeaveAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void LeaveAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.LeaveAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LeaveAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LeaveAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.LeaveAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.LeaveAckFrame)
  return target;
}

size_t LeaveAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.LeaveAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaveAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LeaveAckFrame*>(
      &from));
}

void LeaveAckFrame::MergeFrom(const LeaveAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.LeaveAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void LeaveAckFrame::CopyFrom(const LeaveAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.LeaveAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveAckFrame::IsInitialized() const {
  return true;
}

void LeaveAckFrame::InternalSwap(LeaveAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string LeaveAckFrame::GetTypeName() const {
  return "signal_rtc.LeaveAckFrame";
}


// ===================================================================

class SubscribeFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscribeFrame>()._has_bits_);
  static void set_has_duplex(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sdp_offer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_xrp_host(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_xrp_checkin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_xrp_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SubscribeFrame::SubscribeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  send_streams_(arena),
  receive_stream_ids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.SubscribeFrame)
}
SubscribeFrame::SubscribeFrame(const SubscribeFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      send_streams_(from.send_streams_),
      receive_stream_ids_(from.receive_stream_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sdp_offer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sdp_offer()) {
    sdp_offer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_sdp_offer(),
      GetArena());
  }
  xrp_host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_xrp_host()) {
    xrp_host_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_xrp_host(),
      GetArena());
  }
  ::memcpy(&xrp_checkin_, &from.xrp_checkin_,
    static_cast<size_t>(reinterpret_cast<char*>(&duplex_) -
    reinterpret_cast<char*>(&xrp_checkin_)) + sizeof(duplex_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.SubscribeFrame)
}

void SubscribeFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SubscribeFrame_video_5fcontrol_2eproto.base);
  sdp_offer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  xrp_host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&xrp_checkin_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&xrp_muted_) -
      reinterpret_cast<char*>(&xrp_checkin_)) + sizeof(xrp_muted_));
  duplex_ = 1;
}

SubscribeFrame::~SubscribeFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.SubscribeFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void SubscribeFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sdp_offer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  xrp_host_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SubscribeFrame::ArenaDtor(void* object) {
  SubscribeFrame* _this = reinterpret_cast< SubscribeFrame* >(object);
  (void)_this;
}
void SubscribeFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscribeFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SubscribeFrame& SubscribeFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SubscribeFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void SubscribeFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.SubscribeFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  send_streams_.Clear();
  receive_stream_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sdp_offer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      xrp_host_.ClearNonDefaultToEmpty();
    }
  }
  ::memset(&xrp_checkin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&xrp_muted_) -
      reinterpret_cast<char*>(&xrp_checkin_)) + sizeof(xrp_muted_));
  duplex_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SubscribeFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.StreamServiceType duplex = 1 [default = RX];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::StreamServiceType_IsValid(val))) {
            _internal_set_duplex(static_cast<::signal_rtc::StreamServiceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.StreamDescriptor send_streams = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_send_streams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated uint32 receive_stream_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_receive_stream_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_receive_stream_ids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sdp_offer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_sdp_offer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string xrp_host = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_xrp_host();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool xrp_checkin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_xrp_checkin(&has_bits);
          xrp_checkin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool xrp_muted = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_xrp_muted(&has_bits);
          xrp_muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SubscribeFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.SubscribeFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.StreamServiceType duplex = 1 [default = RX];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_duplex(), target);
  }

  // repeated .signal_rtc.StreamDescriptor send_streams = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_send_streams_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_send_streams(i), target, stream);
  }

  // repeated uint32 receive_stream_ids = 3;
  for (int i = 0, n = this->_internal_receive_stream_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_receive_stream_ids(i), target);
  }

  // optional string sdp_offer = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sdp_offer(), target);
  }

  // optional string xrp_host = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_xrp_host(), target);
  }

  // optional bool xrp_checkin = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_xrp_checkin(), target);
  }

  // optional bool xrp_muted = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_xrp_muted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.SubscribeFrame)
  return target;
}

size_t SubscribeFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.SubscribeFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.StreamDescriptor send_streams = 2;
  total_size += 1UL * this->_internal_send_streams_size();
  for (const auto& msg : this->send_streams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 receive_stream_ids = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->receive_stream_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_receive_stream_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string sdp_offer = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sdp_offer());
    }

    // optional string xrp_host = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_xrp_host());
    }

    // optional bool xrp_checkin = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool xrp_muted = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .signal_rtc.StreamServiceType duplex = 1 [default = RX];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_duplex());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscribeFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SubscribeFrame*>(
      &from));
}

void SubscribeFrame::MergeFrom(const SubscribeFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.SubscribeFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  send_streams_.MergeFrom(from.send_streams_);
  receive_stream_ids_.MergeFrom(from.receive_stream_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sdp_offer(from._internal_sdp_offer());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_xrp_host(from._internal_xrp_host());
    }
    if (cached_has_bits & 0x00000004u) {
      xrp_checkin_ = from.xrp_checkin_;
    }
    if (cached_has_bits & 0x00000008u) {
      xrp_muted_ = from.xrp_muted_;
    }
    if (cached_has_bits & 0x00000010u) {
      duplex_ = from.duplex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SubscribeFrame::CopyFrom(const SubscribeFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.SubscribeFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeFrame::IsInitialized() const {
  return true;
}

void SubscribeFrame::InternalSwap(SubscribeFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  send_streams_.InternalSwap(&other->send_streams_);
  receive_stream_ids_.InternalSwap(&other->receive_stream_ids_);
  sdp_offer_.Swap(&other->sdp_offer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  xrp_host_.Swap(&other->xrp_host_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubscribeFrame, xrp_muted_)
      + sizeof(SubscribeFrame::xrp_muted_)
      - PROTOBUF_FIELD_OFFSET(SubscribeFrame, xrp_checkin_)>(
          reinterpret_cast<char*>(&xrp_checkin_),
          reinterpret_cast<char*>(&other->xrp_checkin_));
  swap(duplex_, other->duplex_);
}

std::string SubscribeFrame::GetTypeName() const {
  return "signal_rtc.SubscribeFrame";
}


// ===================================================================

class SubscribeAckFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscribeAckFrame>()._has_bits_);
  static void set_has_duplex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sdp_answer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SubscribeAckFrame::SubscribeAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  allocations_(arena),
  tracks_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.SubscribeAckFrame)
}
SubscribeAckFrame::SubscribeAckFrame(const SubscribeAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      allocations_(from.allocations_),
      tracks_(from.tracks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sdp_answer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sdp_answer()) {
    sdp_answer_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_sdp_answer(),
      GetArena());
  }
  duplex_ = from.duplex_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.SubscribeAckFrame)
}

void SubscribeAckFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SubscribeAckFrame_video_5fcontrol_2eproto.base);
  sdp_answer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  duplex_ = 1;
}

SubscribeAckFrame::~SubscribeAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.SubscribeAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void SubscribeAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sdp_answer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SubscribeAckFrame::ArenaDtor(void* object) {
  SubscribeAckFrame* _this = reinterpret_cast< SubscribeAckFrame* >(object);
  (void)_this;
}
void SubscribeAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscribeAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SubscribeAckFrame& SubscribeAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SubscribeAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void SubscribeAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.SubscribeAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allocations_.Clear();
  tracks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sdp_answer_.ClearNonDefaultToEmpty();
    }
    duplex_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SubscribeAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.StreamServiceType duplex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::StreamServiceType_IsValid(val))) {
            _internal_set_duplex(static_cast<::signal_rtc::StreamServiceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.StreamAllocation allocations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allocations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string sdp_answer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_sdp_answer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.TrackMapping tracks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tracks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SubscribeAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.SubscribeAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.StreamServiceType duplex = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_duplex(), target);
  }

  // repeated .signal_rtc.StreamAllocation allocations = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_allocations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_allocations(i), target, stream);
  }

  // optional string sdp_answer = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sdp_answer(), target);
  }

  // repeated .signal_rtc.TrackMapping tracks = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tracks_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_tracks(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.SubscribeAckFrame)
  return target;
}

size_t SubscribeAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.SubscribeAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.StreamAllocation allocations = 2;
  total_size += 1UL * this->_internal_allocations_size();
  for (const auto& msg : this->allocations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .signal_rtc.TrackMapping tracks = 4;
  total_size += 1UL * this->_internal_tracks_size();
  for (const auto& msg : this->tracks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string sdp_answer = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sdp_answer());
    }

    // optional .signal_rtc.StreamServiceType duplex = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_duplex());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscribeAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SubscribeAckFrame*>(
      &from));
}

void SubscribeAckFrame::MergeFrom(const SubscribeAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.SubscribeAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  allocations_.MergeFrom(from.allocations_);
  tracks_.MergeFrom(from.tracks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sdp_answer(from._internal_sdp_answer());
    }
    if (cached_has_bits & 0x00000002u) {
      duplex_ = from.duplex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SubscribeAckFrame::CopyFrom(const SubscribeAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.SubscribeAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeAckFrame::IsInitialized() const {
  return true;
}

void SubscribeAckFrame::InternalSwap(SubscribeAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allocations_.InternalSwap(&other->allocations_);
  tracks_.InternalSwap(&other->tracks_);
  sdp_answer_.Swap(&other->sdp_answer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(duplex_, other->duplex_);
}

std::string SubscribeAckFrame::GetTypeName() const {
  return "signal_rtc.SubscribeAckFrame";
}


// ===================================================================

class IndexFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexFrame>()._has_bits_);
  static void set_has_at_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_participants(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IndexFrame::IndexFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  sources_(arena),
  paused_at_source_ids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.IndexFrame)
}
IndexFrame::IndexFrame(const IndexFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      sources_(from.sources_),
      paused_at_source_ids_(from.paused_at_source_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&at_capacity_, &from.at_capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_participants_) -
    reinterpret_cast<char*>(&at_capacity_)) + sizeof(num_participants_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.IndexFrame)
}

void IndexFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IndexFrame_video_5fcontrol_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&at_capacity_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&num_participants_) -
      reinterpret_cast<char*>(&at_capacity_)) + sizeof(num_participants_));
}

IndexFrame::~IndexFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.IndexFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void IndexFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void IndexFrame::ArenaDtor(void* object) {
  IndexFrame* _this = reinterpret_cast< IndexFrame* >(object);
  (void)_this;
}
void IndexFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IndexFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IndexFrame& IndexFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IndexFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void IndexFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.IndexFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sources_.Clear();
  paused_at_source_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&at_capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_participants_) -
        reinterpret_cast<char*>(&at_capacity_)) + sizeof(num_participants_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IndexFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool at_capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_at_capacity(&has_bits);
          at_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.StreamDescriptor sources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated uint32 paused_at_source_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_paused_at_source_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_paused_at_source_ids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 num_participants = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_num_participants(&has_bits);
          num_participants_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IndexFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.IndexFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool at_capacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_at_capacity(), target);
  }

  // repeated .signal_rtc.StreamDescriptor sources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_sources(i), target, stream);
  }

  // repeated uint32 paused_at_source_ids = 3;
  for (int i = 0, n = this->_internal_paused_at_source_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_paused_at_source_ids(i), target);
  }

  // optional uint32 num_participants = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_participants(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.IndexFrame)
  return target;
}

size_t IndexFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.IndexFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.StreamDescriptor sources = 2;
  total_size += 1UL * this->_internal_sources_size();
  for (const auto& msg : this->sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 paused_at_source_ids = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->paused_at_source_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_paused_at_source_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool at_capacity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 num_participants = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_num_participants());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IndexFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IndexFrame*>(
      &from));
}

void IndexFrame::MergeFrom(const IndexFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.IndexFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sources_.MergeFrom(from.sources_);
  paused_at_source_ids_.MergeFrom(from.paused_at_source_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      at_capacity_ = from.at_capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_participants_ = from.num_participants_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IndexFrame::CopyFrom(const IndexFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.IndexFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexFrame::IsInitialized() const {
  return true;
}

void IndexFrame::InternalSwap(IndexFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sources_.InternalSwap(&other->sources_);
  paused_at_source_ids_.InternalSwap(&other->paused_at_source_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexFrame, num_participants_)
      + sizeof(IndexFrame::num_participants_)
      - PROTOBUF_FIELD_OFFSET(IndexFrame, at_capacity_)>(
          reinterpret_cast<char*>(&at_capacity_),
          reinterpret_cast<char*>(&other->at_capacity_));
}

std::string IndexFrame::GetTypeName() const {
  return "signal_rtc.IndexFrame";
}


// ===================================================================

class PauseResumeFrame::_Internal {
 public:
};

PauseResumeFrame::PauseResumeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  stream_ids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.PauseResumeFrame)
}
PauseResumeFrame::PauseResumeFrame(const PauseResumeFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      stream_ids_(from.stream_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.PauseResumeFrame)
}

void PauseResumeFrame::SharedCtor() {
}

PauseResumeFrame::~PauseResumeFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.PauseResumeFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PauseResumeFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PauseResumeFrame::ArenaDtor(void* object) {
  PauseResumeFrame* _this = reinterpret_cast< PauseResumeFrame* >(object);
  (void)_this;
}
void PauseResumeFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PauseResumeFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PauseResumeFrame& PauseResumeFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PauseResumeFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void PauseResumeFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.PauseResumeFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stream_ids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PauseResumeFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated uint32 stream_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stream_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_stream_ids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PauseResumeFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.PauseResumeFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 stream_ids = 1;
  for (int i = 0, n = this->_internal_stream_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stream_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.PauseResumeFrame)
  return target;
}

size_t PauseResumeFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.PauseResumeFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 stream_ids = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->stream_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_stream_ids_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PauseResumeFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PauseResumeFrame*>(
      &from));
}

void PauseResumeFrame::MergeFrom(const PauseResumeFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.PauseResumeFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  stream_ids_.MergeFrom(from.stream_ids_);
}

void PauseResumeFrame::CopyFrom(const PauseResumeFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.PauseResumeFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PauseResumeFrame::IsInitialized() const {
  return true;
}

void PauseResumeFrame::InternalSwap(PauseResumeFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  stream_ids_.InternalSwap(&other->stream_ids_);
}

std::string PauseResumeFrame::GetTypeName() const {
  return "signal_rtc.PauseResumeFrame";
}


// ===================================================================

class BitrateFrame::_Internal {
 public:
};

BitrateFrame::BitrateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  bitrates_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.BitrateFrame)
}
BitrateFrame::BitrateFrame(const BitrateFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      bitrates_(from.bitrates_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.BitrateFrame)
}

void BitrateFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BitrateFrame_video_5fcontrol_2eproto.base);
}

BitrateFrame::~BitrateFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.BitrateFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void BitrateFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void BitrateFrame::ArenaDtor(void* object) {
  BitrateFrame* _this = reinterpret_cast< BitrateFrame* >(object);
  (void)_this;
}
void BitrateFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BitrateFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BitrateFrame& BitrateFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BitrateFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void BitrateFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.BitrateFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bitrates_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BitrateFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.Bitrate bitrates = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bitrates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BitrateFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.BitrateFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.Bitrate bitrates = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bitrates_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_bitrates(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.BitrateFrame)
  return target;
}

size_t BitrateFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.BitrateFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.Bitrate bitrates = 1;
  total_size += 1UL * this->_internal_bitrates_size();
  for (const auto& msg : this->bitrates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitrateFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BitrateFrame*>(
      &from));
}

void BitrateFrame::MergeFrom(const BitrateFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.BitrateFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  bitrates_.MergeFrom(from.bitrates_);
}

void BitrateFrame::CopyFrom(const BitrateFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.BitrateFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitrateFrame::IsInitialized() const {
  return true;
}

void BitrateFrame::InternalSwap(BitrateFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  bitrates_.InternalSwap(&other->bitrates_);
}

std::string BitrateFrame::GetTypeName() const {
  return "signal_rtc.BitrateFrame";
}


// ===================================================================

class StreamDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamDescriptor>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_track_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_avg_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_profile_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_media_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_external_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StreamDescriptor::StreamDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.StreamDescriptor)
}
StreamDescriptor::StreamDescriptor(const StreamDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_track_label()) {
    track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_track_label(),
      GetArena());
  }
  profile_uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_profile_uuid()) {
    profile_uuid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_profile_uuid(),
      GetArena());
  }
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_external_user_id()) {
    external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_external_user_id(),
      GetArena());
  }
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&media_type_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(media_type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.StreamDescriptor)
}

void StreamDescriptor::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StreamDescriptor_video_5fcontrol_2eproto.base);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  profile_uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&avg_bitrate_bps_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(avg_bitrate_bps_));
  media_type_ = 1;
}

StreamDescriptor::~StreamDescriptor() {
  // @@protoc_insertion_point(destructor:signal_rtc.StreamDescriptor)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void StreamDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  track_label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  profile_uuid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StreamDescriptor::ArenaDtor(void* object) {
  StreamDescriptor* _this = reinterpret_cast< StreamDescriptor* >(object);
  (void)_this;
}
void StreamDescriptor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StreamDescriptor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StreamDescriptor& StreamDescriptor::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StreamDescriptor_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void StreamDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.StreamDescriptor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      track_label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      profile_uuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      external_user_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_id_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
  }
  if (cached_has_bits & 0x00000300u) {
    avg_bitrate_bps_ = 0u;
    media_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamDescriptor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 framerate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_framerate(&has_bits);
          framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_bitrate_kbps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_bitrate_kbps(&has_bits);
          max_bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string track_label = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_track_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 profile_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_profile_id(&has_bits);
          profile_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 avg_bitrate_bps = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_avg_bitrate_bps(&has_bits);
          avg_bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string profile_uuid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_profile_uuid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.StreamMediaType media_type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::StreamMediaType_IsValid(val))) {
            _internal_set_media_type(static_cast<::signal_rtc::StreamMediaType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string external_user_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_external_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StreamDescriptor::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.StreamDescriptor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 stream_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_framerate(), target);
  }

  // optional uint32 max_bitrate_kbps = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_max_bitrate_kbps(), target);
  }

  // optional string track_label = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_track_label(), target);
  }

  // optional uint32 profile_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_profile_id(), target);
  }

  // optional uint32 group_id = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_group_id(), target);
  }

  // optional uint32 avg_bitrate_bps = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_avg_bitrate_bps(), target);
  }

  // optional string profile_uuid = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_profile_uuid(), target);
  }

  // optional .signal_rtc.StreamMediaType media_type = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_media_type(), target);
  }

  // optional string external_user_id = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_external_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.StreamDescriptor)
  return target;
}

size_t StreamDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.StreamDescriptor)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string track_label = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_track_label());
    }

    // optional string profile_uuid = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profile_uuid());
    }

    // optional string external_user_id = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_external_user_id());
    }

    // optional uint32 stream_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stream_id());
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_framerate());
    }

    // optional uint32 max_bitrate_kbps = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_bitrate_kbps());
    }

    // optional uint32 profile_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_profile_id());
    }

    // optional uint32 group_id = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_group_id());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 avg_bitrate_bps = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_avg_bitrate_bps());
    }

    // optional .signal_rtc.StreamMediaType media_type = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_media_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamDescriptor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StreamDescriptor*>(
      &from));
}

void StreamDescriptor::MergeFrom(const StreamDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.StreamDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_track_label(from._internal_track_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_profile_uuid(from._internal_profile_uuid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_external_user_id(from._internal_external_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_bitrate_kbps_ = from.max_bitrate_kbps_;
    }
    if (cached_has_bits & 0x00000040u) {
      profile_id_ = from.profile_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      avg_bitrate_bps_ = from.avg_bitrate_bps_;
    }
    if (cached_has_bits & 0x00000200u) {
      media_type_ = from.media_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StreamDescriptor::CopyFrom(const StreamDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.StreamDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamDescriptor::IsInitialized() const {
  return true;
}

void StreamDescriptor::InternalSwap(StreamDescriptor* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  track_label_.Swap(&other->track_label_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  profile_uuid_.Swap(&other->profile_uuid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  external_user_id_.Swap(&other->external_user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamDescriptor, avg_bitrate_bps_)
      + sizeof(StreamDescriptor::avg_bitrate_bps_)
      - PROTOBUF_FIELD_OFFSET(StreamDescriptor, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
  swap(media_type_, other->media_type_);
}

std::string StreamDescriptor::GetTypeName() const {
  return "signal_rtc.StreamDescriptor";
}


// ===================================================================

class StreamAllocation::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamAllocation>()._has_bits_);
  static void set_has_track_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StreamAllocation::StreamAllocation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.StreamAllocation)
}
StreamAllocation::StreamAllocation(const StreamAllocation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_track_label()) {
    track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_track_label(),
      GetArena());
  }
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.StreamAllocation)
}

void StreamAllocation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StreamAllocation_video_5fcontrol_2eproto.base);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
}

StreamAllocation::~StreamAllocation() {
  // @@protoc_insertion_point(destructor:signal_rtc.StreamAllocation)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void StreamAllocation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  track_label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StreamAllocation::ArenaDtor(void* object) {
  StreamAllocation* _this = reinterpret_cast< StreamAllocation* >(object);
  (void)_this;
}
void StreamAllocation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StreamAllocation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StreamAllocation& StreamAllocation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StreamAllocation_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void StreamAllocation::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.StreamAllocation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    track_label_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_id_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamAllocation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string track_label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_track_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 stream_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StreamAllocation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.StreamAllocation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string track_label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_track_label(), target);
  }

  // optional uint32 stream_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stream_id(), target);
  }

  // optional uint32 group_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_group_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.StreamAllocation)
  return target;
}

size_t StreamAllocation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.StreamAllocation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string track_label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_track_label());
    }

    // optional uint32 stream_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stream_id());
    }

    // optional uint32 group_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_group_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamAllocation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StreamAllocation*>(
      &from));
}

void StreamAllocation::MergeFrom(const StreamAllocation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.StreamAllocation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_track_label(from._internal_track_label());
    }
    if (cached_has_bits & 0x00000002u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StreamAllocation::CopyFrom(const StreamAllocation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.StreamAllocation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamAllocation::IsInitialized() const {
  return true;
}

void StreamAllocation::InternalSwap(StreamAllocation* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  track_label_.Swap(&other->track_label_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamAllocation, group_id_)
      + sizeof(StreamAllocation::group_id_)
      - PROTOBUF_FIELD_OFFSET(StreamAllocation, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string StreamAllocation::GetTypeName() const {
  return "signal_rtc.StreamAllocation";
}


// ===================================================================

class TrackMapping::_Internal {
 public:
  using HasBits = decltype(std::declval<TrackMapping>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_track_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TrackMapping::TrackMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.TrackMapping)
}
TrackMapping::TrackMapping(const TrackMapping& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_track_label()) {
    track_label_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_track_label(),
      GetArena());
  }
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ssrc_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(ssrc_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.TrackMapping)
}

void TrackMapping::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrackMapping_video_5fcontrol_2eproto.base);
  track_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&ssrc_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(ssrc_));
}

TrackMapping::~TrackMapping() {
  // @@protoc_insertion_point(destructor:signal_rtc.TrackMapping)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TrackMapping::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  track_label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TrackMapping::ArenaDtor(void* object) {
  TrackMapping* _this = reinterpret_cast< TrackMapping* >(object);
  (void)_this;
}
void TrackMapping::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrackMapping::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrackMapping& TrackMapping::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrackMapping_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void TrackMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.TrackMapping)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    track_label_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ssrc_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(ssrc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TrackMapping::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ssrc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ssrc(&has_bits);
          ssrc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string track_label = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_track_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrackMapping::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.TrackMapping)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 stream_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // optional uint32 ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ssrc(), target);
  }

  // optional string track_label = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_track_label(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.TrackMapping)
  return target;
}

size_t TrackMapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.TrackMapping)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string track_label = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_track_label());
    }

    // optional uint32 stream_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stream_id());
    }

    // optional uint32 ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrackMapping::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TrackMapping*>(
      &from));
}

void TrackMapping::MergeFrom(const TrackMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.TrackMapping)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_track_label(from._internal_track_label());
    }
    if (cached_has_bits & 0x00000002u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      ssrc_ = from.ssrc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrackMapping::CopyFrom(const TrackMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.TrackMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackMapping::IsInitialized() const {
  return true;
}

void TrackMapping::InternalSwap(TrackMapping* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  track_label_.Swap(&other->track_label_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackMapping, ssrc_)
      + sizeof(TrackMapping::ssrc_)
      - PROTOBUF_FIELD_OFFSET(TrackMapping, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string TrackMapping::GetTypeName() const {
  return "signal_rtc.TrackMapping";
}


// ===================================================================

class Bitrate::_Internal {
 public:
  using HasBits = decltype(std::declval<Bitrate>()._has_bits_);
  static void set_has_source_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avg_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Bitrate::Bitrate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.Bitrate)
}
Bitrate::Bitrate(const Bitrate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&source_stream_id_, &from.source_stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&avg_bitrate_bps_) -
    reinterpret_cast<char*>(&source_stream_id_)) + sizeof(avg_bitrate_bps_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.Bitrate)
}

void Bitrate::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&source_stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&avg_bitrate_bps_) -
      reinterpret_cast<char*>(&source_stream_id_)) + sizeof(avg_bitrate_bps_));
}

Bitrate::~Bitrate() {
  // @@protoc_insertion_point(destructor:signal_rtc.Bitrate)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Bitrate::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Bitrate::ArenaDtor(void* object) {
  Bitrate* _this = reinterpret_cast< Bitrate* >(object);
  (void)_this;
}
void Bitrate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bitrate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Bitrate& Bitrate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Bitrate_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void Bitrate::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.Bitrate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&source_stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&avg_bitrate_bps_) -
        reinterpret_cast<char*>(&source_stream_id_)) + sizeof(avg_bitrate_bps_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Bitrate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 source_stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_source_stream_id(&has_bits);
          source_stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 avg_bitrate_bps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_avg_bitrate_bps(&has_bits);
          avg_bitrate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Bitrate::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.Bitrate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 source_stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source_stream_id(), target);
  }

  // optional uint32 avg_bitrate_bps = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_avg_bitrate_bps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.Bitrate)
  return target;
}

size_t Bitrate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.Bitrate)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 source_stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_source_stream_id());
    }

    // optional uint32 avg_bitrate_bps = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_avg_bitrate_bps());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Bitrate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Bitrate*>(
      &from));
}

void Bitrate::MergeFrom(const Bitrate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.Bitrate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      source_stream_id_ = from.source_stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      avg_bitrate_bps_ = from.avg_bitrate_bps_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Bitrate::CopyFrom(const Bitrate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.Bitrate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bitrate::IsInitialized() const {
  return true;
}

void Bitrate::InternalSwap(Bitrate* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bitrate, avg_bitrate_bps_)
      + sizeof(Bitrate::avg_bitrate_bps_)
      - PROTOBUF_FIELD_OFFSET(Bitrate, source_stream_id_)>(
          reinterpret_cast<char*>(&source_stream_id_),
          reinterpret_cast<char*>(&other->source_stream_id_));
}

std::string Bitrate::GetTypeName() const {
  return "signal_rtc.Bitrate";
}


// ===================================================================

class AudioControlFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioControlFrame>()._has_bits_);
  static void set_has_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AudioControlFrame::AudioControlFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioControlFrame)
}
AudioControlFrame::AudioControlFrame(const AudioControlFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  muted_ = from.muted_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioControlFrame)
}

void AudioControlFrame::SharedCtor() {
  muted_ = false;
}

AudioControlFrame::~AudioControlFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioControlFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioControlFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioControlFrame::ArenaDtor(void* object) {
  AudioControlFrame* _this = reinterpret_cast< AudioControlFrame* >(object);
  (void)_this;
}
void AudioControlFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioControlFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioControlFrame& AudioControlFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioControlFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioControlFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioControlFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  muted_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioControlFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool muted = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_muted(&has_bits);
          muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioControlFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioControlFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool muted = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_muted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioControlFrame)
  return target;
}

size_t AudioControlFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioControlFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool muted = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioControlFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioControlFrame*>(
      &from));
}

void AudioControlFrame::MergeFrom(const AudioControlFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioControlFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_muted()) {
    _internal_set_muted(from._internal_muted());
  }
}

void AudioControlFrame::CopyFrom(const AudioControlFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioControlFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioControlFrame::IsInitialized() const {
  return true;
}

void AudioControlFrame::InternalSwap(AudioControlFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(muted_, other->muted_);
}

std::string AudioControlFrame::GetTypeName() const {
  return "signal_rtc.AudioControlFrame";
}


// ===================================================================

class AudioMetadataFrame::_Internal {
 public:
};

AudioMetadataFrame::AudioMetadataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  profile_states_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioMetadataFrame)
}
AudioMetadataFrame::AudioMetadataFrame(const AudioMetadataFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      profile_states_(from.profile_states_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioMetadataFrame)
}

void AudioMetadataFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioMetadataFrame_video_5fcontrol_2eproto.base);
}

AudioMetadataFrame::~AudioMetadataFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioMetadataFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioMetadataFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioMetadataFrame::ArenaDtor(void* object) {
  AudioMetadataFrame* _this = reinterpret_cast< AudioMetadataFrame* >(object);
  (void)_this;
}
void AudioMetadataFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioMetadataFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioMetadataFrame& AudioMetadataFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioMetadataFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioMetadataFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioMetadataFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  profile_states_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioMetadataFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioProfileState profile_states = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_profile_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioMetadataFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioMetadataFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioProfileState profile_states = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_profile_states_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_profile_states(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioMetadataFrame)
  return target;
}

size_t AudioMetadataFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioMetadataFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioProfileState profile_states = 1;
  total_size += 1UL * this->_internal_profile_states_size();
  for (const auto& msg : this->profile_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioMetadataFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioMetadataFrame*>(
      &from));
}

void AudioMetadataFrame::MergeFrom(const AudioMetadataFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioMetadataFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  profile_states_.MergeFrom(from.profile_states_);
}

void AudioMetadataFrame::CopyFrom(const AudioMetadataFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioMetadataFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioMetadataFrame::IsInitialized() const {
  return true;
}

void AudioMetadataFrame::InternalSwap(AudioMetadataFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  profile_states_.InternalSwap(&other->profile_states_);
}

std::string AudioMetadataFrame::GetTypeName() const {
  return "signal_rtc.AudioMetadataFrame";
}


// ===================================================================

class AudioProfileState::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioProfileState>()._has_bits_);
  static void set_has_audio_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_signal_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ntp_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

AudioProfileState::AudioProfileState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioProfileState)
}
AudioProfileState::AudioProfileState(const AudioProfileState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&audio_stream_id_, &from.audio_stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ntp_timestamp_) -
    reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(ntp_timestamp_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioProfileState)
}

void AudioProfileState::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&audio_stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&ntp_timestamp_) -
      reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(ntp_timestamp_));
}

AudioProfileState::~AudioProfileState() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioProfileState)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioProfileState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioProfileState::ArenaDtor(void* object) {
  AudioProfileState* _this = reinterpret_cast< AudioProfileState* >(object);
  (void)_this;
}
void AudioProfileState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioProfileState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioProfileState& AudioProfileState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioProfileState_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioProfileState::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioProfileState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&audio_stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ntp_timestamp_) -
        reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(ntp_timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioProfileState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 audio_stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_audio_stream_id(&has_bits);
          audio_stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volume = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_volume(&has_bits);
          volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool muted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_muted(&has_bits);
          muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 signal_strength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_signal_strength(&has_bits);
          signal_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed64 ntp_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_ntp_timestamp(&has_bits);
          ntp_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioProfileState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioProfileState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 audio_stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_audio_stream_id(), target);
  }

  // optional uint32 volume = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_volume(), target);
  }

  // optional bool muted = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_muted(), target);
  }

  // optional uint32 signal_strength = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_signal_strength(), target);
  }

  // optional fixed64 ntp_timestamp = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(5, this->_internal_ntp_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioProfileState)
  return target;
}

size_t AudioProfileState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioProfileState)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 audio_stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_audio_stream_id());
    }

    // optional uint32 volume = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_volume());
    }

    // optional bool muted = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 signal_strength = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_signal_strength());
    }

    // optional fixed64 ntp_timestamp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioProfileState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioProfileState*>(
      &from));
}

void AudioProfileState::MergeFrom(const AudioProfileState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioProfileState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      audio_stream_id_ = from.audio_stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      volume_ = from.volume_;
    }
    if (cached_has_bits & 0x00000004u) {
      muted_ = from.muted_;
    }
    if (cached_has_bits & 0x00000008u) {
      signal_strength_ = from.signal_strength_;
    }
    if (cached_has_bits & 0x00000010u) {
      ntp_timestamp_ = from.ntp_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AudioProfileState::CopyFrom(const AudioProfileState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioProfileState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioProfileState::IsInitialized() const {
  return true;
}

void AudioProfileState::InternalSwap(AudioProfileState* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioProfileState, ntp_timestamp_)
      + sizeof(AudioProfileState::ntp_timestamp_)
      - PROTOBUF_FIELD_OFFSET(AudioProfileState, audio_stream_id_)>(
          reinterpret_cast<char*>(&audio_stream_id_),
          reinterpret_cast<char*>(&other->audio_stream_id_));
}

std::string AudioProfileState::GetTypeName() const {
  return "signal_rtc.AudioProfileState";
}


// ===================================================================

class AudioStreamIdInfoFrame::_Internal {
 public:
};

AudioStreamIdInfoFrame::AudioStreamIdInfoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  streams_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioStreamIdInfoFrame)
}
AudioStreamIdInfoFrame::AudioStreamIdInfoFrame(const AudioStreamIdInfoFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      streams_(from.streams_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioStreamIdInfoFrame)
}

void AudioStreamIdInfoFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto.base);
}

AudioStreamIdInfoFrame::~AudioStreamIdInfoFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioStreamIdInfoFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioStreamIdInfoFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioStreamIdInfoFrame::ArenaDtor(void* object) {
  AudioStreamIdInfoFrame* _this = reinterpret_cast< AudioStreamIdInfoFrame* >(object);
  (void)_this;
}
void AudioStreamIdInfoFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioStreamIdInfoFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioStreamIdInfoFrame& AudioStreamIdInfoFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioStreamIdInfoFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioStreamIdInfoFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioStreamIdInfoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  streams_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioStreamIdInfoFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioStreamIdInfo streams = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_streams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioStreamIdInfoFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioStreamIdInfoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioStreamIdInfo streams = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_streams_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_streams(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioStreamIdInfoFrame)
  return target;
}

size_t AudioStreamIdInfoFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioStreamIdInfoFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioStreamIdInfo streams = 1;
  total_size += 1UL * this->_internal_streams_size();
  for (const auto& msg : this->streams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioStreamIdInfoFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioStreamIdInfoFrame*>(
      &from));
}

void AudioStreamIdInfoFrame::MergeFrom(const AudioStreamIdInfoFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioStreamIdInfoFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  streams_.MergeFrom(from.streams_);
}

void AudioStreamIdInfoFrame::CopyFrom(const AudioStreamIdInfoFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioStreamIdInfoFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamIdInfoFrame::IsInitialized() const {
  return true;
}

void AudioStreamIdInfoFrame::InternalSwap(AudioStreamIdInfoFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  streams_.InternalSwap(&other->streams_);
}

std::string AudioStreamIdInfoFrame::GetTypeName() const {
  return "signal_rtc.AudioStreamIdInfoFrame";
}


// ===================================================================

class AudioStreamIdInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStreamIdInfo>()._has_bits_);
  static void set_has_audio_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_external_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dropped(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

AudioStreamIdInfo::AudioStreamIdInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioStreamIdInfo)
}
AudioStreamIdInfo::AudioStreamIdInfo(const AudioStreamIdInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  profile_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_profile_id()) {
    profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_profile_id(),
      GetArena());
  }
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_external_user_id()) {
    external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_external_user_id(),
      GetArena());
  }
  ::memcpy(&audio_stream_id_, &from.audio_stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&dropped_) -
    reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(dropped_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioStreamIdInfo)
}

void AudioStreamIdInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioStreamIdInfo_video_5fcontrol_2eproto.base);
  profile_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&audio_stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&dropped_) -
      reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(dropped_));
}

AudioStreamIdInfo::~AudioStreamIdInfo() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioStreamIdInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioStreamIdInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  profile_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AudioStreamIdInfo::ArenaDtor(void* object) {
  AudioStreamIdInfo* _this = reinterpret_cast< AudioStreamIdInfo* >(object);
  (void)_this;
}
void AudioStreamIdInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioStreamIdInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioStreamIdInfo& AudioStreamIdInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioStreamIdInfo_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioStreamIdInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioStreamIdInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      profile_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      external_user_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&audio_stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dropped_) -
        reinterpret_cast<char*>(&audio_stream_id_)) + sizeof(dropped_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioStreamIdInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 audio_stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_audio_stream_id(&has_bits);
          audio_stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string profile_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_profile_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool muted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_muted(&has_bits);
          muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string external_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_external_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool dropped = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_dropped(&has_bits);
          dropped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioStreamIdInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioStreamIdInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 audio_stream_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_audio_stream_id(), target);
  }

  // optional string profile_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_profile_id(), target);
  }

  // optional bool muted = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_muted(), target);
  }

  // optional string external_user_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_external_user_id(), target);
  }

  // optional bool dropped = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_dropped(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioStreamIdInfo)
  return target;
}

size_t AudioStreamIdInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioStreamIdInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string profile_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profile_id());
    }

    // optional string external_user_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_external_user_id());
    }

    // optional uint32 audio_stream_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_audio_stream_id());
    }

    // optional bool muted = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool dropped = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioStreamIdInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioStreamIdInfo*>(
      &from));
}

void AudioStreamIdInfo::MergeFrom(const AudioStreamIdInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioStreamIdInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_profile_id(from._internal_profile_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_external_user_id(from._internal_external_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      audio_stream_id_ = from.audio_stream_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      muted_ = from.muted_;
    }
    if (cached_has_bits & 0x00000010u) {
      dropped_ = from.dropped_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AudioStreamIdInfo::CopyFrom(const AudioStreamIdInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioStreamIdInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamIdInfo::IsInitialized() const {
  return true;
}

void AudioStreamIdInfo::InternalSwap(AudioStreamIdInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  profile_id_.Swap(&other->profile_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  external_user_id_.Swap(&other->external_user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioStreamIdInfo, dropped_)
      + sizeof(AudioStreamIdInfo::dropped_)
      - PROTOBUF_FIELD_OFFSET(AudioStreamIdInfo, audio_stream_id_)>(
          reinterpret_cast<char*>(&audio_stream_id_),
          reinterpret_cast<char*>(&other->audio_stream_id_));
}

std::string AudioStreamIdInfo::GetTypeName() const {
  return "signal_rtc.AudioStreamIdInfo";
}


// ===================================================================

class PingPongFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PingPongFrame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ping_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PingPongFrame::PingPongFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.PingPongFrame)
}
PingPongFrame::PingPongFrame(const PingPongFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ping_id_, &from.ping_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&ping_id_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.PingPongFrame)
}

void PingPongFrame::SharedCtor() {
  ping_id_ = 0u;
  type_ = 1;
}

PingPongFrame::~PingPongFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.PingPongFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PingPongFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PingPongFrame::ArenaDtor(void* object) {
  PingPongFrame* _this = reinterpret_cast< PingPongFrame* >(object);
  (void)_this;
}
void PingPongFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PingPongFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PingPongFrame& PingPongFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PingPongFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void PingPongFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.PingPongFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ping_id_ = 0u;
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PingPongFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .signal_rtc.PingPongType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::PingPongType_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::PingPongType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required uint32 ping_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ping_id(&has_bits);
          ping_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PingPongFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.PingPongFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .signal_rtc.PingPongType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required uint32 ping_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ping_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.PingPongFrame)
  return target;
}

size_t PingPongFrame::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:signal_rtc.PingPongFrame)
  size_t total_size = 0;

  if (_internal_has_ping_id()) {
    // required uint32 ping_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ping_id());
  }

  if (_internal_has_type()) {
    // required .signal_rtc.PingPongType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t PingPongFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.PingPongFrame)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 ping_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ping_id());

    // required .signal_rtc.PingPongType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PingPongFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PingPongFrame*>(
      &from));
}

void PingPongFrame::MergeFrom(const PingPongFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.PingPongFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ping_id_ = from.ping_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PingPongFrame::CopyFrom(const PingPongFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.PingPongFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingPongFrame::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PingPongFrame::InternalSwap(PingPongFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ping_id_, other->ping_id_);
  swap(type_, other->type_);
}

std::string PingPongFrame::GetTypeName() const {
  return "signal_rtc.PingPongFrame";
}


// ===================================================================

class AudioStatusFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStatusFrame>()._has_bits_);
  static void set_has_xrp_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AudioStatusFrame::AudioStatusFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioStatusFrame)
}
AudioStatusFrame::AudioStatusFrame(const AudioStatusFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  xrp_status_ = from.xrp_status_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioStatusFrame)
}

void AudioStatusFrame::SharedCtor() {
  xrp_status_ = 0u;
}

AudioStatusFrame::~AudioStatusFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioStatusFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioStatusFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioStatusFrame::ArenaDtor(void* object) {
  AudioStatusFrame* _this = reinterpret_cast< AudioStatusFrame* >(object);
  (void)_this;
}
void AudioStatusFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioStatusFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioStatusFrame& AudioStatusFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioStatusFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioStatusFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioStatusFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  xrp_status_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioStatusFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 xrp_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_xrp_status(&has_bits);
          xrp_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioStatusFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioStatusFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 xrp_status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_xrp_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioStatusFrame)
  return target;
}

size_t AudioStatusFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioStatusFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 xrp_status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_xrp_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioStatusFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioStatusFrame*>(
      &from));
}

void AudioStatusFrame::MergeFrom(const AudioStatusFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioStatusFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_xrp_status()) {
    _internal_set_xrp_status(from._internal_xrp_status());
  }
}

void AudioStatusFrame::CopyFrom(const AudioStatusFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioStatusFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStatusFrame::IsInitialized() const {
  return true;
}

void AudioStatusFrame::InternalSwap(AudioStatusFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(xrp_status_, other->xrp_status_);
}

std::string AudioStatusFrame::GetTypeName() const {
  return "signal_rtc.AudioStatusFrame";
}


// ===================================================================

class Metric::_Internal {
 public:
  using HasBits = decltype(std::declval<Metric>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Metric::Metric(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.Metric)
}
Metric::Metric(const Metric& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&value_, &from.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&value_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.Metric)
}

void Metric::SharedCtor() {
  value_ = 0;
  type_ = 1;
}

Metric::~Metric() {
  // @@protoc_insertion_point(destructor:signal_rtc.Metric)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Metric::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Metric::ArenaDtor(void* object) {
  Metric* _this = reinterpret_cast< Metric* >(object);
  (void)_this;
}
void Metric::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Metric::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Metric& Metric::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Metric_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.Metric)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    value_ = 0;
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Metric::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.Metric.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::Metric_Type_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::Metric_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Metric::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.Metric)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.Metric.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional double value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.Metric)
  return target;
}

size_t Metric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.Metric)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .signal_rtc.Metric.Type type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Metric::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Metric*>(
      &from));
}

void Metric::MergeFrom(const Metric& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.Metric)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      value_ = from.value_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Metric::CopyFrom(const Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metric::IsInitialized() const {
  return true;
}

void Metric::InternalSwap(Metric* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
  swap(type_, other->type_);
}

std::string Metric::GetTypeName() const {
  return "signal_rtc.Metric";
}


// ===================================================================

class StreamMetricFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamMetricFrame>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StreamMetricFrame::StreamMetricFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  metrics_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.StreamMetricFrame)
}
StreamMetricFrame::StreamMetricFrame(const StreamMetricFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      metrics_(from.metrics_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.StreamMetricFrame)
}

void StreamMetricFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StreamMetricFrame_video_5fcontrol_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
}

StreamMetricFrame::~StreamMetricFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.StreamMetricFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void StreamMetricFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StreamMetricFrame::ArenaDtor(void* object) {
  StreamMetricFrame* _this = reinterpret_cast< StreamMetricFrame* >(object);
  (void)_this;
}
void StreamMetricFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StreamMetricFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StreamMetricFrame& StreamMetricFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StreamMetricFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void StreamMetricFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.StreamMetricFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metrics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_id_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(group_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamMetricFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 stream_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.Metric metrics = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metrics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StreamMetricFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.StreamMetricFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 stream_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stream_id(), target);
  }

  // optional uint32 group_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_group_id(), target);
  }

  // repeated .signal_rtc.Metric metrics = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metrics_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_metrics(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.StreamMetricFrame)
  return target;
}

size_t StreamMetricFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.StreamMetricFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.Metric metrics = 5;
  total_size += 1UL * this->_internal_metrics_size();
  for (const auto& msg : this->metrics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 stream_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stream_id());
    }

    // optional uint32 group_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_group_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamMetricFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StreamMetricFrame*>(
      &from));
}

void StreamMetricFrame::MergeFrom(const StreamMetricFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.StreamMetricFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  metrics_.MergeFrom(from.metrics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StreamMetricFrame::CopyFrom(const StreamMetricFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.StreamMetricFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamMetricFrame::IsInitialized() const {
  return true;
}

void StreamMetricFrame::InternalSwap(StreamMetricFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metrics_.InternalSwap(&other->metrics_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamMetricFrame, group_id_)
      + sizeof(StreamMetricFrame::group_id_)
      - PROTOBUF_FIELD_OFFSET(StreamMetricFrame, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string StreamMetricFrame::GetTypeName() const {
  return "signal_rtc.StreamMetricFrame";
}


// ===================================================================

class ClientMetricFrame::_Internal {
 public:
};

ClientMetricFrame::ClientMetricFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  global_metrics_(arena),
  stream_metric_frames_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.ClientMetricFrame)
}
ClientMetricFrame::ClientMetricFrame(const ClientMetricFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      global_metrics_(from.global_metrics_),
      stream_metric_frames_(from.stream_metric_frames_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.ClientMetricFrame)
}

void ClientMetricFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientMetricFrame_video_5fcontrol_2eproto.base);
}

ClientMetricFrame::~ClientMetricFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.ClientMetricFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ClientMetricFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ClientMetricFrame::ArenaDtor(void* object) {
  ClientMetricFrame* _this = reinterpret_cast< ClientMetricFrame* >(object);
  (void)_this;
}
void ClientMetricFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClientMetricFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientMetricFrame& ClientMetricFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientMetricFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void ClientMetricFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.ClientMetricFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  global_metrics_.Clear();
  stream_metric_frames_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMetricFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.Metric global_metrics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_global_metrics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.StreamMetricFrame stream_metric_frames = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stream_metric_frames(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ClientMetricFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.ClientMetricFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.Metric global_metrics = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_global_metrics_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_global_metrics(i), target, stream);
  }

  // repeated .signal_rtc.StreamMetricFrame stream_metric_frames = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_stream_metric_frames_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_stream_metric_frames(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.ClientMetricFrame)
  return target;
}

size_t ClientMetricFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.ClientMetricFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.Metric global_metrics = 1;
  total_size += 1UL * this->_internal_global_metrics_size();
  for (const auto& msg : this->global_metrics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .signal_rtc.StreamMetricFrame stream_metric_frames = 2;
  total_size += 1UL * this->_internal_stream_metric_frames_size();
  for (const auto& msg : this->stream_metric_frames_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMetricFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientMetricFrame*>(
      &from));
}

void ClientMetricFrame::MergeFrom(const ClientMetricFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.ClientMetricFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  global_metrics_.MergeFrom(from.global_metrics_);
  stream_metric_frames_.MergeFrom(from.stream_metric_frames_);
}

void ClientMetricFrame::CopyFrom(const ClientMetricFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.ClientMetricFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMetricFrame::IsInitialized() const {
  return true;
}

void ClientMetricFrame::InternalSwap(ClientMetricFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  global_metrics_.InternalSwap(&other->global_metrics_);
  stream_metric_frames_.InternalSwap(&other->stream_metric_frames_);
}

std::string ClientMetricFrame::GetTypeName() const {
  return "signal_rtc.ClientMetricFrame";
}


// ===================================================================

class DataMessageFrame::_Internal {
 public:
};

DataMessageFrame::DataMessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  messages_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.DataMessageFrame)
}
DataMessageFrame::DataMessageFrame(const DataMessageFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      messages_(from.messages_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.DataMessageFrame)
}

void DataMessageFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DataMessageFrame_video_5fcontrol_2eproto.base);
}

DataMessageFrame::~DataMessageFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.DataMessageFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DataMessageFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void DataMessageFrame::ArenaDtor(void* object) {
  DataMessageFrame* _this = reinterpret_cast< DataMessageFrame* >(object);
  (void)_this;
}
void DataMessageFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DataMessageFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DataMessageFrame& DataMessageFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DataMessageFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void DataMessageFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.DataMessageFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messages_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessageFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.DataMessagePayload messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataMessageFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.DataMessageFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.DataMessagePayload messages = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_messages_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_messages(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.DataMessageFrame)
  return target;
}

size_t DataMessageFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.DataMessageFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.DataMessagePayload messages = 1;
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->messages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessageFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DataMessageFrame*>(
      &from));
}

void DataMessageFrame::MergeFrom(const DataMessageFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.DataMessageFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  messages_.MergeFrom(from.messages_);
}

void DataMessageFrame::CopyFrom(const DataMessageFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.DataMessageFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessageFrame::IsInitialized() const {
  return true;
}

void DataMessageFrame::InternalSwap(DataMessageFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  messages_.InternalSwap(&other->messages_);
}

std::string DataMessageFrame::GetTypeName() const {
  return "signal_rtc.DataMessageFrame";
}


// ===================================================================

class DataMessagePayload::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessagePayload>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lifetime_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sender_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ingest_time_ns(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sender_external_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DataMessagePayload::DataMessagePayload(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.DataMessagePayload)
}
DataMessagePayload::DataMessagePayload(const DataMessagePayload& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic(),
      GetArena());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  sender_profile_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_profile_id()) {
    sender_profile_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_sender_profile_id(),
      GetArena());
  }
  sender_external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_external_user_id()) {
    sender_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_sender_external_user_id(),
      GetArena());
  }
  ::memcpy(&ingest_time_ns_, &from.ingest_time_ns_,
    static_cast<size_t>(reinterpret_cast<char*>(&lifetime_ms_) -
    reinterpret_cast<char*>(&ingest_time_ns_)) + sizeof(lifetime_ms_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.DataMessagePayload)
}

void DataMessagePayload::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DataMessagePayload_video_5fcontrol_2eproto.base);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_profile_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&ingest_time_ns_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&lifetime_ms_) -
      reinterpret_cast<char*>(&ingest_time_ns_)) + sizeof(lifetime_ms_));
}

DataMessagePayload::~DataMessagePayload() {
  // @@protoc_insertion_point(destructor:signal_rtc.DataMessagePayload)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DataMessagePayload::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_profile_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_external_user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DataMessagePayload::ArenaDtor(void* object) {
  DataMessagePayload* _this = reinterpret_cast< DataMessagePayload* >(object);
  (void)_this;
}
void DataMessagePayload::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DataMessagePayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DataMessagePayload& DataMessagePayload::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DataMessagePayload_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void DataMessagePayload::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.DataMessagePayload)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      sender_profile_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      sender_external_user_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&ingest_time_ns_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lifetime_ms_) -
        reinterpret_cast<char*>(&ingest_time_ns_)) + sizeof(lifetime_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessagePayload::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lifetime_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lifetime_ms(&has_bits);
          lifetime_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sender_profile_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_sender_profile_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 ingest_time_ns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ingest_time_ns(&has_bits);
          ingest_time_ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sender_external_user_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_sender_external_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataMessagePayload::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.DataMessagePayload)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // optional uint32 lifetime_ms = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lifetime_ms(), target);
  }

  // optional string sender_profile_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sender_profile_id(), target);
  }

  // optional int64 ingest_time_ns = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_ingest_time_ns(), target);
  }

  // optional string sender_external_user_id = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_sender_external_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.DataMessagePayload)
  return target;
}

size_t DataMessagePayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.DataMessagePayload)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string topic = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_topic());
    }

    // optional bytes data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional string sender_profile_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sender_profile_id());
    }

    // optional string sender_external_user_id = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sender_external_user_id());
    }

    // optional int64 ingest_time_ns = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_ingest_time_ns());
    }

    // optional uint32 lifetime_ms = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lifetime_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessagePayload::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DataMessagePayload*>(
      &from));
}

void DataMessagePayload::MergeFrom(const DataMessagePayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.DataMessagePayload)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_sender_profile_id(from._internal_sender_profile_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_sender_external_user_id(from._internal_sender_external_user_id());
    }
    if (cached_has_bits & 0x00000010u) {
      ingest_time_ns_ = from.ingest_time_ns_;
    }
    if (cached_has_bits & 0x00000020u) {
      lifetime_ms_ = from.lifetime_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DataMessagePayload::CopyFrom(const DataMessagePayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.DataMessagePayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessagePayload::IsInitialized() const {
  return true;
}

void DataMessagePayload::InternalSwap(DataMessagePayload* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_.Swap(&other->topic_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  sender_profile_id_.Swap(&other->sender_profile_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  sender_external_user_id_.Swap(&other->sender_external_user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessagePayload, lifetime_ms_)
      + sizeof(DataMessagePayload::lifetime_ms_)
      - PROTOBUF_FIELD_OFFSET(DataMessagePayload, ingest_time_ns_)>(
          reinterpret_cast<char*>(&ingest_time_ns_),
          reinterpret_cast<char*>(&other->ingest_time_ns_));
}

std::string DataMessagePayload::GetTypeName() const {
  return "signal_rtc.DataMessagePayload";
}


// ===================================================================

class TurnCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<TurnCredentials>()._has_bits_);
  static void set_has_username(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ttl(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TurnCredentials::TurnCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  uris_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.TurnCredentials)
}
TurnCredentials::TurnCredentials(const TurnCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      uris_(from.uris_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_username()) {
    username_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_username(),
      GetArena());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_password()) {
    password_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_password(),
      GetArena());
  }
  ttl_ = from.ttl_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.TurnCredentials)
}

void TurnCredentials::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TurnCredentials_video_5fcontrol_2eproto.base);
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ttl_ = 0u;
}

TurnCredentials::~TurnCredentials() {
  // @@protoc_insertion_point(destructor:signal_rtc.TurnCredentials)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TurnCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  username_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TurnCredentials::ArenaDtor(void* object) {
  TurnCredentials* _this = reinterpret_cast< TurnCredentials* >(object);
  (void)_this;
}
void TurnCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TurnCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TurnCredentials& TurnCredentials::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TurnCredentials_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void TurnCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.TurnCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uris_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      username_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
  }
  ttl_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TurnCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string username = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_username();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ttl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ttl(&has_bits);
          ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string uris = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_uris();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TurnCredentials::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.TurnCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string username = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_username(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional uint32 ttl = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ttl(), target);
  }

  // repeated string uris = 4;
  for (int i = 0, n = this->_internal_uris_size(); i < n; i++) {
    const auto& s = this->_internal_uris(i);
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.TurnCredentials)
  return target;
}

size_t TurnCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.TurnCredentials)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string uris = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(uris_.size());
  for (int i = 0, n = uris_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      uris_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string username = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional uint32 ttl = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ttl());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TurnCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TurnCredentials*>(
      &from));
}

void TurnCredentials::MergeFrom(const TurnCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.TurnCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  uris_.MergeFrom(from.uris_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_username(from._internal_username());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000004u) {
      ttl_ = from.ttl_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TurnCredentials::CopyFrom(const TurnCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.TurnCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnCredentials::IsInitialized() const {
  return true;
}

void TurnCredentials::InternalSwap(TurnCredentials* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uris_.InternalSwap(&other->uris_);
  username_.Swap(&other->username_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  password_.Swap(&other->password_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(ttl_, other->ttl_);
}

std::string TurnCredentials::GetTypeName() const {
  return "signal_rtc.TurnCredentials";
}


// ===================================================================

class AudioTranscriptItem::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioTranscriptItem>()._has_bits_);
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speaker_attendee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_speaker_external_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_vocabulary_filter_match(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_stable(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

AudioTranscriptItem::AudioTranscriptItem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptItem)
}
AudioTranscriptItem::AudioTranscriptItem(const AudioTranscriptItem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_content()) {
    content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_content(),
      GetArena());
  }
  speaker_attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_speaker_attendee_id()) {
    speaker_attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_speaker_attendee_id(),
      GetArena());
  }
  speaker_external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_speaker_external_user_id()) {
    speaker_external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_speaker_external_user_id(),
      GetArena());
  }
  ::memcpy(&end_time_, &from.end_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&end_time_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptItem)
}

void AudioTranscriptItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptItem_video_5fcontrol_2eproto.base);
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  speaker_attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  speaker_external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&end_time_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&stable_) -
      reinterpret_cast<char*>(&end_time_)) + sizeof(stable_));
  type_ = 1;
}

AudioTranscriptItem::~AudioTranscriptItem() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptItem)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptItem::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  speaker_attendee_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  speaker_external_user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AudioTranscriptItem::ArenaDtor(void* object) {
  AudioTranscriptItem* _this = reinterpret_cast< AudioTranscriptItem* >(object);
  (void)_this;
}
void AudioTranscriptItem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptItem& AudioTranscriptItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptItem_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptItem::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      content_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      speaker_attendee_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      speaker_external_user_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&end_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stable_) -
        reinterpret_cast<char*>(&end_time_)) + sizeof(stable_));
  }
  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string content = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_content();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 end_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string speaker_attendee_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_speaker_attendee_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string speaker_external_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_speaker_external_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 start_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.AudioTranscriptItem.Type type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::AudioTranscriptItem_Type_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::AudioTranscriptItem_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool vocabulary_filter_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_vocabulary_filter_match(&has_bits);
          vocabulary_filter_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double confidence = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_confidence(&has_bits);
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional bool stable = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_stable(&has_bits);
          stable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptItem::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string content = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_content(), target);
  }

  // optional int64 end_time = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_end_time(), target);
  }

  // optional string speaker_attendee_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_speaker_attendee_id(), target);
  }

  // optional string speaker_external_user_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_speaker_external_user_id(), target);
  }

  // optional int64 start_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_start_time(), target);
  }

  // optional .signal_rtc.AudioTranscriptItem.Type type = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_type(), target);
  }

  // optional bool vocabulary_filter_match = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_vocabulary_filter_match(), target);
  }

  // optional double confidence = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_confidence(), target);
  }

  // optional bool stable = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_stable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptItem)
  return target;
}

size_t AudioTranscriptItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptItem)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string content = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content());
    }

    // optional string speaker_attendee_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_speaker_attendee_id());
    }

    // optional string speaker_external_user_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_speaker_external_user_id());
    }

    // optional int64 end_time = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_end_time());
    }

    // optional int64 start_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_start_time());
    }

    // optional double confidence = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional bool vocabulary_filter_match = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool stable = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional .signal_rtc.AudioTranscriptItem.Type type = 6;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptItem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptItem*>(
      &from));
}

void AudioTranscriptItem::MergeFrom(const AudioTranscriptItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_speaker_attendee_id(from._internal_speaker_attendee_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_speaker_external_user_id(from._internal_speaker_external_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      end_time_ = from.end_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      confidence_ = from.confidence_;
    }
    if (cached_has_bits & 0x00000040u) {
      vocabulary_filter_match_ = from.vocabulary_filter_match_;
    }
    if (cached_has_bits & 0x00000080u) {
      stable_ = from.stable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_type(from._internal_type());
  }
}

void AudioTranscriptItem::CopyFrom(const AudioTranscriptItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptItem::IsInitialized() const {
  return true;
}

void AudioTranscriptItem::InternalSwap(AudioTranscriptItem* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  content_.Swap(&other->content_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  speaker_attendee_id_.Swap(&other->speaker_attendee_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  speaker_external_user_id_.Swap(&other->speaker_external_user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioTranscriptItem, stable_)
      + sizeof(AudioTranscriptItem::stable_)
      - PROTOBUF_FIELD_OFFSET(AudioTranscriptItem, end_time_)>(
          reinterpret_cast<char*>(&end_time_),
          reinterpret_cast<char*>(&other->end_time_));
  swap(type_, other->type_);
}

std::string AudioTranscriptItem::GetTypeName() const {
  return "signal_rtc.AudioTranscriptItem";
}


// ===================================================================

class AudioTranscriptEntity::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioTranscriptEntity>()._has_bits_);
  static void set_has_category(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AudioTranscriptEntity::AudioTranscriptEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptEntity)
}
AudioTranscriptEntity::AudioTranscriptEntity(const AudioTranscriptEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  category_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_category()) {
    category_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_category(),
      GetArena());
  }
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_content()) {
    content_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_content(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  ::memcpy(&confidence_, &from.confidence_,
    static_cast<size_t>(reinterpret_cast<char*>(&start_time_) -
    reinterpret_cast<char*>(&confidence_)) + sizeof(start_time_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptEntity)
}

void AudioTranscriptEntity::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptEntity_video_5fcontrol_2eproto.base);
  category_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&confidence_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&start_time_) -
      reinterpret_cast<char*>(&confidence_)) + sizeof(start_time_));
}

AudioTranscriptEntity::~AudioTranscriptEntity() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptEntity)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptEntity::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  category_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AudioTranscriptEntity::ArenaDtor(void* object) {
  AudioTranscriptEntity* _this = reinterpret_cast< AudioTranscriptEntity* >(object);
  (void)_this;
}
void AudioTranscriptEntity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptEntity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptEntity& AudioTranscriptEntity::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptEntity_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptEntity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      category_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      content_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&confidence_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_time_) -
        reinterpret_cast<char*>(&confidence_)) + sizeof(start_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptEntity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string category = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_category();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double confidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_confidence(&has_bits);
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional string content = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_content();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 end_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 start_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptEntity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptEntity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string category = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_category(), target);
  }

  // optional double confidence = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_confidence(), target);
  }

  // optional string content = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_content(), target);
  }

  // optional int64 end_time = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_end_time(), target);
  }

  // optional int64 start_time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_start_time(), target);
  }

  // optional string type = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptEntity)
  return target;
}

size_t AudioTranscriptEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptEntity)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string category = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_category());
    }

    // optional string content = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content());
    }

    // optional string type = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional double confidence = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int64 end_time = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_end_time());
    }

    // optional int64 start_time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_start_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptEntity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptEntity*>(
      &from));
}

void AudioTranscriptEntity::MergeFrom(const AudioTranscriptEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_category(from._internal_category());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000008u) {
      confidence_ = from.confidence_;
    }
    if (cached_has_bits & 0x00000010u) {
      end_time_ = from.end_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      start_time_ = from.start_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AudioTranscriptEntity::CopyFrom(const AudioTranscriptEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptEntity::IsInitialized() const {
  return true;
}

void AudioTranscriptEntity::InternalSwap(AudioTranscriptEntity* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  category_.Swap(&other->category_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  content_.Swap(&other->content_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioTranscriptEntity, start_time_)
      + sizeof(AudioTranscriptEntity::start_time_)
      - PROTOBUF_FIELD_OFFSET(AudioTranscriptEntity, confidence_)>(
          reinterpret_cast<char*>(&confidence_),
          reinterpret_cast<char*>(&other->confidence_));
}

std::string AudioTranscriptEntity::GetTypeName() const {
  return "signal_rtc.AudioTranscriptEntity";
}


// ===================================================================

class AudioTranscriptAlternative::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioTranscriptAlternative>()._has_bits_);
  static void set_has_transcript(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AudioTranscriptAlternative::AudioTranscriptAlternative(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  items_(arena),
  entities_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptAlternative)
}
AudioTranscriptAlternative::AudioTranscriptAlternative(const AudioTranscriptAlternative& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      items_(from.items_),
      entities_(from.entities_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  transcript_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_transcript()) {
    transcript_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_transcript(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptAlternative)
}

void AudioTranscriptAlternative::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto.base);
  transcript_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AudioTranscriptAlternative::~AudioTranscriptAlternative() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptAlternative)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptAlternative::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  transcript_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AudioTranscriptAlternative::ArenaDtor(void* object) {
  AudioTranscriptAlternative* _this = reinterpret_cast< AudioTranscriptAlternative* >(object);
  (void)_this;
}
void AudioTranscriptAlternative::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptAlternative::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptAlternative& AudioTranscriptAlternative::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptAlternative_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptAlternative::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptAlternative)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  items_.Clear();
  entities_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    transcript_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptAlternative::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioTranscriptItem items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string transcript = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_transcript();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .signal_rtc.AudioTranscriptEntity entities = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptAlternative::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptAlternative)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptItem items = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_items_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_items(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string transcript = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_transcript(), target);
  }

  // repeated .signal_rtc.AudioTranscriptEntity entities = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entities_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_entities(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptAlternative)
  return target;
}

size_t AudioTranscriptAlternative::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptAlternative)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptItem items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .signal_rtc.AudioTranscriptEntity entities = 3;
  total_size += 1UL * this->_internal_entities_size();
  for (const auto& msg : this->entities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string transcript = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcript());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptAlternative::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptAlternative*>(
      &from));
}

void AudioTranscriptAlternative::MergeFrom(const AudioTranscriptAlternative& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptAlternative)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  items_.MergeFrom(from.items_);
  entities_.MergeFrom(from.entities_);
  if (from._internal_has_transcript()) {
    _internal_set_transcript(from._internal_transcript());
  }
}

void AudioTranscriptAlternative::CopyFrom(const AudioTranscriptAlternative& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptAlternative)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptAlternative::IsInitialized() const {
  return true;
}

void AudioTranscriptAlternative::InternalSwap(AudioTranscriptAlternative* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  items_.InternalSwap(&other->items_);
  entities_.InternalSwap(&other->entities_);
  transcript_.Swap(&other->transcript_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string AudioTranscriptAlternative::GetTypeName() const {
  return "signal_rtc.AudioTranscriptAlternative";
}


// ===================================================================

class AudioTranscriptResult::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioTranscriptResult>()._has_bits_);
  static void set_has_channel_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_result_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

AudioTranscriptResult::AudioTranscriptResult(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  alternatives_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptResult)
}
AudioTranscriptResult::AudioTranscriptResult(const AudioTranscriptResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      alternatives_(from.alternatives_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  channel_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_channel_id()) {
    channel_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_channel_id(),
      GetArena());
  }
  result_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_result_id()) {
    result_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_result_id(),
      GetArena());
  }
  ::memcpy(&end_time_, &from.end_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_partial_) -
    reinterpret_cast<char*>(&end_time_)) + sizeof(is_partial_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptResult)
}

void AudioTranscriptResult::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptResult_video_5fcontrol_2eproto.base);
  channel_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  result_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&end_time_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&is_partial_) -
      reinterpret_cast<char*>(&end_time_)) + sizeof(is_partial_));
}

AudioTranscriptResult::~AudioTranscriptResult() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptResult)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptResult::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  channel_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  result_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AudioTranscriptResult::ArenaDtor(void* object) {
  AudioTranscriptResult* _this = reinterpret_cast< AudioTranscriptResult* >(object);
  (void)_this;
}
void AudioTranscriptResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptResult& AudioTranscriptResult::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptResult_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptResult::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alternatives_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      channel_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      result_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&end_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_partial_) -
        reinterpret_cast<char*>(&end_time_)) + sizeof(is_partial_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioTranscriptAlternative alternatives = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alternatives(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string channel_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_channel_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 end_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_partial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_partial(&has_bits);
          is_partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string result_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_result_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 start_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptResult::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptAlternative alternatives = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_alternatives_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_alternatives(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string channel_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_channel_id(), target);
  }

  // optional int64 end_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_end_time(), target);
  }

  // optional bool is_partial = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_partial(), target);
  }

  // optional string result_id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_result_id(), target);
  }

  // optional int64 start_time = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_start_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptResult)
  return target;
}

size_t AudioTranscriptResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptResult)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptAlternative alternatives = 1;
  total_size += 1UL * this->_internal_alternatives_size();
  for (const auto& msg : this->alternatives_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string channel_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_channel_id());
    }

    // optional string result_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_result_id());
    }

    // optional int64 end_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_end_time());
    }

    // optional int64 start_time = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_start_time());
    }

    // optional bool is_partial = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptResult*>(
      &from));
}

void AudioTranscriptResult::MergeFrom(const AudioTranscriptResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  alternatives_.MergeFrom(from.alternatives_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_channel_id(from._internal_channel_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_result_id(from._internal_result_id());
    }
    if (cached_has_bits & 0x00000004u) {
      end_time_ = from.end_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_partial_ = from.is_partial_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AudioTranscriptResult::CopyFrom(const AudioTranscriptResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptResult::IsInitialized() const {
  return true;
}

void AudioTranscriptResult::InternalSwap(AudioTranscriptResult* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  alternatives_.InternalSwap(&other->alternatives_);
  channel_id_.Swap(&other->channel_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  result_id_.Swap(&other->result_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioTranscriptResult, is_partial_)
      + sizeof(AudioTranscriptResult::is_partial_)
      - PROTOBUF_FIELD_OFFSET(AudioTranscriptResult, end_time_)>(
          reinterpret_cast<char*>(&end_time_),
          reinterpret_cast<char*>(&other->end_time_));
}

std::string AudioTranscriptResult::GetTypeName() const {
  return "signal_rtc.AudioTranscriptResult";
}


// ===================================================================

class AudioTranscript::_Internal {
 public:
};

AudioTranscript::AudioTranscript(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  results_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscript)
}
AudioTranscript::AudioTranscript(const AudioTranscript& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      results_(from.results_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscript)
}

void AudioTranscript::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscript_video_5fcontrol_2eproto.base);
}

AudioTranscript::~AudioTranscript() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscript)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscript::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioTranscript::ArenaDtor(void* object) {
  AudioTranscript* _this = reinterpret_cast< AudioTranscript* >(object);
  (void)_this;
}
void AudioTranscript::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscript::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscript& AudioTranscript::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscript_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscript::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscript)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  results_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscript::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioTranscriptResult results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscript::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscript)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptResult results = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_results_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_results(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscript)
  return target;
}

size_t AudioTranscript::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscript)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptResult results = 1;
  total_size += 1UL * this->_internal_results_size();
  for (const auto& msg : this->results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscript::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscript*>(
      &from));
}

void AudioTranscript::MergeFrom(const AudioTranscript& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscript)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  results_.MergeFrom(from.results_);
}

void AudioTranscript::CopyFrom(const AudioTranscript& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscript)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscript::IsInitialized() const {
  return true;
}

void AudioTranscript::InternalSwap(AudioTranscript* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  results_.InternalSwap(&other->results_);
}

std::string AudioTranscript::GetTypeName() const {
  return "signal_rtc.AudioTranscript";
}


// ===================================================================

class MeetingTranscriptionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<MeetingTranscriptionStatus>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_transcription_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transcription_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MeetingTranscriptionStatus::MeetingTranscriptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.MeetingTranscriptionStatus)
}
MeetingTranscriptionStatus::MeetingTranscriptionStatus(const MeetingTranscriptionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  transcription_region_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_transcription_region()) {
    transcription_region_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_transcription_region(),
      GetArena());
  }
  transcription_configuration_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_transcription_configuration()) {
    transcription_configuration_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_transcription_configuration(),
      GetArena());
  }
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message(),
      GetArena());
  }
  ::memcpy(&event_time_, &from.event_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&event_time_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.MeetingTranscriptionStatus)
}

void MeetingTranscriptionStatus::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto.base);
  transcription_region_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transcription_configuration_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  event_time_ = PROTOBUF_LONGLONG(0);
  type_ = 1;
}

MeetingTranscriptionStatus::~MeetingTranscriptionStatus() {
  // @@protoc_insertion_point(destructor:signal_rtc.MeetingTranscriptionStatus)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void MeetingTranscriptionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  transcription_region_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transcription_configuration_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MeetingTranscriptionStatus::ArenaDtor(void* object) {
  MeetingTranscriptionStatus* _this = reinterpret_cast< MeetingTranscriptionStatus* >(object);
  (void)_this;
}
void MeetingTranscriptionStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MeetingTranscriptionStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MeetingTranscriptionStatus& MeetingTranscriptionStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MeetingTranscriptionStatus_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void MeetingTranscriptionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.MeetingTranscriptionStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      transcription_region_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      transcription_configuration_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    event_time_ = PROTOBUF_LONGLONG(0);
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MeetingTranscriptionStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.MeetingTranscriptionStatus.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::MeetingTranscriptionStatus_Type_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::MeetingTranscriptionStatus_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 event_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_event_time(&has_bits);
          event_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string transcription_region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_transcription_region();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string transcription_configuration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_transcription_configuration();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MeetingTranscriptionStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.MeetingTranscriptionStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.MeetingTranscriptionStatus.Type type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int64 event_time = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_event_time(), target);
  }

  // optional string transcription_region = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_transcription_region(), target);
  }

  // optional string transcription_configuration = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_transcription_configuration(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.MeetingTranscriptionStatus)
  return target;
}

size_t MeetingTranscriptionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.MeetingTranscriptionStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string transcription_region = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transcription_region());
    }

    // optional string transcription_configuration = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transcription_configuration());
    }

    // optional string message = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional int64 event_time = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_event_time());
    }

    // optional .signal_rtc.MeetingTranscriptionStatus.Type type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MeetingTranscriptionStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MeetingTranscriptionStatus*>(
      &from));
}

void MeetingTranscriptionStatus::MergeFrom(const MeetingTranscriptionStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.MeetingTranscriptionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_transcription_region(from._internal_transcription_region());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_transcription_configuration(from._internal_transcription_configuration());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      event_time_ = from.event_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MeetingTranscriptionStatus::CopyFrom(const MeetingTranscriptionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.MeetingTranscriptionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeetingTranscriptionStatus::IsInitialized() const {
  return true;
}

void MeetingTranscriptionStatus::InternalSwap(MeetingTranscriptionStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transcription_region_.Swap(&other->transcription_region_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  transcription_configuration_.Swap(&other->transcription_configuration_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_.Swap(&other->message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(event_time_, other->event_time_);
  swap(type_, other->type_);
}

std::string MeetingTranscriptionStatus::GetTypeName() const {
  return "signal_rtc.MeetingTranscriptionStatus";
}


// ===================================================================

class AudioTranscriptEvent::_Internal {
 public:
  static const ::signal_rtc::MeetingTranscriptionStatus& status(const AudioTranscriptEvent* msg);
  static const ::signal_rtc::AudioTranscript& transcript(const AudioTranscriptEvent* msg);
};

const ::signal_rtc::MeetingTranscriptionStatus&
AudioTranscriptEvent::_Internal::status(const AudioTranscriptEvent* msg) {
  return *msg->Event_.status_;
}
const ::signal_rtc::AudioTranscript&
AudioTranscriptEvent::_Internal::transcript(const AudioTranscriptEvent* msg) {
  return *msg->Event_.transcript_;
}
void AudioTranscriptEvent::set_allocated_status(::signal_rtc::MeetingTranscriptionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_Event();
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
    Event_.status_ = status;
  }
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptEvent.status)
}
void AudioTranscriptEvent::set_allocated_transcript(::signal_rtc::AudioTranscript* transcript) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_Event();
  if (transcript) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transcript);
    if (message_arena != submessage_arena) {
      transcript = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transcript, submessage_arena);
    }
    set_has_transcript();
    Event_.transcript_ = transcript;
  }
  // @@protoc_insertion_point(field_set_allocated:signal_rtc.AudioTranscriptEvent.transcript)
}
AudioTranscriptEvent::AudioTranscriptEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptEvent)
}
AudioTranscriptEvent::AudioTranscriptEvent(const AudioTranscriptEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_Event();
  switch (from.Event_case()) {
    case kStatus: {
      _internal_mutable_status()->::signal_rtc::MeetingTranscriptionStatus::MergeFrom(from._internal_status());
      break;
    }
    case kTranscript: {
      _internal_mutable_transcript()->::signal_rtc::AudioTranscript::MergeFrom(from._internal_transcript());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptEvent)
}

void AudioTranscriptEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptEvent_video_5fcontrol_2eproto.base);
  clear_has_Event();
}

AudioTranscriptEvent::~AudioTranscriptEvent() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptEvent)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_Event()) {
    clear_Event();
  }
}

void AudioTranscriptEvent::ArenaDtor(void* object) {
  AudioTranscriptEvent* _this = reinterpret_cast< AudioTranscriptEvent* >(object);
  (void)_this;
}
void AudioTranscriptEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptEvent& AudioTranscriptEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptEvent_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptEvent::clear_Event() {
// @@protoc_insertion_point(one_of_clear_start:signal_rtc.AudioTranscriptEvent)
  switch (Event_case()) {
    case kStatus: {
      if (GetArena() == nullptr) {
        delete Event_.status_;
      }
      break;
    }
    case kTranscript: {
      if (GetArena() == nullptr) {
        delete Event_.transcript_;
      }
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EVENT_NOT_SET;
}


void AudioTranscriptEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Event();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .signal_rtc.MeetingTranscriptionStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_rtc.AudioTranscript transcript = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transcript(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptEvent::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (Event_case()) {
    case kStatus: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          1, _Internal::status(this), target, stream);
      break;
    }
    case kTranscript: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::transcript(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptEvent)
  return target;
}

size_t AudioTranscriptEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptEvent)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Event_case()) {
    // .signal_rtc.MeetingTranscriptionStatus status = 1;
    case kStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Event_.status_);
      break;
    }
    // .signal_rtc.AudioTranscript transcript = 2;
    case kTranscript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Event_.transcript_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptEvent*>(
      &from));
}

void AudioTranscriptEvent::MergeFrom(const AudioTranscriptEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Event_case()) {
    case kStatus: {
      _internal_mutable_status()->::signal_rtc::MeetingTranscriptionStatus::MergeFrom(from._internal_status());
      break;
    }
    case kTranscript: {
      _internal_mutable_transcript()->::signal_rtc::AudioTranscript::MergeFrom(from._internal_transcript());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
}

void AudioTranscriptEvent::CopyFrom(const AudioTranscriptEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptEvent::IsInitialized() const {
  return true;
}

void AudioTranscriptEvent::InternalSwap(AudioTranscriptEvent* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(Event_, other->Event_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string AudioTranscriptEvent::GetTypeName() const {
  return "signal_rtc.AudioTranscriptEvent";
}


// ===================================================================

class AudioTranscriptFrame::_Internal {
 public:
};

AudioTranscriptFrame::AudioTranscriptFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  events_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.AudioTranscriptFrame)
}
AudioTranscriptFrame::AudioTranscriptFrame(const AudioTranscriptFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      events_(from.events_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.AudioTranscriptFrame)
}

void AudioTranscriptFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AudioTranscriptFrame_video_5fcontrol_2eproto.base);
}

AudioTranscriptFrame::~AudioTranscriptFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.AudioTranscriptFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AudioTranscriptFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AudioTranscriptFrame::ArenaDtor(void* object) {
  AudioTranscriptFrame* _this = reinterpret_cast< AudioTranscriptFrame* >(object);
  (void)_this;
}
void AudioTranscriptFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AudioTranscriptFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AudioTranscriptFrame& AudioTranscriptFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AudioTranscriptFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void AudioTranscriptFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.AudioTranscriptFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  events_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioTranscriptFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.AudioTranscriptEvent events = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AudioTranscriptFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.AudioTranscriptFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptEvent events = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_events_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_events(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.AudioTranscriptFrame)
  return target;
}

size_t AudioTranscriptFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.AudioTranscriptFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.AudioTranscriptEvent events = 1;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioTranscriptFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AudioTranscriptFrame*>(
      &from));
}

void AudioTranscriptFrame::MergeFrom(const AudioTranscriptFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.AudioTranscriptFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  events_.MergeFrom(from.events_);
}

void AudioTranscriptFrame::CopyFrom(const AudioTranscriptFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.AudioTranscriptFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioTranscriptFrame::IsInitialized() const {
  return true;
}

void AudioTranscriptFrame::InternalSwap(AudioTranscriptFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  events_.InternalSwap(&other->events_);
}

std::string AudioTranscriptFrame::GetTypeName() const {
  return "signal_rtc.AudioTranscriptFrame";
}


// ===================================================================

class RemoteVideoUpdateFrame::_Internal {
 public:
};

RemoteVideoUpdateFrame::RemoteVideoUpdateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  added_or_updated_video_subscriptions_(arena),
  removed_video_subscription_mids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.RemoteVideoUpdateFrame)
}
RemoteVideoUpdateFrame::RemoteVideoUpdateFrame(const RemoteVideoUpdateFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      added_or_updated_video_subscriptions_(from.added_or_updated_video_subscriptions_),
      removed_video_subscription_mids_(from.removed_video_subscription_mids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.RemoteVideoUpdateFrame)
}

void RemoteVideoUpdateFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto.base);
}

RemoteVideoUpdateFrame::~RemoteVideoUpdateFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.RemoteVideoUpdateFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void RemoteVideoUpdateFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void RemoteVideoUpdateFrame::ArenaDtor(void* object) {
  RemoteVideoUpdateFrame* _this = reinterpret_cast< RemoteVideoUpdateFrame* >(object);
  (void)_this;
}
void RemoteVideoUpdateFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RemoteVideoUpdateFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RemoteVideoUpdateFrame& RemoteVideoUpdateFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RemoteVideoUpdateFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void RemoteVideoUpdateFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.RemoteVideoUpdateFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  added_or_updated_video_subscriptions_.Clear();
  removed_video_subscription_mids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoteVideoUpdateFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .signal_rtc.VideoSubscriptionConfiguration added_or_updated_video_subscriptions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_added_or_updated_video_subscriptions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string removed_video_subscription_mids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_removed_video_subscription_mids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RemoteVideoUpdateFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.RemoteVideoUpdateFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .signal_rtc.VideoSubscriptionConfiguration added_or_updated_video_subscriptions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_added_or_updated_video_subscriptions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_added_or_updated_video_subscriptions(i), target, stream);
  }

  // repeated string removed_video_subscription_mids = 2;
  for (int i = 0, n = this->_internal_removed_video_subscription_mids_size(); i < n; i++) {
    const auto& s = this->_internal_removed_video_subscription_mids(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.RemoteVideoUpdateFrame)
  return target;
}

size_t RemoteVideoUpdateFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.RemoteVideoUpdateFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .signal_rtc.VideoSubscriptionConfiguration added_or_updated_video_subscriptions = 1;
  total_size += 1UL * this->_internal_added_or_updated_video_subscriptions_size();
  for (const auto& msg : this->added_or_updated_video_subscriptions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string removed_video_subscription_mids = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(removed_video_subscription_mids_.size());
  for (int i = 0, n = removed_video_subscription_mids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      removed_video_subscription_mids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteVideoUpdateFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RemoteVideoUpdateFrame*>(
      &from));
}

void RemoteVideoUpdateFrame::MergeFrom(const RemoteVideoUpdateFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.RemoteVideoUpdateFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  added_or_updated_video_subscriptions_.MergeFrom(from.added_or_updated_video_subscriptions_);
  removed_video_subscription_mids_.MergeFrom(from.removed_video_subscription_mids_);
}

void RemoteVideoUpdateFrame::CopyFrom(const RemoteVideoUpdateFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.RemoteVideoUpdateFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteVideoUpdateFrame::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(added_or_updated_video_subscriptions_)) return false;
  return true;
}

void RemoteVideoUpdateFrame::InternalSwap(RemoteVideoUpdateFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  added_or_updated_video_subscriptions_.InternalSwap(&other->added_or_updated_video_subscriptions_);
  removed_video_subscription_mids_.InternalSwap(&other->removed_video_subscription_mids_);
}

std::string RemoteVideoUpdateFrame::GetTypeName() const {
  return "signal_rtc.RemoteVideoUpdateFrame";
}


// ===================================================================

class VideoSubscriptionConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoSubscriptionConfiguration>()._has_bits_);
  static void set_has_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attendee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VideoSubscriptionConfiguration::VideoSubscriptionConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.VideoSubscriptionConfiguration)
}
VideoSubscriptionConfiguration::VideoSubscriptionConfiguration(const VideoSubscriptionConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_mid()) {
    mid_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_mid(),
      GetArena());
  }
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_attendee_id()) {
    attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_attendee_id(),
      GetArena());
  }
  stream_id_ = from.stream_id_;
  // @@protoc_insertion_point(copy_constructor:signal_rtc.VideoSubscriptionConfiguration)
}

void VideoSubscriptionConfiguration::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto.base);
  mid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  stream_id_ = 0u;
}

VideoSubscriptionConfiguration::~VideoSubscriptionConfiguration() {
  // @@protoc_insertion_point(destructor:signal_rtc.VideoSubscriptionConfiguration)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void VideoSubscriptionConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  mid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attendee_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VideoSubscriptionConfiguration::ArenaDtor(void* object) {
  VideoSubscriptionConfiguration* _this = reinterpret_cast< VideoSubscriptionConfiguration* >(object);
  (void)_this;
}
void VideoSubscriptionConfiguration::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VideoSubscriptionConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VideoSubscriptionConfiguration& VideoSubscriptionConfiguration::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VideoSubscriptionConfiguration_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void VideoSubscriptionConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.VideoSubscriptionConfiguration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      attendee_id_.ClearNonDefaultToEmpty();
    }
  }
  stream_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoSubscriptionConfiguration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string mid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_mid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string attendee_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_attendee_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 stream_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VideoSubscriptionConfiguration::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.VideoSubscriptionConfiguration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string mid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mid(), target);
  }

  // optional string attendee_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_attendee_id(), target);
  }

  // optional uint32 stream_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stream_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.VideoSubscriptionConfiguration)
  return target;
}

size_t VideoSubscriptionConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.VideoSubscriptionConfiguration)
  size_t total_size = 0;

  // required string mid = 1;
  if (_internal_has_mid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mid());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string attendee_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_attendee_id());
    }

    // optional uint32 stream_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stream_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoSubscriptionConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VideoSubscriptionConfiguration*>(
      &from));
}

void VideoSubscriptionConfiguration::MergeFrom(const VideoSubscriptionConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.VideoSubscriptionConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_mid(from._internal_mid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_attendee_id(from._internal_attendee_id());
    }
    if (cached_has_bits & 0x00000004u) {
      stream_id_ = from.stream_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VideoSubscriptionConfiguration::CopyFrom(const VideoSubscriptionConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.VideoSubscriptionConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoSubscriptionConfiguration::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void VideoSubscriptionConfiguration::InternalSwap(VideoSubscriptionConfiguration* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mid_.Swap(&other->mid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  attendee_id_.Swap(&other->attendee_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(stream_id_, other->stream_id_);
}

std::string VideoSubscriptionConfiguration::GetTypeName() const {
  return "signal_rtc.VideoSubscriptionConfiguration";
}


// ===================================================================

class PrimaryMeetingJoinFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PrimaryMeetingJoinFrame>()._has_bits_);
  static const ::signal_rtc::MeetingSessionCredentials& credentials(const PrimaryMeetingJoinFrame* msg);
  static void set_has_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::signal_rtc::MeetingSessionCredentials&
PrimaryMeetingJoinFrame::_Internal::credentials(const PrimaryMeetingJoinFrame* msg) {
  return *msg->credentials_;
}
PrimaryMeetingJoinFrame::PrimaryMeetingJoinFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.PrimaryMeetingJoinFrame)
}
PrimaryMeetingJoinFrame::PrimaryMeetingJoinFrame(const PrimaryMeetingJoinFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_credentials()) {
    credentials_ = new ::signal_rtc::MeetingSessionCredentials(*from.credentials_);
  } else {
    credentials_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.PrimaryMeetingJoinFrame)
}

void PrimaryMeetingJoinFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto.base);
  credentials_ = nullptr;
}

PrimaryMeetingJoinFrame::~PrimaryMeetingJoinFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.PrimaryMeetingJoinFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PrimaryMeetingJoinFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete credentials_;
}

void PrimaryMeetingJoinFrame::ArenaDtor(void* object) {
  PrimaryMeetingJoinFrame* _this = reinterpret_cast< PrimaryMeetingJoinFrame* >(object);
  (void)_this;
}
void PrimaryMeetingJoinFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrimaryMeetingJoinFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PrimaryMeetingJoinFrame& PrimaryMeetingJoinFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PrimaryMeetingJoinFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void PrimaryMeetingJoinFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.PrimaryMeetingJoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(credentials_ != nullptr);
    credentials_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrimaryMeetingJoinFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.MeetingSessionCredentials credentials = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PrimaryMeetingJoinFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.PrimaryMeetingJoinFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.MeetingSessionCredentials credentials = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::credentials(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.PrimaryMeetingJoinFrame)
  return target;
}

size_t PrimaryMeetingJoinFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.PrimaryMeetingJoinFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .signal_rtc.MeetingSessionCredentials credentials = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *credentials_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrimaryMeetingJoinFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PrimaryMeetingJoinFrame*>(
      &from));
}

void PrimaryMeetingJoinFrame::MergeFrom(const PrimaryMeetingJoinFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.PrimaryMeetingJoinFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_credentials()) {
    _internal_mutable_credentials()->::signal_rtc::MeetingSessionCredentials::MergeFrom(from._internal_credentials());
  }
}

void PrimaryMeetingJoinFrame::CopyFrom(const PrimaryMeetingJoinFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.PrimaryMeetingJoinFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimaryMeetingJoinFrame::IsInitialized() const {
  return true;
}

void PrimaryMeetingJoinFrame::InternalSwap(PrimaryMeetingJoinFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(credentials_, other->credentials_);
}

std::string PrimaryMeetingJoinFrame::GetTypeName() const {
  return "signal_rtc.PrimaryMeetingJoinFrame";
}


// ===================================================================

class PrimaryMeetingJoinAckFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PrimaryMeetingJoinAckFrame>()._has_bits_);
  static void set_has_attendee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PrimaryMeetingJoinAckFrame::PrimaryMeetingJoinAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.PrimaryMeetingJoinAckFrame)
}
PrimaryMeetingJoinAckFrame::PrimaryMeetingJoinAckFrame(const PrimaryMeetingJoinAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_attendee_id()) {
    attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_attendee_id(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.PrimaryMeetingJoinAckFrame)
}

void PrimaryMeetingJoinAckFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto.base);
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

PrimaryMeetingJoinAckFrame::~PrimaryMeetingJoinAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.PrimaryMeetingJoinAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PrimaryMeetingJoinAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  attendee_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PrimaryMeetingJoinAckFrame::ArenaDtor(void* object) {
  PrimaryMeetingJoinAckFrame* _this = reinterpret_cast< PrimaryMeetingJoinAckFrame* >(object);
  (void)_this;
}
void PrimaryMeetingJoinAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrimaryMeetingJoinAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PrimaryMeetingJoinAckFrame& PrimaryMeetingJoinAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PrimaryMeetingJoinAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void PrimaryMeetingJoinAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.PrimaryMeetingJoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attendee_id_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrimaryMeetingJoinAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string attendee_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_attendee_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PrimaryMeetingJoinAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.PrimaryMeetingJoinAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string attendee_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_attendee_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.PrimaryMeetingJoinAckFrame)
  return target;
}

size_t PrimaryMeetingJoinAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.PrimaryMeetingJoinAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string attendee_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_attendee_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrimaryMeetingJoinAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PrimaryMeetingJoinAckFrame*>(
      &from));
}

void PrimaryMeetingJoinAckFrame::MergeFrom(const PrimaryMeetingJoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.PrimaryMeetingJoinAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attendee_id()) {
    _internal_set_attendee_id(from._internal_attendee_id());
  }
}

void PrimaryMeetingJoinAckFrame::CopyFrom(const PrimaryMeetingJoinAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.PrimaryMeetingJoinAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimaryMeetingJoinAckFrame::IsInitialized() const {
  return true;
}

void PrimaryMeetingJoinAckFrame::InternalSwap(PrimaryMeetingJoinAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  attendee_id_.Swap(&other->attendee_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string PrimaryMeetingJoinAckFrame::GetTypeName() const {
  return "signal_rtc.PrimaryMeetingJoinAckFrame";
}


// ===================================================================

class PrimaryMeetingLeaveFrame::_Internal {
 public:
};

PrimaryMeetingLeaveFrame::PrimaryMeetingLeaveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.PrimaryMeetingLeaveFrame)
}
PrimaryMeetingLeaveFrame::PrimaryMeetingLeaveFrame(const PrimaryMeetingLeaveFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:signal_rtc.PrimaryMeetingLeaveFrame)
}

void PrimaryMeetingLeaveFrame::SharedCtor() {
}

PrimaryMeetingLeaveFrame::~PrimaryMeetingLeaveFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.PrimaryMeetingLeaveFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PrimaryMeetingLeaveFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PrimaryMeetingLeaveFrame::ArenaDtor(void* object) {
  PrimaryMeetingLeaveFrame* _this = reinterpret_cast< PrimaryMeetingLeaveFrame* >(object);
  (void)_this;
}
void PrimaryMeetingLeaveFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrimaryMeetingLeaveFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PrimaryMeetingLeaveFrame& PrimaryMeetingLeaveFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PrimaryMeetingLeaveFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void PrimaryMeetingLeaveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.PrimaryMeetingLeaveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PrimaryMeetingLeaveFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PrimaryMeetingLeaveFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.PrimaryMeetingLeaveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.PrimaryMeetingLeaveFrame)
  return target;
}

size_t PrimaryMeetingLeaveFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.PrimaryMeetingLeaveFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrimaryMeetingLeaveFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PrimaryMeetingLeaveFrame*>(
      &from));
}

void PrimaryMeetingLeaveFrame::MergeFrom(const PrimaryMeetingLeaveFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.PrimaryMeetingLeaveFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void PrimaryMeetingLeaveFrame::CopyFrom(const PrimaryMeetingLeaveFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.PrimaryMeetingLeaveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimaryMeetingLeaveFrame::IsInitialized() const {
  return true;
}

void PrimaryMeetingLeaveFrame::InternalSwap(PrimaryMeetingLeaveFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string PrimaryMeetingLeaveFrame::GetTypeName() const {
  return "signal_rtc.PrimaryMeetingLeaveFrame";
}


// ===================================================================

class BridgeReserveFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BridgeReserveFrame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BridgeReserveFrame::BridgeReserveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.BridgeReserveFrame)
}
BridgeReserveFrame::BridgeReserveFrame(const BridgeReserveFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_request_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_request_token()) {
    client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_request_token(),
      GetArena());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&action_) -
    reinterpret_cast<char*>(&type_)) + sizeof(action_));
  // @@protoc_insertion_point(copy_constructor:signal_rtc.BridgeReserveFrame)
}

void BridgeReserveFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BridgeReserveFrame_video_5fcontrol_2eproto.base);
  client_request_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  action_ = 1;
}

BridgeReserveFrame::~BridgeReserveFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.BridgeReserveFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void BridgeReserveFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  client_request_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BridgeReserveFrame::ArenaDtor(void* object) {
  BridgeReserveFrame* _this = reinterpret_cast< BridgeReserveFrame* >(object);
  (void)_this;
}
void BridgeReserveFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BridgeReserveFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BridgeReserveFrame& BridgeReserveFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BridgeReserveFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void BridgeReserveFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.BridgeReserveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      client_request_token_.ClearNonDefaultToEmpty();
    }
    type_ = 1;
    action_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BridgeReserveFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .signal_rtc.BridgeReserveFrame.ReservationType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::BridgeReserveFrame_ReservationType_IsValid(val))) {
            _internal_set_type(static_cast<::signal_rtc::BridgeReserveFrame_ReservationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .signal_rtc.BridgeReserveFrame.Action action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::signal_rtc::BridgeReserveFrame_Action_IsValid(val))) {
            _internal_set_action(static_cast<::signal_rtc::BridgeReserveFrame_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string client_request_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_client_request_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BridgeReserveFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.BridgeReserveFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .signal_rtc.BridgeReserveFrame.ReservationType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .signal_rtc.BridgeReserveFrame.Action action = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_action(), target);
  }

  // optional string client_request_token = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_request_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.BridgeReserveFrame)
  return target;
}

size_t BridgeReserveFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.BridgeReserveFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string client_request_token = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_request_token());
    }

    // optional .signal_rtc.BridgeReserveFrame.ReservationType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .signal_rtc.BridgeReserveFrame.Action action = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BridgeReserveFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BridgeReserveFrame*>(
      &from));
}

void BridgeReserveFrame::MergeFrom(const BridgeReserveFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.BridgeReserveFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_request_token(from._internal_client_request_token());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      action_ = from.action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BridgeReserveFrame::CopyFrom(const BridgeReserveFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.BridgeReserveFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BridgeReserveFrame::IsInitialized() const {
  return true;
}

void BridgeReserveFrame::InternalSwap(BridgeReserveFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_request_token_.Swap(&other->client_request_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(type_, other->type_);
  swap(action_, other->action_);
}

std::string BridgeReserveFrame::GetTypeName() const {
  return "signal_rtc.BridgeReserveFrame";
}


// ===================================================================

class BridgeReserveAckFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<BridgeReserveAckFrame>()._has_bits_);
  static void set_has_client_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BridgeReserveAckFrame::BridgeReserveAckFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.BridgeReserveAckFrame)
}
BridgeReserveAckFrame::BridgeReserveAckFrame(const BridgeReserveAckFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_request_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_request_token()) {
    client_request_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_request_token(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.BridgeReserveAckFrame)
}

void BridgeReserveAckFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto.base);
  client_request_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

BridgeReserveAckFrame::~BridgeReserveAckFrame() {
  // @@protoc_insertion_point(destructor:signal_rtc.BridgeReserveAckFrame)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void BridgeReserveAckFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  client_request_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BridgeReserveAckFrame::ArenaDtor(void* object) {
  BridgeReserveAckFrame* _this = reinterpret_cast< BridgeReserveAckFrame* >(object);
  (void)_this;
}
void BridgeReserveAckFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BridgeReserveAckFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BridgeReserveAckFrame& BridgeReserveAckFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BridgeReserveAckFrame_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void BridgeReserveAckFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.BridgeReserveAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    client_request_token_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BridgeReserveAckFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_request_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_request_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BridgeReserveAckFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.BridgeReserveAckFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_request_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_request_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.BridgeReserveAckFrame)
  return target;
}

size_t BridgeReserveAckFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.BridgeReserveAckFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string client_request_token = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_request_token());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BridgeReserveAckFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BridgeReserveAckFrame*>(
      &from));
}

void BridgeReserveAckFrame::MergeFrom(const BridgeReserveAckFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.BridgeReserveAckFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_request_token()) {
    _internal_set_client_request_token(from._internal_client_request_token());
  }
}

void BridgeReserveAckFrame::CopyFrom(const BridgeReserveAckFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.BridgeReserveAckFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BridgeReserveAckFrame::IsInitialized() const {
  return true;
}

void BridgeReserveAckFrame::InternalSwap(BridgeReserveAckFrame* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_request_token_.Swap(&other->client_request_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string BridgeReserveAckFrame::GetTypeName() const {
  return "signal_rtc.BridgeReserveAckFrame";
}


// ===================================================================

class MeetingSessionCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<MeetingSessionCredentials>()._has_bits_);
  static void set_has_attendee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_external_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_join_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MeetingSessionCredentials::MeetingSessionCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:signal_rtc.MeetingSessionCredentials)
}
MeetingSessionCredentials::MeetingSessionCredentials(const MeetingSessionCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_attendee_id()) {
    attendee_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_attendee_id(),
      GetArena());
  }
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_external_user_id()) {
    external_user_id_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_external_user_id(),
      GetArena());
  }
  join_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_join_token()) {
    join_token_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_join_token(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:signal_rtc.MeetingSessionCredentials)
}

void MeetingSessionCredentials::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MeetingSessionCredentials_video_5fcontrol_2eproto.base);
  attendee_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  join_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

MeetingSessionCredentials::~MeetingSessionCredentials() {
  // @@protoc_insertion_point(destructor:signal_rtc.MeetingSessionCredentials)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void MeetingSessionCredentials::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  attendee_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  external_user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  join_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MeetingSessionCredentials::ArenaDtor(void* object) {
  MeetingSessionCredentials* _this = reinterpret_cast< MeetingSessionCredentials* >(object);
  (void)_this;
}
void MeetingSessionCredentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MeetingSessionCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MeetingSessionCredentials& MeetingSessionCredentials::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MeetingSessionCredentials_video_5fcontrol_2eproto.base);
  return *internal_default_instance();
}


void MeetingSessionCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:signal_rtc.MeetingSessionCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      attendee_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      external_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      join_token_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MeetingSessionCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string attendee_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_attendee_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string external_user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_external_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string join_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_join_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MeetingSessionCredentials::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:signal_rtc.MeetingSessionCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string attendee_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_attendee_id(), target);
  }

  // optional string external_user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_external_user_id(), target);
  }

  // optional string join_token = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_join_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:signal_rtc.MeetingSessionCredentials)
  return target;
}

size_t MeetingSessionCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:signal_rtc.MeetingSessionCredentials)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string attendee_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_attendee_id());
    }

    // optional string external_user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_external_user_id());
    }

    // optional string join_token = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_join_token());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MeetingSessionCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MeetingSessionCredentials*>(
      &from));
}

void MeetingSessionCredentials::MergeFrom(const MeetingSessionCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:signal_rtc.MeetingSessionCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attendee_id(from._internal_attendee_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_external_user_id(from._internal_external_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_join_token(from._internal_join_token());
    }
  }
}

void MeetingSessionCredentials::CopyFrom(const MeetingSessionCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:signal_rtc.MeetingSessionCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeetingSessionCredentials::IsInitialized() const {
  return true;
}

void MeetingSessionCredentials::InternalSwap(MeetingSessionCredentials* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  attendee_id_.Swap(&other->attendee_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  external_user_id_.Swap(&other->external_user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  join_token_.Swap(&other->join_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string MeetingSessionCredentials::GetTypeName() const {
  return "signal_rtc.MeetingSessionCredentials";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace signal_rtc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::signal_rtc::SignalFrame* Arena::CreateMaybeMessage< ::signal_rtc::SignalFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::SignalFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::ErrorFrame* Arena::CreateMaybeMessage< ::signal_rtc::ErrorFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::ErrorFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::ClientDetails* Arena::CreateMaybeMessage< ::signal_rtc::ClientDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::ClientDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::JoinFrame* Arena::CreateMaybeMessage< ::signal_rtc::JoinFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::JoinFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::JoinAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::JoinAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::JoinAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::BridgeJoinFrame* Arena::CreateMaybeMessage< ::signal_rtc::BridgeJoinFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::BridgeJoinFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::BridgeJoinAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::BridgeJoinAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::BridgeJoinAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::LeaveFrame* Arena::CreateMaybeMessage< ::signal_rtc::LeaveFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::LeaveFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::LeaveAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::LeaveAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::LeaveAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::SubscribeFrame* Arena::CreateMaybeMessage< ::signal_rtc::SubscribeFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::SubscribeFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::SubscribeAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::SubscribeAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::SubscribeAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::IndexFrame* Arena::CreateMaybeMessage< ::signal_rtc::IndexFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::IndexFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::PauseResumeFrame* Arena::CreateMaybeMessage< ::signal_rtc::PauseResumeFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::PauseResumeFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::BitrateFrame* Arena::CreateMaybeMessage< ::signal_rtc::BitrateFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::BitrateFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::StreamDescriptor* Arena::CreateMaybeMessage< ::signal_rtc::StreamDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::StreamDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::StreamAllocation* Arena::CreateMaybeMessage< ::signal_rtc::StreamAllocation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::StreamAllocation >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::TrackMapping* Arena::CreateMaybeMessage< ::signal_rtc::TrackMapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::TrackMapping >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::Bitrate* Arena::CreateMaybeMessage< ::signal_rtc::Bitrate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::Bitrate >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioControlFrame* Arena::CreateMaybeMessage< ::signal_rtc::AudioControlFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioControlFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioMetadataFrame* Arena::CreateMaybeMessage< ::signal_rtc::AudioMetadataFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioMetadataFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioProfileState* Arena::CreateMaybeMessage< ::signal_rtc::AudioProfileState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioProfileState >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioStreamIdInfoFrame* Arena::CreateMaybeMessage< ::signal_rtc::AudioStreamIdInfoFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioStreamIdInfoFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioStreamIdInfo* Arena::CreateMaybeMessage< ::signal_rtc::AudioStreamIdInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioStreamIdInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::PingPongFrame* Arena::CreateMaybeMessage< ::signal_rtc::PingPongFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::PingPongFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioStatusFrame* Arena::CreateMaybeMessage< ::signal_rtc::AudioStatusFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioStatusFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::Metric* Arena::CreateMaybeMessage< ::signal_rtc::Metric >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::Metric >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::StreamMetricFrame* Arena::CreateMaybeMessage< ::signal_rtc::StreamMetricFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::StreamMetricFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::ClientMetricFrame* Arena::CreateMaybeMessage< ::signal_rtc::ClientMetricFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::ClientMetricFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::DataMessageFrame* Arena::CreateMaybeMessage< ::signal_rtc::DataMessageFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::DataMessageFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::DataMessagePayload* Arena::CreateMaybeMessage< ::signal_rtc::DataMessagePayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::DataMessagePayload >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::TurnCredentials* Arena::CreateMaybeMessage< ::signal_rtc::TurnCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::TurnCredentials >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptItem* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptItem >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptEntity* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptAlternative* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptAlternative >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptAlternative >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptResult* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptResult >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscript* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscript >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscript >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::MeetingTranscriptionStatus* Arena::CreateMaybeMessage< ::signal_rtc::MeetingTranscriptionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::MeetingTranscriptionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptEvent* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::AudioTranscriptFrame* Arena::CreateMaybeMessage< ::signal_rtc::AudioTranscriptFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::AudioTranscriptFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::RemoteVideoUpdateFrame* Arena::CreateMaybeMessage< ::signal_rtc::RemoteVideoUpdateFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::RemoteVideoUpdateFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::VideoSubscriptionConfiguration* Arena::CreateMaybeMessage< ::signal_rtc::VideoSubscriptionConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::VideoSubscriptionConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::PrimaryMeetingJoinFrame* Arena::CreateMaybeMessage< ::signal_rtc::PrimaryMeetingJoinFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::PrimaryMeetingJoinFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::PrimaryMeetingJoinAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::PrimaryMeetingJoinAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::PrimaryMeetingJoinAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::PrimaryMeetingLeaveFrame* Arena::CreateMaybeMessage< ::signal_rtc::PrimaryMeetingLeaveFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::PrimaryMeetingLeaveFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::BridgeReserveFrame* Arena::CreateMaybeMessage< ::signal_rtc::BridgeReserveFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::BridgeReserveFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::BridgeReserveAckFrame* Arena::CreateMaybeMessage< ::signal_rtc::BridgeReserveAckFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::BridgeReserveAckFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::signal_rtc::MeetingSessionCredentials* Arena::CreateMaybeMessage< ::signal_rtc::MeetingSessionCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::signal_rtc::MeetingSessionCredentials >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
